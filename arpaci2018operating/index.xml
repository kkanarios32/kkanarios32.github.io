<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:uri>https://kellenkanarios.com/arpaci2018operating/</fr:uri>
    <fr:display-uri>arpaci2018operating</fr:display-uri>
    <fr:route>/arpaci2018operating/</fr:route>
    <fr:title text="Operating Systems: Three Easy Pieces">Operating Systems: Three Easy Pieces</fr:title>
    <fr:taxon>Reference</fr:taxon>
    <fr:meta name="external">https://pages.cs.wisc.edu/~remzi/OSTEP/</fr:meta>
    <fr:meta name="bibtex"><![CDATA[@article{arpaci2018operating,
  title={Operating systems: Three easy pieces},
  author={Arpaci-Dusseau, Remzi H and Arpaci-Dusseau, Andrea C},
  year={2018},
  publisher={Arpaci-Dusseau Books, LLC Madison, WI, USA}
}]]></fr:meta>
  </fr:frontmatter>
  <fr:mainmatter />
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>26</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/HN3M/</fr:uri>
            <fr:display-uri>HN3M</fr:display-uri>
            <fr:route>/HN3M/</fr:route>
            <fr:title text="TPE Scheduling cont."><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Scheduling cont.</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>In the previous section, we discussed algorithms that minimize turnaround time OR response time. Here, we will look at how to find a happy middle ground</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Multi-Level Feedback Queue">Multi-Level Feedback Queue</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The main idea is to maintain multiple queues with varying levels of priority. Each queue will then be scheduled round-robin within priority groups and lower priorities will not be scheduled until all processes of higher priority are completed. This introduces a few problems that we must remedy</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we assign priorities?</html:em>
</html:div>

<html:p>One approach is the idea of <html:em>allotment</html:em>. Essentially, each process is given an alloted amount of time at each priority. Once the process has run for the alloted amount of time at a given priority it moves down to the next priority.
</html:p>
<html:p>
Clearly, this achieves a good response time because it essentially reduces to round robin. This also does not tank performance because, if we recall that STCF is the optimal algorithm for turnaround time, we see that short jobs will still finish relatively quickly because they will spend all of their time at high priority (assuming a high enough allotment).</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We also saw in the previous section that one way to handle I/O is by breaking it into multiple jobs. However, this can result in gaming an allotment scheduler by I/O-ing right before you reach allotment essentially ensuring your process always remains the highest priority. To deal with this, we can count the total time spent by each of the jobs toward the allotment.
</fr:mainmatter></fr:tree>


 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we prevent starvation of lower priority queues?</html:em>
</html:div>

<html:p>It seems the easiest way for this is to just periodically move all processes back to the highest priority.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Proportional Share">Proportional Share</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The key idea here is rather than maintain queues of priorities we instead assign each job a certain <html:em>proportion</html:em> of the CPU time. The obvious question:</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we ensure the jobs actually match the desired proportion?</html:em>
</html:div>

The first approach is the concept of <html:em>ticket currency</html:em>. The idea is to give each user a finite amount of tickets and have them allocate them amongs their processes. 

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
They also allow <html:em>ticket transfer</html:em> and <html:em>ticket inflation</html:em>, where a process can transfer tickets i.e. client / server, or temporarily increase their number of tickets.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The benefit of the <html:em>ticket currency</html:em> approach is the simplicity of the implementation. You simply draw a random number in the range of the total number of tickets and select the process with that number.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The natural question of how to actually assign tickets is very difficult and not solved.
</fr:mainmatter></fr:tree>

<html:p><html:strong>Deterministic version:</html:strong> The ambitious observer might wonder if there is a deterministic algorithm to achieve the same effect. Luckily, the answer is actually yes! Rather than randomly sample tickets, we set the <html:em>stride</html:em> to be inversely proportional to the ticket count. We then track the <html:em>pass</html:em> (a running sum for each process that is incremented by the processes stride). To formalize-ish,
<html:ol><html:li>Choose process with lowest <html:em>pass</html:em>.</html:li>
  <html:li>Increment the chosen process pass by the process stride.</html:li>
  <html:li>Repeat.</html:li></html:ol>
We see that a low stride (high ticket count) results in being scheduled more frequently.
</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is still an advantage of lottery-based scheduling: no global state. If new processes join, it is unclear what to set their initial pass at. 
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
On linux, the user can manually set priorities using <html:code>nice</html:code> and setting the <html:em>niceness</html:em> of a process in <![CDATA[[]]>-20, 20<![CDATA[)]]>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>26</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/B8GC/</fr:uri>
            <fr:display-uri>B8GC</fr:display-uri>
            <fr:route>/B8GC/</fr:route>
            <fr:title text="TPE Scheduling"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Scheduling</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p>Toward the end of the previous section we alluded to the ominuous entity known as the <html:em>scheduler</html:em>. There is only one question that needs answering</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How should we pick what process to run at any given time?</html:em>
</html:div>
<html:p>It turns out there is no right answer to this question (at least that is my takeaway from these three sections in the book). The reason for this is the conflicting priorities of various metrics. Namely,
<html:ol><html:li><html:strong>turnaround time:</html:strong> the time to complete a process i.e.
  <fr:tex display="block"><![CDATA[T_{\text {completion}} - T_{\text {arrival}}]]></fr:tex>
  <html:li><html:strong>fairness:</html:strong> this is computed according to some arbitrary index. However, the main idea is that worst case jobs should not be neglected</html:li>
  <html:li><html:strong>response time:</html:strong> how long it takes from issuing the command to it being scheduled.</html:li></html:li></html:ol></html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Naive First Attempts">Naive First Attempts</fr:title></fr:frontmatter><fr:mainmatter>
<html:p><html:strong>FIFO:</html:strong> A naive and fair scheduler is to just serve each job in a <html:em>first-in-first-out</html:em> manner. However this suffers from the <html:em>convoy effect</html:em>. Namely, if we consider the case where the first job is very long. Then subsequent much shorter jobs will have much longer service times than they should.</html:p>

<html:p><html:strong>SJF:</html:strong> To counteract this, we can try the <html:em>shortest job first</html:em>. If all jobs arrive at the same time, then SJF actually provably minimizes turnaround time. However, all jobs do not arrive at the same time and if the same problematic sequence for FIFO arrives sequentially it will also break SJF.</html:p>
<html:p><html:strong>STCF:</html:strong> Up to this point, we have assumed that all jobs must be run to completion. However, we can relax this assumption and allow the OS to <html:em>preempt</html:em> a job (pausing it and starting a new job). With this, we introduce <html:em>shortest to completion first</html:em>, where we periodically preempt the current running job and then schedule the job with the shortest amount of time remaining until completion.</html:p>
<html:p><html:strong>RR:</html:strong> While the previous algorithm is optimal with respect to turnaround time, it is not very good with respect to response time. In particular, long jobs may not be serviced for a very long time. The best we can do with respect to response time is just <html:em>round robin</html:em>, where we periodically randomly switch between processes. The intervals between switching are referred to as <html:em>strides</html:em> or <html:em>time slices</html:em> or <html:em>quantum lengths</html:em>.</html:p>
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Each time we switch between processes, we incur the cost of a context switch. Choosing larger time slices allows us to <html:em>amortize</html:em> this cost.
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Prior to this, we had been ignoring I/O of the processes. A very simple way to not suffer substantial performance loss due to I/O is to simply divide the process up into its non I/O components and schedule them individually.
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Partial Homework Solutions">Partial Homework Solutions</fr:title></fr:frontmatter><fr:mainmatter>
<html:ol><html:li>For what types of workloads does SJF deliver the same turnaround as FIFO?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  For workloads that arrive in increasing order of total job time.
  </fr:mainmatter></fr:tree>

  <html:li>For what types of workloads and quantum lengths does SJF deliver the same response times as RR?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  For shorter jobs and longer quantum lengths, RR and SJF should deliver similar response times.
  </fr:mainmatter></fr:tree>

  <html:li>What happens to response time with SJF as job lengths increase?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Response time degrades because the longest jobs have to wait for each of the shorter jobs to finish. If these shorter jobs become longer than the response time grows linearly(?).
  </fr:mainmatter></fr:tree>

  <html:li>What happens to response time with RR as quantum lengths increase? Can you write an equation that gives the worst-case response time, given <fr:tex display="inline"><![CDATA[N]]></fr:tex> jobs?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    The response time is the average over stride length number of preceding jobs. The formula can be written as
    <fr:tex display="block"><![CDATA[\mathrm {RT} = \frac {1}{N} \sum _{i = 1}^{N} (i - 1)S = \frac {S(N - 1) N}{N} = S(N - 1)]]></fr:tex>
  </fr:mainmatter></fr:tree></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>19</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/VE8C/</fr:uri>
            <fr:display-uri>VE8C</fr:display-uri>
            <fr:route>/VE8C/</fr:route>
            <fr:title text="TPE Limited Direct Execution"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Limited Direct Execution</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (7/66)</html:p><html:p>The contents of this chapter were revolved around two fundamental questions:</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:ol><html:li><html:em>How do we make sure a program doesn't do what we don't want it to do?</html:em></html:li>
    <html:li><html:em>How do we enable timesharing?</html:em></html:li></html:ol>
</html:div>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="modes">modes</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>For the first question, we introduce two modes <html:em>user mode</html:em> and <html:em>kernel mode</html:em>. In <html:em>user mode</html:em>, we are restricted with what sort of operations we can run.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
More importantly, in user mode, we are limited with what we can <html:em>see</html:em>. We will see later on in memory, but in user mode we have a limited address space allocated for the current process. However, in kernel mode, the address space is the entire computer and can therefore be very dangerous if we are not careful.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  How do we switch from user and kernel mode without allowing processes to run instructions in kernel mode?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  We must have some cooperation from the hardware. Namely, on boot, the OS code is run and sets up a <html:em>trap table</html:em>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="trapping">trapping</fr:title></fr:frontmatter><fr:mainmatter>
The hardware has some responsibility when switching to kernel mode. Namely, it must store two types of registers (1) user registers (2) kernel register.
<html:ol><html:li>The user registers are registers that contain the current program context i.e. stack variables, such as <html:code>x = 1</html:code>.</html:li>
  <html:li>The kernel registers hold more meta-information, such as the PC, the syscall number of the calling syscall, etc.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Each time we return to a process or switch between processes the hardware must perform a <html:em>context switch</html:em>. This is when they store all of the context of the current program before replacing it with the context of another program. The cost of such a switch is the tradeoff when performing <html:em>scheduling</html:em> of processes.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="syscall implementation">syscall implementation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
In order to implement the syscall, there needs to be some pre-agreed upon arrangement on where certain things go. For example, the syscall number must be stored in a pre-defined register. The general procedure (I think?) is as follows:
  </html:p>
<html:ol><html:li>syscall calls trap instruction defined by hardware.</html:li>
  <html:li>hardware stores all information necessary to restore processes in pre-determined location.</html:li>
  <html:li>hardware switches to kernel mode from user mode.</html:li>
  <html:li>hardware jumps to code in OS to handle syscall (trap handler / interrupt handler?).</html:li>
  <html:li>OS code checks pre-arranged register for the syscall number</html:li>
  <html:li>OS executes corresponding syscall code.</html:li>
  <html:li>OS restores program.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Due to relying on pre-determined registers, the syscalls are typically hand coded in assembly.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The OS must also perform checks regarding the safety of the requested operation i.e. we cannot let a process read the kernel code...
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is a similar mechanism for interrupts via an interrupt handler.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="timesharing">timesharing</fr:title></fr:frontmatter><fr:mainmatter>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  If the CPU is running a process, then how can the kernel decide to stop running it?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
It can't... Instead the hardware performs period interrupts that trap to the OS code. The OS code can then decide what process to run via the <html:em>scheduler</html:em> (next section).
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="booting up">booting up</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>This section is a summary of my findings:</html:p>
<html:ol><html:li>Power signals reset of CPU state.</html:li>
  <html:li>CPU runs BIOS, which checks that hardware works.</html:li>
  <html:li>BIOS then runs bootloader (i.e. grub).</html:li>
  <html:li>Bootloader places kernel code in right place and runs it.</html:li>
  <html:li>Kernel then specifies things like trap table location (which is a special hardware instruction). Also must set timer.</html:li></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/0084/</fr:uri>
            <fr:display-uri>0084</fr:display-uri>
            <fr:route>/0084/</fr:route>
            <fr:title text="Notebook: Three Easy Pieces">Notebook: <fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">Three Easy Pieces</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Part of my <fr:link href="/004H/" title="The Computer in Computer Science" uri="https://kellenkanarios.com/004H/" display-uri="004H" type="local">revisiting CS fundamentals journey</fr:link></html:p>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>6</fr:month>
                  <fr:day>23</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/007V/</fr:uri>
                <fr:display-uri>007V</fr:display-uri>
                <fr:route>/007V/</fr:route>
                <fr:title text="TPE Processes"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Processes</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (1/66)</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="The Abstraction">The Abstraction</fr:title></fr:frontmatter><fr:mainmatter>
<html:p><html:em>A process</html:em> consists of a few primary components
<html:ol><html:li><html:strong>Memory</html:strong>: each process requires its own portion of memory for (i) to store the instructions of the program to execute and (ii) for the memory required by the calling program. This is referred to as the <html:em>address space</html:em>.</html:li>
  <html:li><html:strong>Registers</html:strong>: for those familiar with computers, instructions typically deal with registers, where information is loaded from memory into registers to perform computation. Additionally, there are special registers reserved for certain mechanisms i.e.
  <html:ul><html:li><html:strong>Program Counter (PC)</html:strong>: This register is in charge of telling us what instruction we are currently on in the executing program.</html:li>
    <html:li><html:strong>Stack and Frame Pointer:</html:strong> Used to manage where we currently are on the stack.</html:li></html:ul></html:li></html:ol></html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Process API">Process API</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>In order to implement a process, one must support each of the following operations</html:p>
  <html:ol><html:li><html:strong>Create:</html:strong> <html:p>The operating system must implement a mechanism to create a process. This consists of loading the program from disk, initializing memory (i.e. stack and heap), and jumping to <html:code>main</html:code> (typically).</html:p></html:li>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The stack is allocated up front and does not change. However, typically a small amount of memory is allocated for the heap and it grows via <html:code>malloc</html:code>. This is non-trivial because if <html:code>malloc</html:code> is called without available heap memory then memory must be allocated by the OS. I need to look into <fr:link href="https://gee.cs.oswego.edu/dl/html/malloc.html" type="external">how</fr:link> this is done more.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  The OS will also initialize the parameters to <html:code>main</html:code> i.e. <html:code>argc</html:code> or <html:code>argv</html:code>.
</fr:mainmatter></fr:tree>

    <html:li><html:strong>Destroy:</html:strong> Clearly, if a process is misbehaved or the user just does not want it to run any longer, there must be some mechanism to <html:em>kill</html:em> the process.
      </html:li>
    <html:li><html:strong>Wait:</html:strong> In the case of dependencies (piping?), it may be useful to wait for a process to complete.
      </html:li>
    <html:li><html:strong>Miscellaneous Control:</html:strong> The example provided in the book is to <html:em>suspend</html:em> a process.
      </html:li>
    <html:li><html:strong>Status:</html:strong> It is helpful to be able to get information about running processes.
    </html:li></html:ol>
<html:p>There are also process <html:em>states</html:em>. These states are <html:strong>running</html:strong>, <html:strong>ready</html:strong>, and <html:strong>blocked</html:strong>. These states are pretty self-explanatory.
  </html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Data Structures">Data Structures</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>It seems throughout the book we will be seeing implementation examples from the smaller <fr:link href="https://github.com/mit-pdos/xv6-public" type="external">xv6</fr:link> OS.</html:p>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  In addition to the process implementation below, there is also a data structure that must keep track of all the processes. This is the <html:strong>process list</html:strong> or <html:strong>process control block</html:strong>.
  </fr:mainmatter></fr:tree>

<html:p><html:pre><![CDATA[// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
  char *mem; // Start of process memory
  uint sz; // Size of process memory
  char *kstack; // Bottom of kernel stack for this process
  enum proc_state state; // Process state
  int pid; // Process ID
  struct proc *parent; // Parent process
  void *chan; // If non-zero, sleeping on chan
  int killed; // If non-zero, have been killed
  struct file *ofile[NOFILE]; // Open files
  struct inode *cwd; // Current directory
  struct context context; // Switch here to run process
  struct trapframe *tf; // Trap frame for the current interrupt
};]]></html:pre></html:p>
</fr:mainmatter></fr:tree>

  

  <fr:tree show-metadata="false" expanded="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Homework">Homework</fr:title></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Run <html:code>process.py</html:code> with the flags <html:code>-l 5:100, 5:100</html:code>. What should the CPU utilization be?
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>The flags correspond to running two processes each with <fr:tex display="inline"><![CDATA[5]]></fr:tex> instructions where each instruction has probability one of using the CPU. The output from the program is 
    <html:pre><![CDATA[  Process 0
    cpu
    cpu
    cpu
    cpu
    cpu

  Process 1
    cpu
    cpu
    cpu
    cpu
    cpu]]></html:pre>
    with this, we can conclude that the utilization is 100%. We will execute one instruction for the first process until it completes, then the five instructions of the next process. If both are waiting on IO, then I do not think this would be the case? 
    </fr:mainmatter></fr:tree>

    
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
    Using the solution flags <html:code>-cp</html:code>, there is 100% utilization. 
    </fr:mainmatter></fr:tree></html:li>
    <html:li>Run <html:code>process.py</html:code> with the flags <html:code>-l 4:100, 1:0</html:code>. How long does it take to complete both processes?
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>The flags correspond to running one process with <fr:tex display="inline"><![CDATA[4]]></fr:tex> instructions with each instruction having probability one of using the CPU and one process with one instruction that uses the IO. The output from the program is 
    <html:pre><![CDATA[Process 0
  cpu
  cpu
  cpu
  cpu

Process 1
  io
  io_done]]></html:pre>
It will take <fr:tex display="inline"><![CDATA[4 + \text {time of IO}]]></fr:tex>. Since the process with <fr:tex display="inline"><![CDATA[4]]></fr:tex> non-IO-dependent instructions will run each of those instructions and then the next process will begin which must wait for the entire duration of IO.
    </fr:mainmatter></fr:tree>

    
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>Using the <html:code>-cp</html:code> flags it takes <fr:tex display="inline"><![CDATA[11]]></fr:tex> timesteps to complete which is <fr:tex display="inline"><![CDATA[\approx  4 + \text {time of IO}]]></fr:tex>.
  </fr:mainmatter></fr:tree></html:li>
<html:li>
Now switch the order of the processes: <html:code>./process-run.py -l
1:0,4:100</html:code>. What happens now? Does switching the order mat-
ter? Why?
  
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
The output of the code is
    <html:pre><![CDATA[Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu]]></html:pre>
    Depending on the time of IO (<html:code>the -L flag</html:code>), it should take <fr:tex display="inline"><![CDATA[\max (5, 1 + \text {time IO})]]></fr:tex>. Switching the order does matter because we can run the CPU instructions while waiting for non-blocking IO. This motivates the idea of scheduling.
  </fr:mainmatter></fr:tree>

  
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
    It only takes <fr:tex display="inline"><![CDATA[7]]></fr:tex> timesteps because we are able to perform the IO operations off the CPU as expected.
  </fr:mainmatter></fr:tree></html:li>
  <html:li>
We’ll now explore some of the other flags. One important flag is <html:code>-S</html:code>, which determines how the system reacts when a process issues an I/O. With the flag set to <html:code>SWITCH_ON_END</html:code>, the system will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes, one doing I/O and the other doing CPU work? (<html:code>-l 1:0,4:100 -c -S SWITCH_ON_END</html:code>)

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The output of the code is:
<html:pre><![CDATA[Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1          
  2        BLOCKED         READY                           1
  3        BLOCKED         READY                           1
  4        BLOCKED         READY                           1
  5        BLOCKED         READY                           1
  6        BLOCKED         READY                           1
  7*   RUN:io_done         READY             1          
  8           DONE       RUN:cpu             1          
  9           DONE       RUN:cpu             1          
 10           DONE       RUN:cpu             1          
 11           DONE       RUN:cpu             1]]></html:pre>
As expected, it runs the IO process, blocking the CPU process until it is completed.
</fr:mainmatter></fr:tree></html:li>
    <html:li>Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is <html:code>WAITING</html:code> for I/O (<html:code>-l 1:0,4:100 -c -S SWITCH ON IO</html:code>). What happens now? Use <html:code>-c</html:code>
and <html:code>-p</html:code> to confirm that you are right</html:li>

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  I assume that at timestep <fr:tex display="inline"><![CDATA[1]]></fr:tex> we will still <html:code>RUN:io</html:code>. However, we will then switch the <html:code>PID: 1</html:code> for the next <fr:tex display="inline"><![CDATA[4]]></fr:tex> timesteps until it is completed. After one additional <html:code>BLOCKED</html:code> timestep, we will run <html:code>RUN:io_done</html:code> and complete both processes. 
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The output of the code is:
  <html:pre><![CDATA[Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1          
  2        BLOCKED       RUN:cpu             1             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7*   RUN:io_done          DONE             1]]></html:pre>
</fr:mainmatter></fr:tree>
 

<html:li>
One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever was running at the time keeps running. What happens when you run this combination of processes? (<html:code>./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER -c -p</html:code>) Are system resources being effectively utilized?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The resources are not efficiently utilized because we end up waiting until all of our CPU-bound processes finish before returning to the IO-bound process, which calls another <html:code>IO:run</html:code> and we do not get any concurrency benefit.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The code output is pretty long but the end output is
  <html:pre><![CDATA[Stats: Total Time 31
Stats: CPU Busy 21 (67.74%)
Stats: IO Busy  15 (48.39%)]]></html:pre>
</fr:mainmatter></fr:tree></html:li>
<html:li>
Now run the same processes, but with <html:code>-I IO RUN IMMEDIATE</html:code> set, which immediately runs the process that issued the I/O. How does this behavior differ? Why might running a process that just completed an I/O again be a good idea?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The behavior differs by returning to the IO-bound process, which can then immediately call the next <html:code>IO:run</html:code> before returning access to the CPU-bound processes, improving concurrency. In an attempt to predict the next IO call, it might be a good idea to run the process that just completed IO because it is more likely to make another IO call.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The corresponding statistics are
  <html:pre><![CDATA[Stats: Total Time 21
Stats: CPU Busy 21 (100.00%)
Stats: IO Busy  15 (71.43%)]]></html:pre>
</fr:mainmatter></fr:tree></html:li>
<html:li>
Now run with some randomly generated processes, e.g., <html:code>-s 1 -l
3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50</html:code>. See
if you can predict how the trace will turn out. What happens when
you use <html:code>-I IO RUN IMMEDIATE</html:code> vs. <html:code>-I IO RUN LATER</html:code>? What hap-
pens when you use <html:code>-S SWITCH ON IO</html:code> vs. <html:code>-S SWITCH ON END</html:code>?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  Since each instruction has a 50% chance of being CPU or I/O, I do not think there will be much benefit to <html:code>IO_RUN_LATER</html:code> vs. <html:code>IO_RUN_IMMEDIATE</html:code>. However, I believe it will be crucial to enable <html:code>-S SWITCH_ON_IO</html:code> over <html:code>-S SWITCH_ON_END</html:code> as the number of processes grow because we should always have waiting CPU instructions to run. In the case of two processes, we still may not improve that much because they will likely both be IO-bound at some point.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  For <html:code>-s 1</html:code> (aka the seed), the observed performance between <html:code>IO_RUN_IMMEDIATE</html:code> and <html:code>IO_RUN_LATER</html:code> is the same. However, we do observe an improvement on both IO and CPU usage when we enable <html:code>SWITCH_ON_IO</html:code>.
</fr:mainmatter></fr:tree></html:li></html:ol>
  </fr:mainmatter></fr:tree>

</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>1</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/007Y/</fr:uri>
                <fr:display-uri>007Y</fr:display-uri>
                <fr:route>/007Y/</fr:route>
                <fr:title text="TPE Process Interlude"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Process Interlude</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (3/66)</html:p><html:p>This was a very short chapter just introducing the actual API for some very important system calls. Namely</html:p>
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="fork()"><html:code>fork()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
The <html:em>fork</html:em> system call allows a program to duplicate itself in a new process from the current instruction. This is quite literally a duplication which entails giving the child its own
<html:ol><html:li>Address space</html:li>
  <html:li>Registers</html:li>
  <html:li>Program counter</html:li></html:ol></html:p>
<html:p>
A fork is invoked in the parent process like
  <html:pre><![CDATA[  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
    else
      printf("in parent");]]></html:pre></html:p>
<html:p>
Importantly, you identify whether you are in the child or the parent via the return value of <html:code>rc</html:code> (0 for child), (PID of child for parent).
</html:p>

    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Which process is run first (the parent or the child) is non-deterministic and depends on the CPU scheduling algorithm.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="wait()"><html:code>wait()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
  Due to the remark, we need some way to enforce ordering among parent and child. This is the motivation for the <html:em>wait</html:em> system call. Namely, when the parent calls <html:code>wait()</html:code> it tells the CPU not to schedule it until the child completes. 
  </html:p>
  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
    From the previous <fr:link href="/007V/" title="TPE Processes" uri="https://kellenkanarios.com/007V/" display-uri="007V" type="local">section</fr:link>, we saw the data structure for a process included the state. I assume <html:code>wait()</html:code> is implemented by adjusting the process state in the PCB somehow?
  </fr:mainmatter></fr:tree>

  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Doing a bit more research, it seems this is on the right track. Additionally, when a child completes it enters the <html:code>ZOMBIE</html:code> state, where it stores all the relevant information of the process, so that the parent process can then use this information. How this is actually coordinated seems to involve <html:em>signals</html:em> and <html:em>wait_entries</html:em> that essentially track all the children of a parent. The OS can then get a signal of completion from a child and find the corresponding parent?
  </fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="exec()"><html:code>exec()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
<html:p>While <html:code>fork()</html:code> is useful in the sense that it allows us to spawn new processes from a parent process, it is still limited in that it can only execute instructions following the line of the <html:code>fork()</html:code> call in the parent process.</html:p>
<html:p>In practice, we do not want to have to compile massive C projects that contain all the necessary files for every possible binary we may want to run. To get around this, we can use the <html:code>exec()</html:code> system call. <html:code>exec()</html:code> allows us to transform a process into the desired executable. What this entails:
<html:ol><html:li>Loading the code and static data for the executable and overwriting the current coad and static data.</html:li>
  <html:li>Re-initializing stack and heap memory.</html:li>
  <html:li>Running the program, where the arguments passed to <html:code>exec()</html:code> are treated as <html:code>argv</html:code> for the program.</html:li></html:ol>
For a parent process to invoke <html:code>ls</html:code>, they could do something like
  <html:pre><![CDATA[  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
      exec(ls);
    else
      printf("in parent");]]></html:pre>
  This spawns a child process and overwrites it with the <html:code>ls</html:code> executable.
</html:p>
</fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
Combining <html:code>fork()</html:code> and <html:code>exec()</html:code> is where the true power lies. In particular, with this combination you can practically implement an entire shell. Below is some (hybrid) pseudocode.
<html:pre><![CDATA[int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      exec(command);
    else
      int rc = wait(NULL);
  }]]></html:pre>
You can also implement redirection by opening a file prior to calling <html:code>exec()</html:code> i.e.
<html:pre><![CDATA[int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      close(STD_OUT_FILENO);
      open(output.txt);
      exec(command);
    else
      int rc = wait(NULL);
  }]]></html:pre>
</fr:mainmatter></fr:tree>
 

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Signals">Signals</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>They briefly mention <html:em>signals</html:em>: what I expect to be an important topic in the future. Namely, you can send a signall to a process via <html:code>kill()</html:code> and the recipient program can "catch" this signal via the system call <html:code>signal()</html:code>.
</html:p>
<html:p>This naturally leads to the introduction of a <html:em>user</html:em>. The <html:em>user</html:em> determines which processes they are allowed to signal, where the <html:em>superuser</html:em> can arbitrarily signal all processes.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Coding Homework">Coding Homework</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (6/66).</html:p>
  <html:ol><html:li>Write a program that calls <html:code>fork()</html:code>. Before calling <html:code>fork()</html:code>, have the main process access a variable (e.g., <html:code>x</html:code>) and set its value to something (e.g., 100). What value is the variable in the child process? What happens to the variable when both the child and parent change the value of <html:code>x</html:code></html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Both the parent and the child get a copy of the variable values i.e. <fr:tex display="inline"><![CDATA[x]]></fr:tex>. When they modify <fr:tex display="inline"><![CDATA[x]]></fr:tex> it only affects the copy of <fr:tex display="inline"><![CDATA[x]]></fr:tex> in their local address space.
    </fr:mainmatter></fr:tree>

    <html:li>
Write a program that opens a file (with the <html:code>open()</html:code> system call) and then calls <html:code>fork()</html:code> to create a new process. Can both the child and parent access the file descriptor returned by <html:code>open()</html:code>? What happens when they are writing to the file concurrently, i.e., at the same time?
      </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Both do have access to the same file descriptor. I believe that they can interleave writes if writing at the same time but for me whichever process got ran first always finished writing prior the other starting. This may be a scheduling thing, where one process is able to complete before the other is scheduled?
    </fr:mainmatter></fr:tree>

    <html:li>
Write another program using <html:code>fork()</html:code>. The child process should
print “hello”; the parent process should print “goodbye”. You should
try to ensure that the child process always prints first; can you do
this without calling <html:code>wait()</html:code> in the parent?
    </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Using the previous problem, in the child, we can write something to a file. Then, in the parent, we can enforce an ordering by making the parent wait in a <html:code>while</html:code> loop until it reads the value written by the child. However, this is terribly inconvenient (and probably why <html:code>wait()</html:code> exists).
    </fr:mainmatter></fr:tree>

    <html:li>
Now write a program that uses <html:code>wait()</html:code> to wait for the child process to finish in the parent. What does <html:code>wait()</html:code> return? What happens if you use <html:code>wait()</html:code> in the child?
      </html:li>
      
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
        <html:code>wait()</html:code> returns the pid of the child process that died. Using <html:code>wait()</html:code> in the child just immediately returns <fr:tex display="inline"><![CDATA[-1]]></fr:tex>.
      </fr:mainmatter></fr:tree>

      <html:li>
Write a program that calls <html:code>fork()</html:code> and then calls some form of <html:code>exec()</html:code> to run the program <html:code>/bin/ls</html:code>. See if you can try all of the variants of <html:code>exec()</html:code>, including <html:code>execl()</html:code>, <html:code>execle()</html:code>, <html:code>execlp()</html:code>, <html:code>execv()</html:code>, <html:code>execvp()</html:code>, and <html:code>execvP()</html:code>. Why do you think there are so many variants of the same basic call?
        </html:li>
        
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
          It seems that some of them support different types of arguments i.e. <html:code>execv</html:code> family allows variable size argument list. Additionally, there is a distinction in the <html:em>environment</html:em>. This seems to be a list of environment variable values that <html:code>exec{l,v}e()</html:code> will search over. The <fr:tex display="inline"><![CDATA[p]]></fr:tex> family use the same search as the shell i.e. the <html:code>PATH</html:code>.
        </fr:mainmatter></fr:tree>

    <html:li>
Write a slight modification of the previous program, this time us- ing <html:code>waitpid()</html:code> instead of <html:code>wait()</html:code>. When would <html:code>waitpid()</html:code> be useful?
    </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      If a parent process has multiple children, then <html:code>wait()</html:code> will only wait until the first one dies. <html:code>waitpid()</html:code> lets you specify waiting on a specific child process.
    </fr:mainmatter></fr:tree>

    <html:li> Write a program that creates a child process, and then in the child closes standard output (<html:code>STDOUT_FILENO</html:code>). What happens if the child calls <html:code>printf()</html:code> to print some output after closing the descriptor? </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Nothing prints in the child process. However, stdout is still open in the parent process and able to print.
    </fr:mainmatter></fr:tree>

    <html:li>
Write a program that creates two children, and connects the standard output of one to the standard input of the other, using the <html:code>pipe()</html:code> system call
      </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      This required <html:code>fflush()</html:code> for me. I am not sure if this is true in general?
    </fr:mainmatter></fr:tree></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/VE8C/</fr:uri>
                <fr:display-uri>VE8C</fr:display-uri>
                <fr:route>/VE8C/</fr:route>
                <fr:title text="TPE Limited Direct Execution"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Limited Direct Execution</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (7/66)</html:p><html:p>The contents of this chapter were revolved around two fundamental questions:</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:ol><html:li><html:em>How do we make sure a program doesn't do what we don't want it to do?</html:em></html:li>
    <html:li><html:em>How do we enable timesharing?</html:em></html:li></html:ol>
</html:div>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="modes">modes</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>For the first question, we introduce two modes <html:em>user mode</html:em> and <html:em>kernel mode</html:em>. In <html:em>user mode</html:em>, we are restricted with what sort of operations we can run.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
More importantly, in user mode, we are limited with what we can <html:em>see</html:em>. We will see later on in memory, but in user mode we have a limited address space allocated for the current process. However, in kernel mode, the address space is the entire computer and can therefore be very dangerous if we are not careful.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  How do we switch from user and kernel mode without allowing processes to run instructions in kernel mode?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  We must have some cooperation from the hardware. Namely, on boot, the OS code is run and sets up a <html:em>trap table</html:em>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="trapping">trapping</fr:title></fr:frontmatter><fr:mainmatter>
The hardware has some responsibility when switching to kernel mode. Namely, it must store two types of registers (1) user registers (2) kernel register.
<html:ol><html:li>The user registers are registers that contain the current program context i.e. stack variables, such as <html:code>x = 1</html:code>.</html:li>
  <html:li>The kernel registers hold more meta-information, such as the PC, the syscall number of the calling syscall, etc.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Each time we return to a process or switch between processes the hardware must perform a <html:em>context switch</html:em>. This is when they store all of the context of the current program before replacing it with the context of another program. The cost of such a switch is the tradeoff when performing <html:em>scheduling</html:em> of processes.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="syscall implementation">syscall implementation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
In order to implement the syscall, there needs to be some pre-agreed upon arrangement on where certain things go. For example, the syscall number must be stored in a pre-defined register. The general procedure (I think?) is as follows:
  </html:p>
<html:ol><html:li>syscall calls trap instruction defined by hardware.</html:li>
  <html:li>hardware stores all information necessary to restore processes in pre-determined location.</html:li>
  <html:li>hardware switches to kernel mode from user mode.</html:li>
  <html:li>hardware jumps to code in OS to handle syscall (trap handler / interrupt handler?).</html:li>
  <html:li>OS code checks pre-arranged register for the syscall number</html:li>
  <html:li>OS executes corresponding syscall code.</html:li>
  <html:li>OS restores program.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Due to relying on pre-determined registers, the syscalls are typically hand coded in assembly.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The OS must also perform checks regarding the safety of the requested operation i.e. we cannot let a process read the kernel code...
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is a similar mechanism for interrupts via an interrupt handler.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="timesharing">timesharing</fr:title></fr:frontmatter><fr:mainmatter>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  If the CPU is running a process, then how can the kernel decide to stop running it?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
It can't... Instead the hardware performs period interrupts that trap to the OS code. The OS code can then decide what process to run via the <html:em>scheduler</html:em> (next section).
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="booting up">booting up</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>This section is a summary of my findings:</html:p>
<html:ol><html:li>Power signals reset of CPU state.</html:li>
  <html:li>CPU runs BIOS, which checks that hardware works.</html:li>
  <html:li>BIOS then runs bootloader (i.e. grub).</html:li>
  <html:li>Bootloader places kernel code in right place and runs it.</html:li>
  <html:li>Kernel then specifies things like trap table location (which is a special hardware instruction). Also must set timer.</html:li></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/B8GC/</fr:uri>
                <fr:display-uri>B8GC</fr:display-uri>
                <fr:route>/B8GC/</fr:route>
                <fr:title text="TPE Scheduling"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Scheduling</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Toward the end of the previous section we alluded to the ominuous entity known as the <html:em>scheduler</html:em>. There is only one question that needs answering</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How should we pick what process to run at any given time?</html:em>
</html:div>
<html:p>It turns out there is no right answer to this question (at least that is my takeaway from these three sections in the book). The reason for this is the conflicting priorities of various metrics. Namely,
<html:ol><html:li><html:strong>turnaround time:</html:strong> the time to complete a process i.e.
  <fr:tex display="block"><![CDATA[T_{\text {completion}} - T_{\text {arrival}}]]></fr:tex>
  <html:li><html:strong>fairness:</html:strong> this is computed according to some arbitrary index. However, the main idea is that worst case jobs should not be neglected</html:li>
  <html:li><html:strong>response time:</html:strong> how long it takes from issuing the command to it being scheduled.</html:li></html:li></html:ol></html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Naive First Attempts">Naive First Attempts</fr:title></fr:frontmatter><fr:mainmatter>
<html:p><html:strong>FIFO:</html:strong> A naive and fair scheduler is to just serve each job in a <html:em>first-in-first-out</html:em> manner. However this suffers from the <html:em>convoy effect</html:em>. Namely, if we consider the case where the first job is very long. Then subsequent much shorter jobs will have much longer service times than they should.</html:p>

<html:p><html:strong>SJF:</html:strong> To counteract this, we can try the <html:em>shortest job first</html:em>. If all jobs arrive at the same time, then SJF actually provably minimizes turnaround time. However, all jobs do not arrive at the same time and if the same problematic sequence for FIFO arrives sequentially it will also break SJF.</html:p>
<html:p><html:strong>STCF:</html:strong> Up to this point, we have assumed that all jobs must be run to completion. However, we can relax this assumption and allow the OS to <html:em>preempt</html:em> a job (pausing it and starting a new job). With this, we introduce <html:em>shortest to completion first</html:em>, where we periodically preempt the current running job and then schedule the job with the shortest amount of time remaining until completion.</html:p>
<html:p><html:strong>RR:</html:strong> While the previous algorithm is optimal with respect to turnaround time, it is not very good with respect to response time. In particular, long jobs may not be serviced for a very long time. The best we can do with respect to response time is just <html:em>round robin</html:em>, where we periodically randomly switch between processes. The intervals between switching are referred to as <html:em>strides</html:em> or <html:em>time slices</html:em> or <html:em>quantum lengths</html:em>.</html:p>
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Each time we switch between processes, we incur the cost of a context switch. Choosing larger time slices allows us to <html:em>amortize</html:em> this cost.
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Prior to this, we had been ignoring I/O of the processes. A very simple way to not suffer substantial performance loss due to I/O is to simply divide the process up into its non I/O components and schedule them individually.
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Partial Homework Solutions">Partial Homework Solutions</fr:title></fr:frontmatter><fr:mainmatter>
<html:ol><html:li>For what types of workloads does SJF deliver the same turnaround as FIFO?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  For workloads that arrive in increasing order of total job time.
  </fr:mainmatter></fr:tree>

  <html:li>For what types of workloads and quantum lengths does SJF deliver the same response times as RR?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  For shorter jobs and longer quantum lengths, RR and SJF should deliver similar response times.
  </fr:mainmatter></fr:tree>

  <html:li>What happens to response time with SJF as job lengths increase?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Response time degrades because the longest jobs have to wait for each of the shorter jobs to finish. If these shorter jobs become longer than the response time grows linearly(?).
  </fr:mainmatter></fr:tree>

  <html:li>What happens to response time with RR as quantum lengths increase? Can you write an equation that gives the worst-case response time, given <fr:tex display="inline"><![CDATA[N]]></fr:tex> jobs?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    The response time is the average over stride length number of preceding jobs. The formula can be written as
    <fr:tex display="block"><![CDATA[\mathrm {RT} = \frac {1}{N} \sum _{i = 1}^{N} (i - 1)S = \frac {S(N - 1) N}{N} = S(N - 1)]]></fr:tex>
  </fr:mainmatter></fr:tree></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/HN3M/</fr:uri>
                <fr:display-uri>HN3M</fr:display-uri>
                <fr:route>/HN3M/</fr:route>
                <fr:title text="TPE Scheduling cont."><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Scheduling cont.</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>In the previous section, we discussed algorithms that minimize turnaround time OR response time. Here, we will look at how to find a happy middle ground</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Multi-Level Feedback Queue">Multi-Level Feedback Queue</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The main idea is to maintain multiple queues with varying levels of priority. Each queue will then be scheduled round-robin within priority groups and lower priorities will not be scheduled until all processes of higher priority are completed. This introduces a few problems that we must remedy</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we assign priorities?</html:em>
</html:div>

<html:p>One approach is the idea of <html:em>allotment</html:em>. Essentially, each process is given an alloted amount of time at each priority. Once the process has run for the alloted amount of time at a given priority it moves down to the next priority.
</html:p>
<html:p>
Clearly, this achieves a good response time because it essentially reduces to round robin. This also does not tank performance because, if we recall that STCF is the optimal algorithm for turnaround time, we see that short jobs will still finish relatively quickly because they will spend all of their time at high priority (assuming a high enough allotment).</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We also saw in the previous section that one way to handle I/O is by breaking it into multiple jobs. However, this can result in gaming an allotment scheduler by I/O-ing right before you reach allotment essentially ensuring your process always remains the highest priority. To deal with this, we can count the total time spent by each of the jobs toward the allotment.
</fr:mainmatter></fr:tree>


 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we prevent starvation of lower priority queues?</html:em>
</html:div>

<html:p>It seems the easiest way for this is to just periodically move all processes back to the highest priority.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Proportional Share">Proportional Share</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The key idea here is rather than maintain queues of priorities we instead assign each job a certain <html:em>proportion</html:em> of the CPU time. The obvious question:</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we ensure the jobs actually match the desired proportion?</html:em>
</html:div>

The first approach is the concept of <html:em>ticket currency</html:em>. The idea is to give each user a finite amount of tickets and have them allocate them amongs their processes. 

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
They also allow <html:em>ticket transfer</html:em> and <html:em>ticket inflation</html:em>, where a process can transfer tickets i.e. client / server, or temporarily increase their number of tickets.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The benefit of the <html:em>ticket currency</html:em> approach is the simplicity of the implementation. You simply draw a random number in the range of the total number of tickets and select the process with that number.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The natural question of how to actually assign tickets is very difficult and not solved.
</fr:mainmatter></fr:tree>

<html:p><html:strong>Deterministic version:</html:strong> The ambitious observer might wonder if there is a deterministic algorithm to achieve the same effect. Luckily, the answer is actually yes! Rather than randomly sample tickets, we set the <html:em>stride</html:em> to be inversely proportional to the ticket count. We then track the <html:em>pass</html:em> (a running sum for each process that is incremented by the processes stride). To formalize-ish,
<html:ol><html:li>Choose process with lowest <html:em>pass</html:em>.</html:li>
  <html:li>Increment the chosen process pass by the process stride.</html:li>
  <html:li>Repeat.</html:li></html:ol>
We see that a low stride (high ticket count) results in being scheduled more frequently.
</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is still an advantage of lottery-based scheduling: no global state. If new processes join, it is unclear what to set their initial pass at. 
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
On linux, the user can manually set priorities using <html:code>nice</html:code> and setting the <html:em>niceness</html:em> of a process in <![CDATA[[]]>-20, 20<![CDATA[)]]>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/SAYD/</fr:uri>
                <fr:display-uri>SAYD</fr:display-uri>
                <fr:route>/SAYD/</fr:route>
                <fr:title text="Memory Intro">Memory Intro</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>
We are now moving on from scheduling into the wonderful world of all things memory.
  </html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Address Spaces">Address Spaces</fr:title></fr:frontmatter><fr:mainmatter>
If we think about what we have done so far, we have an assortment of processes that are constantly being switched between. However, each of these process has their own assortment of register states, but more importantly they each have their own state in <html:em>memory</html:em>.
<html:ol><html:li>For register states, the OS has its own reserved memory, where it can easily store and switch between register states.</html:li>
  <html:li>For memory, when we switch processes, are we expected to clear out memory for the next process by storing to disk? <html:strong>NO!</html:strong></html:li></html:ol>
This motivates the idea behind <html:em>address spaces</html:em>. Namely, each process is given its own address space (chunk in memory) to use at its own discretion. This will then ensure that other processes do not overwrite the program state of one another. The address space of a process typically consists of three components
<html:ol><html:li>Code of the program</html:li>
  <html:li>Stack: local var, arguments, return values</html:li>
  <html:li>Heap: dynamically allocated memory</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
As we will see later, every address we see is actually <html:em>virtual</html:em>, meaning it is not the location in physical memory.
</fr:mainmatter></fr:tree>

<html:p><html:strong>API:</html:strong> We only really need two methods, a way to get memory and a way to release memory. These are implemented via <html:code>malloc</html:code> and <html:code>free</html:code>. However, the use of these is usually accompanied with a handful of common errors:</html:p>
<html:ol><html:li>Forget to initialize mem.</html:li>
  <html:li>Forget to free mem.</html:li>
  <html:li>Freeing memory early: <html:em>dangling pointer</html:em>.</html:li>
  <html:li>Freeing the same memory twice: <html:em>double free</html:em>.</html:li>
  <html:li>Passing something not allocated earlier: <html:em>invalid free</html:em>.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
When a process dies, the OS reclaims all of that process memory. This means that as long as your program memory is bounded, leakage will not do any sort of catastrophic damage. However, it is still not good practice.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:code>malloc</html:code> and <html:code>free</html:code> are not syscalls. The heap is pre-allocated with some allotment of memory. If the program exceeds this memory then <html:code>malloc</html:code> will call a syscall <html:code>brk</html:code> / <html:code>sbrk</html:code> to increment / decrement heap mem pointer.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
You can actually initialize and use your own heap-like memory through <html:code>mmap</html:code>. This memory is not associated with any particular file and is an <html:em>anonymous</html:em> memory region within your program.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Address Translation">Address Translation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>The next question is once each program has their own address space, how do we unify the experience for the user.</html:p>
  <html:ol><html:li>We want every process to have the <html:em>illusion</html:em> that is starts at address <fr:tex display="inline"><![CDATA[0]]></fr:tex></html:li>
    <html:li>We want every process to have the <html:em>illusion</html:em> of a large address space.</html:li></html:ol>
  <html:p>However, we also do not want to give up the protection / speed of the address space abstraction. The overarching idea is <html:em>virualizing</html:em> the address space. This means that the address the user sees is not the true address in physical memory. How we achieve this will be a longstanding topic for the next few entries of these notes.</html:p>
  <html:p><html:strong>Base and Bounds:</html:strong> The first approach is <html:em>base and bounds</html:em>. For this approach, the hardware has a dedicated base and bound register to indicate where the address space for a given process begins and ends. It is the OSes job to ensure that these registers are filled with the correct values for the current process.
  <html:ul><html:li>The hardware must provide protected instructions to allow the OS to modify the base and bound registers.</html:li></html:ul></html:p>
  <html:p>An <html:em>address translation</html:em> is then performed by the hardware by adding the base to the virtual address and checking it remains within the bounds. This is done by the <html:em>memory management unit</html:em> (MMU). A common theme we will see is that hardware support is crucial to achieve good virtualization.</html:p>
  
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
    <html:strong>Problem:</html:strong> <html:em>to support a large addres space with base and bounds we suffer significant <html:em>internal fragmentation</html:em> i.e. in between the base and bound there is a lot of unused memory.</html:em>
  </html:div>

  <html:p>To better understand why fragmentation is such an issue: if we have 16kb total memory and each process requests 4kb but only uses 2kb, then we can only maintain 4 processes despite having the memory to service 8! To attempt to remedy this, we will introduce the idea of <html:em>segmentation</html:em>.</html:p> 
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Segmentation">Segmentation</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>Instead of pre-allocating the memory between the heap and stack, why don't we <html:em>allocate on demand</html:em>. To do so, we can treat the code, heap, and stack as their own <html:em>segments</html:em> with their own base and bound registers. An address could then be decomposed as 
<fr:tex display="block"><![CDATA[\underbrace {0 1}_{\text {segment}}\underbrace {0 1 \cdots  11}_{\text {offset}}]]></fr:tex>
This also enables an idea of <html:em>memory sharing</html:em>, where process can share a portion of memory (such as the code) to save memory on the system.
<html:ul><html:li>Need to add a protection bit to indicate whether a process can modify certain addrs.</html:li></html:ul></html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
This limits flexibility in the sense that we have no control over where the middle region was allocated and therefore we cannot grow beyond the initial bound.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The hardware also has to support the stack growing backwards when it checks the bounds. To do so, it has to perform an additional check based on the segment number.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/67X5/</fr:uri>
                <fr:display-uri>67X5</fr:display-uri>
                <fr:route>/67X5/</fr:route>
                <fr:title text="Free-Space Management">Free-Space Management</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>We have been talking a lot about how to abstract physical address to provide ease of use for the programmer. However, we have yet to discuss how to actually allocate these physical addresses in the first place. When allocating memory, there are a few issues we need to be careful about
<html:ol><html:li><html:em>External fragmentation</html:em>: lots of small unallocated non-contiguous chunks of memory.</html:li>
  <html:li><html:em>Internal fragmentation</html:em>: allocated memory that is unused in the process it is allocated for.</html:li></html:ol>
To start, we make a few simplifying assumptions:
<html:ol><html:li>After memory has been allocated, it cannot be moved.</html:li>
  <html:li>The size of memory is fixed.</html:li>
  <html:li>The user does not specify the size in <html:code>free</html:code>.</html:li></html:ol>
First, we can quickly deal with the last problem by introducing a <html:em>header</html:em>. The OS stores additional metadata, such as the size of the allocated memory in a header directly preceding the returned pointer in memory.
<html:ul><html:li>If <html:code>int* x = malloc(sizeof(int))</html:code> then <html:code>header = (header_t)* x - 1</html:code>.</html:li>
  <html:li>OS needs to find memory for the requested memory + size of the header.</html:li></html:ul></html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Malloc Policies">Malloc Policies</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The general allocation algorithm consists of maintaining some <html:em>free-list</html:em> that contains the address and length of free memory. An allocation is done by some policy over this list. When memory is re-claimed, the list is searched for adjacent memory and if it is found then it is <html:em>coalesced</html:em> into a larger chunk of free memory.</html:p>
<html:ol><html:li><html:em>Best fit</html:em>: find smallest chunk that is big enough</html:li>
  <html:ul><html:li>leaves lots of small chunks</html:li></html:ul>
  <html:li><html:em>Worst fit</html:em>: find largest chunk</html:li></html:ol>
Both of these require searching the entire list, so instead we can introduce some heuristics.
<html:ol><html:li><html:em>First fit</html:em>: find first block that can service.</html:li>
  <html:li><html:em>Next fit</html:em>: find first block that can service starting from the previous allocation.</html:li></html:ol>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Segregated Lists">Segregated Lists</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>Outside of the allocation policy, we can make data-structure level optimization. One such optimization is segmentation lists. The idea is to maintain different lists that correspond to different commonly allocated object types.</html:p>
  <html:ul><html:li>Grow list by requesting segments as multiple size of the objects.</html:li>
    <html:li>Can return to main list when no references.</html:li>
    <html:li>Can also leave objects pre-iitialized on list to eliminate calls to constructor / destructor.</html:li></html:ul>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Buddy Allocation">Buddy Allocation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>Assume memory is size <fr:tex display="inline"><![CDATA[2^n]]></fr:tex>. Search through memory to find smallest block that can service request.</html:p>
<html:figure><html:img width="50%" src="/bafkrmigwzou6llta75hya6llhd6ixa6gjzeoyjqecitht2op5xxutkjgnu.png" />
<html:figcaption>Memory <fr:tex display="inline"><![CDATA[2^n]]></fr:tex>.</html:figcaption></html:figure>
<html:p>When block is freed,
<html:ol><html:li>Check if the buddy is free.</html:li>
  <html:li>If the buddy is free.</html:li>
  <html:ul><html:li>Coalesce into larger block</html:li>
    <html:li>Repeat.</html:li></html:ul></html:ol>
Can easily check buddy because address differ by one bit at each level. Just modify the corresponding bit and check the free data structure (bitmap?) if the address is free. If it is then move up and check the next bit.
</html:p>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>31</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/SB61/</fr:uri>
                <fr:display-uri>SB61</fr:display-uri>
                <fr:route>/SB61/</fr:route>
                <fr:title text="Paging">Paging</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Previously, we have only dealt with memory allocations as variable sized chunks i.e. the amount of memory allocated can be anything. A simple idea to avoid the drastic fragmentation this can induce is to instead divide memory into fixed size chunks. This idea is called <html:em>paging</html:em>, where each chunk is a <html:em>page</html:em>.</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:strong>Main question:</html:strong> <html:em>how do we virtualize memory with pages?</html:em>
</html:div>
<html:p><html:strong>Idea:</html:strong> we decompose the address into a <html:em>virtual page number</html:em> (VPN) and offset i.e. 
<fr:tex display="block"><![CDATA[\underbrace {01}_{\text {VPN}}\underbrace {110\cdots  01}_{\text {offset}}]]></fr:tex>
we then maintain a datastructure to map <fr:tex display="inline"><![CDATA[\text {VPN} \mapsto  \text {PPN}]]></fr:tex>, where the PPN is the <html:em>physical page number</html:em> (we divide both virtual and physical memory into pages). We call this data structure a <html:em>page table</html:em>.
</html:p><html:p><html:strong>Problem 1:</html:strong> The page table can get ridiculously large.</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
For now, we consider a linear page table (an array with entry for each VPN). If we support a 32 bit address space with 4kb pages and each entry in the page table is 4 bytes then this is <fr:tex display="inline"><![CDATA[2^{32} / 2^{12} * 4 = 2^{22}]]></fr:tex> bytes of memory for the page table!
</fr:mainmatter></fr:tree>
 
<html:p>Before, we relied on the MMU to translate between physical and virtual addresses via simple operations like base and bound. However, there is no way the MMU could support this many arbitrary translations. Therefore, the page table itself must be stored in physical memory.</html:p><html:p>In addition to the address translation, the page table also keeps track of the following bits:
<html:ol><html:li>
Valid bit: whether this particular VPN has memory allocated to it i.e. mem between stack / heap does not need to be allocated.
  </html:li>
  <html:li>
Protection bit: determines whether the calling program can read / write / execute.
  </html:li>
  <html:li>
Present bit: whether the page currently resides in physical memory.
  </html:li>
  <html:li>
Dirty bit: has the page been modified since being paged in.
  </html:li>
  <html:li>
Reference bit: has the page been accessed (used for eviction policy).
    </html:li></html:ol></html:p><html:p><html:strong>Problem 2:</html:strong> Every time we want to perform an address translation (very often) we must
<html:ol><html:li>Compute VPN from address</html:li>
  <html:li>Access page table entry in physical memory (slow)</html:li>
  <html:li>Compute address with offset + PPN.</html:li>
  <html:li>Access corresponding physical page in physical memory.</html:li></html:ol>
This is very slow!
</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:title text="TLB">TLB</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>Due to the previously discussed issues, we need a faster way of performing address translation to make paging a feasible option. A common theme: we will throw hardware at it</html:p>
<html:p>Specifically, we will add an additional cache known as the <html:em>translation lookaside buffer</html:em> that caches address translations. Generally, an address translation proceeds as:
<html:ol><html:li>Extract VPN</html:li>
  <html:li>Check if VPN in TLB</html:li>
  <html:li>If in TLB: get translation</html:li>
  <html:li>Otherwise: TLB miss -&gt; trap to OS (RISC)</html:li></html:ol></html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We have to be a little careful. The OS code itself is located in memory and is therefore subject to our paging system. We can imagine that on TLB miss the hardware tries to load the TLB miss handler code by checking the TLB, getting the translation, and loading the code. But what if the translation for the TLB miss handler is not in the TLB?!?! To not worry about these things the TLB miss handler gets a permanent spot in physical memory.
</fr:mainmatter></fr:tree>

<html:p>Formally, an entry in the TLB consists of 
<html:ol><html:li>VPN</html:li>
  <html:li>PPN</html:li>
  <html:li>Other bits</html:li>
  <html:ul><html:li>Valid bit: has valid translation (different from PTE valid bit) can be invalid on initialization, eviction, or context switch.</html:li>
    <html:li>Protection bit: whether the requested access can be performed.</html:li></html:ul></html:ol></html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Problem</fr:taxon></fr:frontmatter><fr:mainmatter>
  Each process has different address translations corresponding to the same VPN.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  Keep additional <html:em>address space identifier</html:em> (ASID) in TLB entry. We also need an ASID register that we set at every process switch to identify the current running process.
</fr:mainmatter></fr:tree>
 

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://kellenkanarios.com/P9UM/</fr:uri><fr:display-uri>P9UM</fr:display-uri><fr:route>/P9UM/</fr:route><fr:title text="Culler's Law">Culler's Law</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:em>"Ram is not always ram"</html:em>. Referring to the fact that a physical memory access takes a substantial different amount of time depending on whether it hit in the TLB.</html:p></fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
In a real software managed TLB, the TLB consisted of the following components:
<html:ol><html:li>Global bits for globally shared pages,</html:li>
  <html:li>8 bit ASID,</html:li>
  <html:li>Coherence bits for cache-coherence,</html:li>
  <html:li>32-64 TLB entries,</html:li>
  <html:li>A wired register to indicate how many slots to reserve in the TLB for things like TLB miss handler.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Another important tidbit: when using very fast caches, even an access to the TLB is a CPU bottleneck (accessing TLB is longer than accessing cache). To get around this, there are <html:em>virtually indexed caches</html:em> that circumvent the need for performing an address translation.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:title text="Smaller Tables">Smaller Tables</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>As previously discussed, as it currently stands, the page table takes up too much memory.</html:p>
<html:p><html:strong>Solution 1:</html:strong> Just use bigger pages! Unfortunately, this will suffer from severe internal fragmentation (processes not using their allocated memory) and so we would prefer to avoid this solution.</html:p>
<html:p><html:strong>Solution 2:</html:strong> Paging + segmentation. Instead of a page table for all of memory, keep 3 page tables: one for code, stack, and heap. This only partially resolves the problem.
<html:ol><html:li>Same problems as segmentation. Variable sized page tables will cause external fragmentation</html:li>
  <html:li>We can do better. Within each heap, there is still a (smaller) version of the same problem: a bunch of unused allocated PTEs.</html:li></html:ol></html:p>
<html:p><html:strong>Multi-level page tables:</html:strong> Finally, we have arrived to the idea of a multi-level page table. The idea can be summarized as</html:p>
<html:ol><html:li>Chop page table up into pages.</html:li>
  <html:li>Do not allocated pages with no valid references (i.e. none of the corresponding are being used).</html:li></html:ol>
<html:figure><html:img width="80%" src="/bafkrmihf7gcws2u2ay4ecuwqwpgnziozltgjbsn7zo6x5bs6ismwq76jby.png" /></html:figure>
<html:p>This has a few advantages:</html:p>
<html:ol><html:li>Fits easily in memory. Allocate one page when an entry is used.</html:li> 
 <html:li>Proportional to the amount of address space actually in use.</html:li></html:ol>
<html:p>The obvious downside is the added complexity. Namely, on every TLB miss we must make two loads of memory (1) the page directory entry and (2) the page table entry.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:title text="What happens when memory is full?">What happens when memory is full?</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>We reserve space on disk for pages that cannot fit in physical memory. This is referred to as <html:em>swap space</html:em>.</html:p>
<html:p>We need to add an additional <html:em>present bit</html:em> to the PTE. On a TLB miss, the hardware (or software) will check the page table and see the present bit to indicate whether the page is in physical memory. If not, we must trap to the OS and this is known as a <html:em>page fault</html:em>.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The hardware <html:strong>never</html:strong> handles page faults because this would require understanding swap space + knowing how to perform I/O with disk.
</fr:mainmatter></fr:tree>

<html:p>Three important cases to consider:</html:p>
<html:ol><html:li>Page is <html:strong>present</html:strong> and <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Hardware can just grab physical address from PTE.</html:li></html:ul>
  <html:li>Page is not <html:strong>present</html:strong> but <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Hardware must call page fault handler to retrieve page.</html:li></html:ul>
  <html:li>Page is not <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Throw exception and likely terminate process as it is accessing invalid memory.</html:li></html:ul></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/007Y/</fr:uri>
            <fr:display-uri>007Y</fr:display-uri>
            <fr:route>/007Y/</fr:route>
            <fr:title text="TPE Process Interlude"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Process Interlude</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (3/66)</html:p><html:p>This was a very short chapter just introducing the actual API for some very important system calls. Namely</html:p>
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="fork()"><html:code>fork()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
The <html:em>fork</html:em> system call allows a program to duplicate itself in a new process from the current instruction. This is quite literally a duplication which entails giving the child its own
<html:ol><html:li>Address space</html:li>
  <html:li>Registers</html:li>
  <html:li>Program counter</html:li></html:ol></html:p>
<html:p>
A fork is invoked in the parent process like
  <html:pre><![CDATA[  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
    else
      printf("in parent");]]></html:pre></html:p>
<html:p>
Importantly, you identify whether you are in the child or the parent via the return value of <html:code>rc</html:code> (0 for child), (PID of child for parent).
</html:p>

    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Which process is run first (the parent or the child) is non-deterministic and depends on the CPU scheduling algorithm.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="wait()"><html:code>wait()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
  Due to the remark, we need some way to enforce ordering among parent and child. This is the motivation for the <html:em>wait</html:em> system call. Namely, when the parent calls <html:code>wait()</html:code> it tells the CPU not to schedule it until the child completes. 
  </html:p>
  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
    From the previous <fr:link href="/007V/" title="TPE Processes" uri="https://kellenkanarios.com/007V/" display-uri="007V" type="local">section</fr:link>, we saw the data structure for a process included the state. I assume <html:code>wait()</html:code> is implemented by adjusting the process state in the PCB somehow?
  </fr:mainmatter></fr:tree>

  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Doing a bit more research, it seems this is on the right track. Additionally, when a child completes it enters the <html:code>ZOMBIE</html:code> state, where it stores all the relevant information of the process, so that the parent process can then use this information. How this is actually coordinated seems to involve <html:em>signals</html:em> and <html:em>wait_entries</html:em> that essentially track all the children of a parent. The OS can then get a signal of completion from a child and find the corresponding parent?
  </fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="exec()"><html:code>exec()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
<html:p>While <html:code>fork()</html:code> is useful in the sense that it allows us to spawn new processes from a parent process, it is still limited in that it can only execute instructions following the line of the <html:code>fork()</html:code> call in the parent process.</html:p>
<html:p>In practice, we do not want to have to compile massive C projects that contain all the necessary files for every possible binary we may want to run. To get around this, we can use the <html:code>exec()</html:code> system call. <html:code>exec()</html:code> allows us to transform a process into the desired executable. What this entails:
<html:ol><html:li>Loading the code and static data for the executable and overwriting the current coad and static data.</html:li>
  <html:li>Re-initializing stack and heap memory.</html:li>
  <html:li>Running the program, where the arguments passed to <html:code>exec()</html:code> are treated as <html:code>argv</html:code> for the program.</html:li></html:ol>
For a parent process to invoke <html:code>ls</html:code>, they could do something like
  <html:pre><![CDATA[  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
      exec(ls);
    else
      printf("in parent");]]></html:pre>
  This spawns a child process and overwrites it with the <html:code>ls</html:code> executable.
</html:p>
</fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
Combining <html:code>fork()</html:code> and <html:code>exec()</html:code> is where the true power lies. In particular, with this combination you can practically implement an entire shell. Below is some (hybrid) pseudocode.
<html:pre><![CDATA[int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      exec(command);
    else
      int rc = wait(NULL);
  }]]></html:pre>
You can also implement redirection by opening a file prior to calling <html:code>exec()</html:code> i.e.
<html:pre><![CDATA[int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      close(STD_OUT_FILENO);
      open(output.txt);
      exec(command);
    else
      int rc = wait(NULL);
  }]]></html:pre>
</fr:mainmatter></fr:tree>
 

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Signals">Signals</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>They briefly mention <html:em>signals</html:em>: what I expect to be an important topic in the future. Namely, you can send a signall to a process via <html:code>kill()</html:code> and the recipient program can "catch" this signal via the system call <html:code>signal()</html:code>.
</html:p>
<html:p>This naturally leads to the introduction of a <html:em>user</html:em>. The <html:em>user</html:em> determines which processes they are allowed to signal, where the <html:em>superuser</html:em> can arbitrarily signal all processes.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Coding Homework">Coding Homework</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (6/66).</html:p>
  <html:ol><html:li>Write a program that calls <html:code>fork()</html:code>. Before calling <html:code>fork()</html:code>, have the main process access a variable (e.g., <html:code>x</html:code>) and set its value to something (e.g., 100). What value is the variable in the child process? What happens to the variable when both the child and parent change the value of <html:code>x</html:code></html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Both the parent and the child get a copy of the variable values i.e. <fr:tex display="inline"><![CDATA[x]]></fr:tex>. When they modify <fr:tex display="inline"><![CDATA[x]]></fr:tex> it only affects the copy of <fr:tex display="inline"><![CDATA[x]]></fr:tex> in their local address space.
    </fr:mainmatter></fr:tree>

    <html:li>
Write a program that opens a file (with the <html:code>open()</html:code> system call) and then calls <html:code>fork()</html:code> to create a new process. Can both the child and parent access the file descriptor returned by <html:code>open()</html:code>? What happens when they are writing to the file concurrently, i.e., at the same time?
      </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Both do have access to the same file descriptor. I believe that they can interleave writes if writing at the same time but for me whichever process got ran first always finished writing prior the other starting. This may be a scheduling thing, where one process is able to complete before the other is scheduled?
    </fr:mainmatter></fr:tree>

    <html:li>
Write another program using <html:code>fork()</html:code>. The child process should
print “hello”; the parent process should print “goodbye”. You should
try to ensure that the child process always prints first; can you do
this without calling <html:code>wait()</html:code> in the parent?
    </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Using the previous problem, in the child, we can write something to a file. Then, in the parent, we can enforce an ordering by making the parent wait in a <html:code>while</html:code> loop until it reads the value written by the child. However, this is terribly inconvenient (and probably why <html:code>wait()</html:code> exists).
    </fr:mainmatter></fr:tree>

    <html:li>
Now write a program that uses <html:code>wait()</html:code> to wait for the child process to finish in the parent. What does <html:code>wait()</html:code> return? What happens if you use <html:code>wait()</html:code> in the child?
      </html:li>
      
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
        <html:code>wait()</html:code> returns the pid of the child process that died. Using <html:code>wait()</html:code> in the child just immediately returns <fr:tex display="inline"><![CDATA[-1]]></fr:tex>.
      </fr:mainmatter></fr:tree>

      <html:li>
Write a program that calls <html:code>fork()</html:code> and then calls some form of <html:code>exec()</html:code> to run the program <html:code>/bin/ls</html:code>. See if you can try all of the variants of <html:code>exec()</html:code>, including <html:code>execl()</html:code>, <html:code>execle()</html:code>, <html:code>execlp()</html:code>, <html:code>execv()</html:code>, <html:code>execvp()</html:code>, and <html:code>execvP()</html:code>. Why do you think there are so many variants of the same basic call?
        </html:li>
        
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
          It seems that some of them support different types of arguments i.e. <html:code>execv</html:code> family allows variable size argument list. Additionally, there is a distinction in the <html:em>environment</html:em>. This seems to be a list of environment variable values that <html:code>exec{l,v}e()</html:code> will search over. The <fr:tex display="inline"><![CDATA[p]]></fr:tex> family use the same search as the shell i.e. the <html:code>PATH</html:code>.
        </fr:mainmatter></fr:tree>

    <html:li>
Write a slight modification of the previous program, this time us- ing <html:code>waitpid()</html:code> instead of <html:code>wait()</html:code>. When would <html:code>waitpid()</html:code> be useful?
    </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      If a parent process has multiple children, then <html:code>wait()</html:code> will only wait until the first one dies. <html:code>waitpid()</html:code> lets you specify waiting on a specific child process.
    </fr:mainmatter></fr:tree>

    <html:li> Write a program that creates a child process, and then in the child closes standard output (<html:code>STDOUT_FILENO</html:code>). What happens if the child calls <html:code>printf()</html:code> to print some output after closing the descriptor? </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Nothing prints in the child process. However, stdout is still open in the parent process and able to print.
    </fr:mainmatter></fr:tree>

    <html:li>
Write a program that creates two children, and connects the standard output of one to the standard input of the other, using the <html:code>pipe()</html:code> system call
      </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      This required <html:code>fflush()</html:code> for me. I am not sure if this is true in general?
    </fr:mainmatter></fr:tree></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>6</fr:month>
              <fr:day>23</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/007V/</fr:uri>
            <fr:display-uri>007V</fr:display-uri>
            <fr:route>/007V/</fr:route>
            <fr:title text="TPE Processes"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Processes</fr:title>
          </fr:frontmatter>
          <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (1/66)</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="The Abstraction">The Abstraction</fr:title></fr:frontmatter><fr:mainmatter>
<html:p><html:em>A process</html:em> consists of a few primary components
<html:ol><html:li><html:strong>Memory</html:strong>: each process requires its own portion of memory for (i) to store the instructions of the program to execute and (ii) for the memory required by the calling program. This is referred to as the <html:em>address space</html:em>.</html:li>
  <html:li><html:strong>Registers</html:strong>: for those familiar with computers, instructions typically deal with registers, where information is loaded from memory into registers to perform computation. Additionally, there are special registers reserved for certain mechanisms i.e.
  <html:ul><html:li><html:strong>Program Counter (PC)</html:strong>: This register is in charge of telling us what instruction we are currently on in the executing program.</html:li>
    <html:li><html:strong>Stack and Frame Pointer:</html:strong> Used to manage where we currently are on the stack.</html:li></html:ul></html:li></html:ol></html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Process API">Process API</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>In order to implement a process, one must support each of the following operations</html:p>
  <html:ol><html:li><html:strong>Create:</html:strong> <html:p>The operating system must implement a mechanism to create a process. This consists of loading the program from disk, initializing memory (i.e. stack and heap), and jumping to <html:code>main</html:code> (typically).</html:p></html:li>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The stack is allocated up front and does not change. However, typically a small amount of memory is allocated for the heap and it grows via <html:code>malloc</html:code>. This is non-trivial because if <html:code>malloc</html:code> is called without available heap memory then memory must be allocated by the OS. I need to look into <fr:link href="https://gee.cs.oswego.edu/dl/html/malloc.html" type="external">how</fr:link> this is done more.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  The OS will also initialize the parameters to <html:code>main</html:code> i.e. <html:code>argc</html:code> or <html:code>argv</html:code>.
</fr:mainmatter></fr:tree>

    <html:li><html:strong>Destroy:</html:strong> Clearly, if a process is misbehaved or the user just does not want it to run any longer, there must be some mechanism to <html:em>kill</html:em> the process.
      </html:li>
    <html:li><html:strong>Wait:</html:strong> In the case of dependencies (piping?), it may be useful to wait for a process to complete.
      </html:li>
    <html:li><html:strong>Miscellaneous Control:</html:strong> The example provided in the book is to <html:em>suspend</html:em> a process.
      </html:li>
    <html:li><html:strong>Status:</html:strong> It is helpful to be able to get information about running processes.
    </html:li></html:ol>
<html:p>There are also process <html:em>states</html:em>. These states are <html:strong>running</html:strong>, <html:strong>ready</html:strong>, and <html:strong>blocked</html:strong>. These states are pretty self-explanatory.
  </html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Data Structures">Data Structures</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>It seems throughout the book we will be seeing implementation examples from the smaller <fr:link href="https://github.com/mit-pdos/xv6-public" type="external">xv6</fr:link> OS.</html:p>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  In addition to the process implementation below, there is also a data structure that must keep track of all the processes. This is the <html:strong>process list</html:strong> or <html:strong>process control block</html:strong>.
  </fr:mainmatter></fr:tree>

<html:p><html:pre><![CDATA[// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
  char *mem; // Start of process memory
  uint sz; // Size of process memory
  char *kstack; // Bottom of kernel stack for this process
  enum proc_state state; // Process state
  int pid; // Process ID
  struct proc *parent; // Parent process
  void *chan; // If non-zero, sleeping on chan
  int killed; // If non-zero, have been killed
  struct file *ofile[NOFILE]; // Open files
  struct inode *cwd; // Current directory
  struct context context; // Switch here to run process
  struct trapframe *tf; // Trap frame for the current interrupt
};]]></html:pre></html:p>
</fr:mainmatter></fr:tree>

  

  <fr:tree show-metadata="false" expanded="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Homework">Homework</fr:title></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Run <html:code>process.py</html:code> with the flags <html:code>-l 5:100, 5:100</html:code>. What should the CPU utilization be?
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>The flags correspond to running two processes each with <fr:tex display="inline"><![CDATA[5]]></fr:tex> instructions where each instruction has probability one of using the CPU. The output from the program is 
    <html:pre><![CDATA[  Process 0
    cpu
    cpu
    cpu
    cpu
    cpu

  Process 1
    cpu
    cpu
    cpu
    cpu
    cpu]]></html:pre>
    with this, we can conclude that the utilization is 100%. We will execute one instruction for the first process until it completes, then the five instructions of the next process. If both are waiting on IO, then I do not think this would be the case? 
    </fr:mainmatter></fr:tree>

    
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
    Using the solution flags <html:code>-cp</html:code>, there is 100% utilization. 
    </fr:mainmatter></fr:tree></html:li>
    <html:li>Run <html:code>process.py</html:code> with the flags <html:code>-l 4:100, 1:0</html:code>. How long does it take to complete both processes?
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>The flags correspond to running one process with <fr:tex display="inline"><![CDATA[4]]></fr:tex> instructions with each instruction having probability one of using the CPU and one process with one instruction that uses the IO. The output from the program is 
    <html:pre><![CDATA[Process 0
  cpu
  cpu
  cpu
  cpu

Process 1
  io
  io_done]]></html:pre>
It will take <fr:tex display="inline"><![CDATA[4 + \text {time of IO}]]></fr:tex>. Since the process with <fr:tex display="inline"><![CDATA[4]]></fr:tex> non-IO-dependent instructions will run each of those instructions and then the next process will begin which must wait for the entire duration of IO.
    </fr:mainmatter></fr:tree>

    
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>Using the <html:code>-cp</html:code> flags it takes <fr:tex display="inline"><![CDATA[11]]></fr:tex> timesteps to complete which is <fr:tex display="inline"><![CDATA[\approx  4 + \text {time of IO}]]></fr:tex>.
  </fr:mainmatter></fr:tree></html:li>
<html:li>
Now switch the order of the processes: <html:code>./process-run.py -l
1:0,4:100</html:code>. What happens now? Does switching the order mat-
ter? Why?
  
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
The output of the code is
    <html:pre><![CDATA[Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu]]></html:pre>
    Depending on the time of IO (<html:code>the -L flag</html:code>), it should take <fr:tex display="inline"><![CDATA[\max (5, 1 + \text {time IO})]]></fr:tex>. Switching the order does matter because we can run the CPU instructions while waiting for non-blocking IO. This motivates the idea of scheduling.
  </fr:mainmatter></fr:tree>

  
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
    It only takes <fr:tex display="inline"><![CDATA[7]]></fr:tex> timesteps because we are able to perform the IO operations off the CPU as expected.
  </fr:mainmatter></fr:tree></html:li>
  <html:li>
We’ll now explore some of the other flags. One important flag is <html:code>-S</html:code>, which determines how the system reacts when a process issues an I/O. With the flag set to <html:code>SWITCH_ON_END</html:code>, the system will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes, one doing I/O and the other doing CPU work? (<html:code>-l 1:0,4:100 -c -S SWITCH_ON_END</html:code>)

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The output of the code is:
<html:pre><![CDATA[Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1          
  2        BLOCKED         READY                           1
  3        BLOCKED         READY                           1
  4        BLOCKED         READY                           1
  5        BLOCKED         READY                           1
  6        BLOCKED         READY                           1
  7*   RUN:io_done         READY             1          
  8           DONE       RUN:cpu             1          
  9           DONE       RUN:cpu             1          
 10           DONE       RUN:cpu             1          
 11           DONE       RUN:cpu             1]]></html:pre>
As expected, it runs the IO process, blocking the CPU process until it is completed.
</fr:mainmatter></fr:tree></html:li>
    <html:li>Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is <html:code>WAITING</html:code> for I/O (<html:code>-l 1:0,4:100 -c -S SWITCH ON IO</html:code>). What happens now? Use <html:code>-c</html:code>
and <html:code>-p</html:code> to confirm that you are right</html:li>

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  I assume that at timestep <fr:tex display="inline"><![CDATA[1]]></fr:tex> we will still <html:code>RUN:io</html:code>. However, we will then switch the <html:code>PID: 1</html:code> for the next <fr:tex display="inline"><![CDATA[4]]></fr:tex> timesteps until it is completed. After one additional <html:code>BLOCKED</html:code> timestep, we will run <html:code>RUN:io_done</html:code> and complete both processes. 
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The output of the code is:
  <html:pre><![CDATA[Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1          
  2        BLOCKED       RUN:cpu             1             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7*   RUN:io_done          DONE             1]]></html:pre>
</fr:mainmatter></fr:tree>
 

<html:li>
One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever was running at the time keeps running. What happens when you run this combination of processes? (<html:code>./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER -c -p</html:code>) Are system resources being effectively utilized?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The resources are not efficiently utilized because we end up waiting until all of our CPU-bound processes finish before returning to the IO-bound process, which calls another <html:code>IO:run</html:code> and we do not get any concurrency benefit.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The code output is pretty long but the end output is
  <html:pre><![CDATA[Stats: Total Time 31
Stats: CPU Busy 21 (67.74%)
Stats: IO Busy  15 (48.39%)]]></html:pre>
</fr:mainmatter></fr:tree></html:li>
<html:li>
Now run the same processes, but with <html:code>-I IO RUN IMMEDIATE</html:code> set, which immediately runs the process that issued the I/O. How does this behavior differ? Why might running a process that just completed an I/O again be a good idea?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The behavior differs by returning to the IO-bound process, which can then immediately call the next <html:code>IO:run</html:code> before returning access to the CPU-bound processes, improving concurrency. In an attempt to predict the next IO call, it might be a good idea to run the process that just completed IO because it is more likely to make another IO call.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The corresponding statistics are
  <html:pre><![CDATA[Stats: Total Time 21
Stats: CPU Busy 21 (100.00%)
Stats: IO Busy  15 (71.43%)]]></html:pre>
</fr:mainmatter></fr:tree></html:li>
<html:li>
Now run with some randomly generated processes, e.g., <html:code>-s 1 -l
3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50</html:code>. See
if you can predict how the trace will turn out. What happens when
you use <html:code>-I IO RUN IMMEDIATE</html:code> vs. <html:code>-I IO RUN LATER</html:code>? What hap-
pens when you use <html:code>-S SWITCH ON IO</html:code> vs. <html:code>-S SWITCH ON END</html:code>?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  Since each instruction has a 50% chance of being CPU or I/O, I do not think there will be much benefit to <html:code>IO_RUN_LATER</html:code> vs. <html:code>IO_RUN_IMMEDIATE</html:code>. However, I believe it will be crucial to enable <html:code>-S SWITCH_ON_IO</html:code> over <html:code>-S SWITCH_ON_END</html:code> as the number of processes grow because we should always have waiting CPU instructions to run. In the case of two processes, we still may not improve that much because they will likely both be IO-bound at some point.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  For <html:code>-s 1</html:code> (aka the seed), the observed performance between <html:code>IO_RUN_IMMEDIATE</html:code> and <html:code>IO_RUN_LATER</html:code> is the same. However, we do observe an improvement on both IO and CPU usage when we enable <html:code>SWITCH_ON_IO</html:code>.
</fr:mainmatter></fr:tree></html:li></html:ol>
  </fr:mainmatter></fr:tree>

</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
