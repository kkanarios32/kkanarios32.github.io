<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>2</fr:month>
      <fr:day>1</fr:day>
    </fr:date>
    <fr:uri>https://kellenkanarios.com/004D/</fr:uri>
    <fr:display-uri>004D</fr:display-uri>
    <fr:route>/004D/</fr:route>
    <fr:title text="Convex Function">Convex Function</fr:title>
    <fr:taxon>Definition</fr:taxon>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>A function <fr:tex display="inline"><![CDATA[f : C \to  \mathbb {R}]]></fr:tex> is said to be convex if <fr:tex display="inline"><![CDATA[C]]></fr:tex> is convex, and for any <fr:tex display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex>, <fr:tex display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex>, we have
<fr:tex display="block"><![CDATA[f(\lambda  x_1 + (1 - \lambda )x_2) \leq  \lambda  f(x_1) + (1 - \lambda )f(x_2)]]></fr:tex>
and strictly convex if the inequality is strict.
</html:p>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/004B/</fr:uri>
            <fr:display-uri>004B</fr:display-uri>
            <fr:route>/004B/</fr:route>
            <fr:title text="Notebook: Information Theory">Notebook: Information Theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Definitions">Definitions</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:uri>https://kellenkanarios.com/0081/</fr:uri><fr:display-uri>0081</fr:display-uri><fr:route>/0081/</fr:route><fr:title text="Entropy">Entropy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We define the <html:em>entropy</html:em> of a random variable <fr:tex display="inline"><![CDATA[X \sim  p_{X}]]></fr:tex>, where <fr:tex display="inline"><![CDATA[p_{X} : \mathcal {X} \to  [0, 1]]]></fr:tex> as 
<fr:tex display="block"><![CDATA[H(X) = -\sum _{x \in  |\mathcal {X}|} p_{X}(x) \log  p_{X}(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Lecture 5">Lecture 5</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004C/</fr:uri><fr:display-uri>004C</fr:display-uri><fr:route>/004C/</fr:route><fr:title text="Convex set">Convex set</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[C]]></fr:tex> is said to be convex if for any <fr:tex display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex> then <fr:tex display="inline"><![CDATA[\lambda  x_1 + (1 - \lambda )x_2 \in  C]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004D/</fr:uri><fr:display-uri>004D</fr:display-uri><fr:route>/004D/</fr:route><fr:title text="Convex Function">Convex Function</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A function <fr:tex display="inline"><![CDATA[f : C \to  \mathbb {R}]]></fr:tex> is said to be convex if <fr:tex display="inline"><![CDATA[C]]></fr:tex> is convex, and for any <fr:tex display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex>, <fr:tex display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex>, we have
<fr:tex display="block"><![CDATA[f(\lambda  x_1 + (1 - \lambda )x_2) \leq  \lambda  f(x_1) + (1 - \lambda )f(x_2)]]></fr:tex>
and strictly convex if the inequality is strict.
</html:p></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0034/</fr:uri><fr:display-uri>0034</fr:display-uri><fr:route>/0034/</fr:route><fr:title text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x}
\rangle ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
    This can be thought of as the tangent is always an underestimate of a convex function.
  </fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0035/</fr:uri><fr:display-uri>0035</fr:display-uri><fr:route>/0035/</fr:route><fr:title text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  This implies positive curvature or the common "bowl-shaped" interpretation.
  </fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002G/</fr:uri><fr:display-uri>002G</fr:display-uri><fr:route>/002G/</fr:route><fr:title text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex display="inline"><![CDATA[X]]></fr:tex> then <fr:tex display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
    Holds with equality if and only if 
    <html:ol><html:li><fr:tex display="inline"><![CDATA[f]]></fr:tex> is linear on <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[X]]></fr:tex> is a constant almost surely.</html:li></html:ol>
  </fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004E/</fr:uri><fr:display-uri>004E</fr:display-uri><fr:route>/004E/</fr:route><fr:title text="Gibb's inequality">Gibb's inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[D_{\mathrm {KL}}(P || Q) \geq  0]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Note that 
<fr:tex display="block"><![CDATA[
\begin {align*}
 D_{\mathrm {KL}}(P || Q) &= \mathbb {E}_P \left [\log \left (\frac {P(x)}{Q(x)}\right )\right ] \\
&= \mathbb {E}_P \left [-\log \left (\frac {Q(x)}{P(x)}\right )\right ] \\
\end {align*}
]]></fr:tex>
By <fr:link href="/002G/" title="Jensen's Inequality" uri="https://kellenkanarios.com/002G/" display-uri="002G" type="local">Jensen's Inequality</fr:link>,
<fr:tex display="block"><![CDATA[
  \begin {align*}
    D_{\mathrm {KL}}(P || Q) &\geq  -\log  \left (\mathbb {E}_P \left [\frac {Q(x)}{P(x)}\right ]\right ) = 0
  \end {align*}
]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Problem</fr:taxon></fr:frontmatter><fr:mainmatter>
  When is <fr:tex display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q) = 0]]></fr:tex>?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Need <fr:tex display="inline"><![CDATA[Q(x) / P(x)]]></fr:tex> to be constant almost surely. This occurs only when <fr:tex display="inline"><![CDATA[Q = P]]></fr:tex>. 
    <fr:tex display="block"><![CDATA[
        Q(x) / P(x) = c \implies  Q(x) = P(x) c \iff  \sum  Q(x) = c \sum  P(x) \implies  c = 1
      ]]></fr:tex>
  </fr:mainmatter></fr:tree>

  <html:strong>Applications of <fr:link href="/004E/" title="Gibb's inequality" uri="https://kellenkanarios.com/004E/" display-uri="004E" type="local">Gibb's inequality</fr:link>:</html:strong>
  <html:ul><html:li><fr:tex display="inline"><![CDATA[I(X; Y) \geq  0]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[H(X | Y) \leq  H(X)]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[H(X^n) \leq  \sum _{i = 1}^n H(X_i)]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[H(X) \leq  \log  |\mathcal {X}|]]></fr:tex></html:li></html:ul>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004F/</fr:uri><fr:display-uri>004F</fr:display-uri><fr:route>/004F/</fr:route><fr:title text="Log-Sum Inequality">Log-Sum Inequality</fr:title></fr:frontmatter><fr:mainmatter><html:p>
If <fr:tex display="inline"><![CDATA[a_{i},b_{i}>0]]></fr:tex> for <fr:tex display="inline"><![CDATA[i\in \{1,\ldots ,n\}]]></fr:tex>; <fr:tex display="inline"><![CDATA[A=\sum _{i=1}^{n}a_{i},\quad  B=\sum _{i=1}^{n}b_{i}]]></fr:tex>
Then, we have: <fr:tex display="inline"><![CDATA[\sum _{i=1}^{n}a_{i}\log  a_{i}/b_{i}\geq  A\log  A/B]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Define <fr:tex display="inline"><![CDATA[p_i = \frac {a_i}{A}]]></fr:tex>, <fr:tex display="inline"><![CDATA[q_i = \frac {b_i}{B}]]></fr:tex>, then 
<fr:tex display="block"><![CDATA[
\begin {align*}
  D_{\mathrm {KL}}(p || q) &= \sum  \frac {a_i}{A} \log {\frac {B a_i}{A b_i}} \\
  &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \sum  \frac {a_i}{A} \log {\frac {A}{B}} \\
  &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \\
\end {align*}
]]></fr:tex>
By <fr:link href="/004E/" title="Gibb's inequality" uri="https://kellenkanarios.com/004E/" display-uri="004E" type="local">Gibb's inequality</fr:link>,
<fr:tex display="block"><![CDATA[
\begin {align*}
  \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \geq  0
  &\implies 
  \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} \geq  \log {\frac {A}{B}} \\
  &\iff 
  A \sum  a_i \log {\frac {a_i}{b_i}} \geq  A \log {\frac {A}{B}}
\end {align*}
]]></fr:tex>
as desired.
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
  <html:strong>Consequences of <fr:link href="/004F/" title="Log-Sum Inequality" uri="https://kellenkanarios.com/004F/" display-uri="004F" type="local">Log-Sum Inequality</fr:link>:</html:strong>
  <html:ul><html:li>Joint convexity of <fr:tex display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>,</html:li>
      <html:li>Individual convexity of <fr:tex display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>.</html:li>
      <html:li>Concavity of entropy.</html:li></html:ul>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Lecture 7">Lecture 7</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004Y/</fr:uri><fr:display-uri>004Y</fr:display-uri><fr:route>/004Y/</fr:route><fr:title text="Maximum Aposteriori Estimator">Maximum Aposteriori Estimator</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The optimal estimator <fr:tex display="inline"><![CDATA[g^* : \mathcal {Y} \to  \mathcal {X}]]></fr:tex> is
<fr:tex display="block"><![CDATA[
\begin {align*}
  g^*(y) = \arg \max _{x \in  \mathcal {X}} P_{X | Y}(x | y)
\end {align*}
]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    Recall that
<fr:tex display="block"><![CDATA[
    \begin {align*}
      P_{e}(g) &= \sum _{x}\sum _y P_{XY}(x, y) \cdot  \mathbf {1}_{x \neq  g(y)} \\
      &= \sum _{y} P_Y(y) \sum _{x} P_{X|Y}(x|y) \mathbf {1}_{x \neq  g(y)} \\
      &= \sum _{y} P_Y(y) (1 - P_{X|Y}(g(y)|y)) \\
    \end {align*}
]]></fr:tex>
To minimize this, we take
<fr:tex display="block"><![CDATA[
  \begin {align*}
    g^*(y) = \arg \max _{x} P_{X|Y}(x | y)
  \end {align*}
]]></fr:tex>
as desired.
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Data Processing Inequality"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Data Processing Inequality</fr:title></fr:frontmatter><fr:mainmatter>
    High-level
    <html:ul><html:li><fr:tex display="inline"><![CDATA[Y]]></fr:tex> contains more information about <fr:tex display="inline"><![CDATA[X]]></fr:tex> than <fr:tex display="inline"><![CDATA[\hat {X}]]></fr:tex>.</html:li>
        <html:li>We cannot increase the amount of information about <fr:tex display="inline"><![CDATA[X]]></fr:tex> by processing <fr:tex display="inline"><![CDATA[Y]]></fr:tex>.</html:li></html:ul>
    <html:strong>Markov Chains:</html:strong>
    <html:ul><html:li><fr:tex display="inline"><![CDATA[(U, V, W)]]></fr:tex> form a Markov chain if
        <fr:tex display="block"><![CDATA[
\begin {align*}
  P(W = w \mid  U = u, V = v) = P(w = w \mid  V = v)
\end {align*}
          ]]></fr:tex>
Denoted <fr:tex display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>.
        </html:li>
          <html:li>Equivalently, we say <fr:tex display="inline"><![CDATA[(U \perp  W) | V]]></fr:tex> which means <fr:tex display="block"><![CDATA[
             P(W = w, U=u \mid  V = v) \implies  P(W = w \mid  V = v)P(U = u \mid  V = v)
          ]]></fr:tex></html:li>
          <html:li>Reversibility: <fr:tex display="inline"><![CDATA[U \to  V \to  W \iff  W \to  V \to  U]]></fr:tex>.</html:li>
          <html:li>Estimation: <fr:tex display="inline"><![CDATA[X \to  Y \to  \hat {X}]]></fr:tex></html:li></html:ul> 

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004Z/</fr:uri><fr:display-uri>004Z</fr:display-uri><fr:route>/004Z/</fr:route><fr:title text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  Suppose that <fr:tex display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[I(U; W) \leq  I(U; V)]]></fr:tex>.
  </html:p><html:p><html:strong>Intuition:</html:strong> by data processing, we can never create new information about <fr:tex display="inline"><![CDATA[U]]></fr:tex>.
</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Use chain rule to expand <fr:tex display="inline"><![CDATA[I(U; (V, W))]]></fr:tex> in two ways i.e. 
<fr:tex display="block"><![CDATA[
  \begin {align*}
    I(U; (V, W)) = I(U; V) + I(U; W | V) = I(U; W) + I(U; V | W)
  \end {align*}
]]></fr:tex>
Since <fr:tex display="inline"><![CDATA[U \to  V \to  W]]></fr:tex> is a Markov chain, <fr:tex display="inline"><![CDATA[I(U; W | V) = 0]]></fr:tex>. Therefore,
<fr:tex display="block"><![CDATA[
\begin {align*}
  I(U; V)  &= I(U; W) + I(U; V | W) \\
&\geq  I(U; W)
\end {align*}
]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Fano's Inequality"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Fano's Inequality</fr:title></fr:frontmatter><fr:mainmatter>
    <html:ul><html:li><fr:tex display="inline"><![CDATA[H(X | Y)]]></fr:tex> controls the error probability <fr:tex display="inline"><![CDATA[P_e]]></fr:tex>.</html:li></html:ul>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0050/</fr:uri><fr:display-uri>0050</fr:display-uri><fr:route>/0050/</fr:route><fr:title text="Fano's Inequality">Fano's Inequality</fr:title></fr:frontmatter><fr:mainmatter><html:p>
  Suppose that <fr:tex display="inline"><![CDATA[X \iff  Y \iff  \hat {X}]]></fr:tex> and let <fr:tex display="inline"><![CDATA[p_e = \mathbb {P}(X \neq  \hat {X})]]></fr:tex>. Then, we have 
  <fr:tex display="block"><![CDATA[
      \begin {align*}
        H(p_e) + p_e \log (|\mathcal {X}| - 1) \geq  H(X \mid  \hat {X}) \geq  H(X \mid  Y)
      \end {align*}
    ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Asymptotic Equipartion Propery">Asymptotic Equipartion Propery</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0051/</fr:uri><fr:display-uri>0051</fr:display-uri><fr:route>/0051/</fr:route><fr:title text="Weak Law of Large Numbers">Weak Law of Large Numbers</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Then,

<fr:tex display="block"><![CDATA[\frac {1}{n}\sum _{i=1}^{n}X_{i}\stackrel {{p}}{{\rightarrow }}\mu ]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    By <fr:link href="/002F/" title="Chebyshev's Inequality" uri="https://kellenkanarios.com/002F/" display-uri="002F" type="local">Chebyshev's Inequality</fr:link>,
    <fr:tex display="block"><![CDATA[
    \begin {align*}
      \mathbb {P}(|\hat {X} - \mu | > a) \leq  -\frac {\sigma ^2}{a^2}
    \end {align*}
    ]]></fr:tex>
    Since <fr:tex display="inline"><![CDATA[X_i]]></fr:tex>'s are independent, 
<fr:tex display="block"><![CDATA[\mathrm {Var}[\hat {X}] = \frac {1}{n^2} \sum _{i = 1}^{n} \mathrm {Var}[X_i]]]></fr:tex>
    Therefore,
<fr:tex display="block"><![CDATA[
    \begin {align*}
      \lim _{n \to  \infty } \mathbb {P}(|\hat {X} - \mu | > a) \leq  \lim _{n \to  \infty }-\frac {\sigma ^2}{n a^2} \to  0
    \end {align*}
]]></fr:tex>
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0052/</fr:uri><fr:display-uri>0052</fr:display-uri><fr:route>/0052/</fr:route><fr:taxon>Corollary</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> be any function, such that <fr:tex display="inline"><![CDATA[\mathrm {Var}(f(X))=\sigma _{f}^{2}<\infty ]]></fr:tex>. Then,
<fr:tex display="block"><![CDATA[\frac {1}{n} \sum _{i = 1}^{n} f(X_i) \stackrel {p}{\rightarrow } \mathbb {E}[f(X)]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0053/</fr:uri><fr:display-uri>0053</fr:display-uri><fr:route>/0053/</fr:route><fr:title text="Continuous Mapping Theorem">Continuous Mapping Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[X_{n}\stackrel {{p}}{{\rightarrow }}X]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> denote a continuous function. Then,
<fr:tex display="block"><![CDATA[f(X_n) \stackrel {p}{\rightarrow } f(X)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0054/</fr:uri><fr:display-uri>0054</fr:display-uri><fr:route>/0054/</fr:route><fr:title text="AEP Theorem">AEP Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex> denote i.i.d. <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with distribution <fr:tex display="inline"><![CDATA[P_{X}]]></fr:tex>. Then,

<fr:tex display="block"><![CDATA[
\begin {align*}
 \lim _{n\to \infty }-\frac {1}{n}\log  p_{X^{n}}(X_{1},\ldots ,X_{n}) &= \lim _{n \to  \infty } -\frac {1}{n} \log  \prod _{i = 1}^{n} P_X(X_i) \\
 &= \mathbb {E}_{X \sim  p_X}[-\log  p_X(X)] \\ 
 &= H(X)
\end {align*}
]]></fr:tex>
Equivalently, for large <fr:tex display="inline"><![CDATA[n]]></fr:tex>
<fr:tex display="block"><![CDATA[
  \begin {align*}
    \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon 
  \end {align*}
]]></fr:tex>
with high probability.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0055/</fr:uri><fr:display-uri>0055</fr:display-uri><fr:route>/0055/</fr:route><fr:title text="\epsilon -typical set"><fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set</fr:title></fr:frontmatter><fr:mainmatter><html:p>
Fix an <fr:tex display="inline"><![CDATA[\epsilon >0]]></fr:tex>. Then, an <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set with respect to the pmf <fr:tex display="inline"><![CDATA[p_{X}]]></fr:tex>, denoted by <fr:tex display="inline"><![CDATA[A_{\epsilon }^{(n)}]]></fr:tex>, is defined as
<fr:tex display="block"><![CDATA[\left \{X^n \in  \mathcal {X}^n \mid  \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon  \right \}]]></fr:tex>
Alternatively,
<fr:tex display="block"><![CDATA[A_{\epsilon ^{(n)}} = \left \{X^n \in  \mathcal {X}^n \mid  2^{-n(H(X) + \epsilon )} \leq  p_{X^n}(X^n) \leq  2^{-n(H(X) - \epsilon )}\right \}]]></fr:tex></html:p>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  We have the following important properties
  <html:ol><html:li><fr:tex display="inline"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)})\geq 1-\epsilon {\text { for large enough }}n]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[|A_{c}^{(n)}|\leq 2^{n(H(X)+\epsilon )}]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[|A_{\epsilon }^{(n)}|\geq (1-\epsilon )2^{n(H(X)-\epsilon )}\;\text {for large enough }\;n\;,]]></fr:tex></html:li></html:ol>
    Together, this says that, depending on the entropy, the typical set can contain most of the probability despite being much smaller than the entire space.
  </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<html:p><html:strong>interpretation:</html:strong> <fr:tex display="inline"><![CDATA[A_{\epsilon }^{(n)}\,\text { is a subset of }\,{\mathcal {X}}^{n}]]></fr:tex>
<html:ul><html:li>Contains almost all the probability.</html:li>
    <html:li>Consists of <fr:tex display="inline"><![CDATA[\approx  2^{nH(X)}]]></fr:tex></html:li>
    <html:li>Almost equiprobable sequences.</html:li></html:ul></html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0056/</fr:uri><fr:display-uri>0056</fr:display-uri><fr:route>/0056/</fr:route><fr:title text="High probability sets">High probability sets</fr:title><fr:taxon>Corollary</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[B_{\epsilon }^{(n)}\subset \mathcal {X}^{n}]]></fr:tex> be the smallest set with probability at least <fr:tex display="inline"><![CDATA[1-\epsilon ]]></fr:tex>. Then, we must have

<fr:tex display="block"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)}\cap  B_{\epsilon }^{(n)})\geq 1-2\epsilon ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Fixed-rate lossless source coding">Fixed-rate lossless source coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0059/</fr:uri><fr:display-uri>0059</fr:display-uri><fr:route>/0059/</fr:route><fr:title text="Coding system">Coding system</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A coding system with parameters <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> consist of an encoder and a decoder, where an encoder is a function
<fr:tex display="block"><![CDATA[
  e: \mathcal {X}^n \to  \{1, 2, \ldots , \theta \}
]]></fr:tex>
and a decoder is a function 
<fr:tex display="block"><![CDATA[f: \{1, 2, \ldots , \theta \} \to  \mathcal {X}^n]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<html:p><html:strong>Performance:</html:strong>
    <html:ul><html:li>Rate = <fr:tex display="inline"><![CDATA[\frac {\log _2 \theta }{n}]]></fr:tex></html:li>
        <html:li>Probability of decoding error = <fr:tex display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n|]]></fr:tex></html:li></html:ul></html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005A/</fr:uri><fr:display-uri>005A</fr:display-uri><fr:route>/005A/</fr:route><fr:title text="Achievability">Achievability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A positive real number <fr:tex display="inline"><![CDATA[R]]></fr:tex> is said to be <html:em>achievable</html:em> if for all <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex> (perturbation parameter) there exists a block length <fr:tex display="inline"><![CDATA[N(\epsilon )]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\forall  n > N(\epsilon )]]></fr:tex> the following holds
<html:ul><html:li>There exists an <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> <fr:link href="/0059/" title="Coding system" uri="https://kellenkanarios.com/0059/" display-uri="0059" type="local">coding system</fr:link> such that <fr:tex display="inline"><![CDATA[\frac {\log  \theta }{n} < R + \epsilon ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n| < \epsilon ]]></fr:tex>.</html:li></html:ul></html:p><html:p>Alternatively, a positive real number <fr:tex display="inline"><![CDATA[R]]></fr:tex> is said to be <html:em>achievable</html:em> if there exists a sequence of <fr:link href="/0059/" title="Coding system" uri="https://kellenkanarios.com/0059/" display-uri="0059" type="local">coding systems</fr:link> <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log  \theta }{n} \to  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lim _{n \to  \infty } \mathbb {P}|\hat {X}^n \neq  X^n| \to  0]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005B/</fr:uri><fr:display-uri>005B</fr:display-uri><fr:route>/005B/</fr:route><fr:title text="Minimum rate of source coding">Minimum rate of source coding</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The <html:em>minimum rate of source coding</html:em> <fr:tex display="inline"><![CDATA[R_s]]></fr:tex> is the infimum over all <fr:tex display="inline"><![CDATA[R]]></fr:tex> such that <fr:tex display="inline"><![CDATA[R]]></fr:tex> is <fr:link href="/005A/" title="Achievability" uri="https://kellenkanarios.com/005A/" display-uri="005A" type="local">achievable</fr:link> i.e.  
<fr:tex display="block"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005C/</fr:uri><fr:display-uri>005C</fr:display-uri><fr:route>/005C/</fr:route><fr:title text="Entropy as MRSC">Entropy as <fr:link href="/005B/" title="Minimum rate of source coding" uri="https://kellenkanarios.com/005B/" display-uri="005B" type="local">MRSC</fr:link></fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[R_s = H(P_X) = H(X) = -\sum _{x \in  \mathcal {X}} P_X(x) \log  P_X(x)]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    First we will show that <fr:tex display="inline"><![CDATA[H(X)]]></fr:tex> is <fr:link href="/005A/" title="Achievability" uri="https://kellenkanarios.com/005A/" display-uri="005A" type="local">achievable</fr:link>. Then we will have <fr:tex display="inline"><![CDATA[R_s \leq  H(X)]]></fr:tex> by definition. Idea: take <fr:tex display="inline"><![CDATA[\theta  = 2^{n(H(X) + \epsilon )} + 1]]></fr:tex>. Give each element in typical set a unique index, everything else the same index. By properties of typical set, <fr:tex display="inline"><![CDATA[\mathbb {P}(\text {error}) < \epsilon ]]></fr:tex> for sufficiently large <fr:tex display="inline"><![CDATA[n]]></fr:tex>.
  </html:p>
  <html:p>
      For the other direction, suppose we have some <fr:tex display="inline"><![CDATA[R]]></fr:tex> <fr:link href="/005A/" title="Achievability" uri="https://kellenkanarios.com/005A/" display-uri="005A" type="local">achievable</fr:link>. By definition, for all <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, for all sufficiently large <fr:tex display="inline"><![CDATA[n]]></fr:tex> there exists a <fr:link href="/0059/" title="Coding system" uri="https://kellenkanarios.com/0059/" display-uri="0059" type="local">Coding system</fr:link> with parameters <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that
<fr:tex display="block"><![CDATA[
        \begin {align*}
          \frac {\log  \theta }{n} < R + \epsilon , \quad  \mathbb {P}(\text {error}) < \epsilon 
        \end {align*}
      ]]></fr:tex>
      Use <fr:link href="/0050/" title="Fano's Inequality" uri="https://kellenkanarios.com/0050/" display-uri="0050" type="local">Fano's Inequality</fr:link> to show this is not possible.
    </html:p>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
  </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Variable Rate Source Coding">Variable Rate Source Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005K/</fr:uri><fr:display-uri>005K</fr:display-uri><fr:route>/005K/</fr:route><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A coding system (variable rate) with parameter <fr:tex display="inline"><![CDATA[n]]></fr:tex> and an encoder-decoder pair <fr:tex display="inline"><![CDATA[(e,f)]]></fr:tex>, where 
<fr:tex display="block"><![CDATA[e: \mathcal {X}^n \to  \{0, 1\}^*, \quad  \text {and} \quad  f: \{0, 1\}^* \to  \mathcal {X}^n]]></fr:tex>
We want the probability of error to be exactly zero; that is <fr:tex display="inline"><![CDATA[\mathbb {P}(X^n \neq  f(e(X^n))) = 0]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005L/</fr:uri><fr:display-uri>005L</fr:display-uri><fr:route>/005L/</fr:route><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\ell (x^n)]]></fr:tex> denote the number of bits in <fr:tex display="inline"><![CDATA[e(x^n)]]></fr:tex>, where <fr:tex display="inline"><![CDATA[e]]></fr:tex> is the encoding function. Then, the rate is <fr:tex display="block"><![CDATA[\frac {\mathbb {E}[\ell (X^n)]}{n}]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Although it is unclear here, the difference between variable and fixed rate source coding is that we allow our encoder and decoder to map to/from <fr:tex display="inline"><![CDATA[\{0,1\}^* ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[^*]]></fr:tex> is variable i.e. our encoded versions of our alphabet can have varying lengths.</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005U/</fr:uri><fr:display-uri>005U</fr:display-uri><fr:route>/005U/</fr:route><fr:title text="Singularity of a code">Singularity of a code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[e]]></fr:tex> is many-to-one then we say that <fr:tex display="inline"><![CDATA[e]]></fr:tex> is singular. Similarly, if <fr:tex display="inline"><![CDATA[e]]></fr:tex> is one-to-one then <fr:tex display="inline"><![CDATA[e]]></fr:tex> is non-singular.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005M/</fr:uri><fr:display-uri>005M</fr:display-uri><fr:route>/005M/</fr:route><fr:title text="Extensions and Unique Decodability">Extensions and Unique Decodability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Given a code with <fr:tex display="inline"><![CDATA[n = 1]]></fr:tex>, we define its extension <fr:tex display="inline"><![CDATA[e^*]]></fr:tex>; that maps <fr:tex display="inline"><![CDATA[\mathcal {X}^* \to  \{0,1\}^* ]]></fr:tex> by concatenation. That is 
<fr:tex display="block"><![CDATA[e^*(x_{1}, x_{2}, \ldots , x_m) = (e(x_{1}), e(x_{2}), \ldots , e(x_m))]]></fr:tex>
A code with encoder <fr:tex display="inline"><![CDATA[e]]></fr:tex> is said to be uniquely decodable if <fr:tex display="inline"><![CDATA[e^*]]></fr:tex> is <fr:link href="/005U/" title="Singularity of a code" uri="https://kellenkanarios.com/005U/" display-uri="005U" type="local">non-singular</fr:link>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005N/</fr:uri><fr:display-uri>005N</fr:display-uri><fr:route>/005N/</fr:route><fr:title text="instantaneous / prefix-free code">instantaneous / prefix-free code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A code is said to be prefix-free or instantaneous if no codeword is a prefix of another.</html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter><fr:link href="/005N/" title="instantaneous / prefix-free code" uri="https://kellenkanarios.com/005N/" display-uri="005N" type="local">Prefix free</fr:link> codes are <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link>. To show unique-decodability, you simply have to provide a way to decode and show it is unique. For <fr:link href="/005N/" title="instantaneous / prefix-free code" uri="https://kellenkanarios.com/005N/" display-uri="005N" type="local">prefix-free</fr:link>, greedily decoding suffices.</fr:mainmatter></fr:tree>

<html:figure><html:img width="300px" src="/bafkrmib5zz6npwtuhx2bv7mogpae3nas72xwhqerh3i5ixdk3h2kjqchse.png" />
<html:figcaption>Taxonomy of codes from <fr:link href="/coverELEMENTSINFORMATIONTHEORY/" title="ELEMENTS OF INFORMATION THEORY" uri="https://kellenkanarios.com/coverELEMENTSINFORMATIONTHEORY/" display-uri="coverELEMENTSINFORMATIONTHEORY" type="local">Reference <fr:contextual-number uri="https://kellenkanarios.com/coverELEMENTSINFORMATIONTHEORY/" display-uri="coverELEMENTSINFORMATIONTHEORY" /></fr:link>.</html:figcaption></html:figure>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Note that <fr:link href="/005U/" title="Singularity of a code" uri="https://kellenkanarios.com/005U/" display-uri="005U" type="local">non-singular</fr:link> does not imply <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link>. This is because for <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link> we require the extension to be <fr:link href="/005U/" title="Singularity of a code" uri="https://kellenkanarios.com/005U/" display-uri="005U" type="local">non-singular</fr:link>. For example, if we have that <fr:tex display="inline"><![CDATA[e(0) = 0, e(1) = 1, e(2) = 01]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[e^*(01) = e^*(2)]]></fr:tex>. From this, we can see that <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link> is a much stronger condition.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Kraft's inequality">Kraft's inequality</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005O/</fr:uri><fr:display-uri>005O</fr:display-uri><fr:route>/005O/</fr:route><fr:title text="Kraft's inequality">Kraft's inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[e: \mathcal {X} \to  \{0,1\}^* ]]></fr:tex> denote a <fr:link href="/005N/" title="instantaneous / prefix-free code" uri="https://kellenkanarios.com/005N/" display-uri="005N" type="local">prefix-free</fr:link> code with lengths <fr:tex display="inline"><![CDATA[\ell _i = \ell (x_i)]]></fr:tex> for <fr:tex display="inline"><![CDATA[x_i \in  \mathcal {X}]]></fr:tex>. Suppose <fr:tex display="inline"><![CDATA[|\mathcal {X}| = m]]></fr:tex>. Then the following must be true:
<fr:tex display="block"><![CDATA[\sum _{i=1}^{m} 2^{-\ell _i} \leq  1]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Other direction is also true. For any <fr:tex display="inline"><![CDATA[\ell _i]]></fr:tex> satisfying Kraft's inequality, one can construct a prefix-free code whose lengths of <fr:tex display="inline"><![CDATA[e(x_i) = \ell _i]]></fr:tex>.</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Surprisingly, any <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link> code must also satisfy <fr:link href="/005O/" title="Kraft's inequality" uri="https://kellenkanarios.com/005O/" display-uri="005O" type="local">Kraft's inequality</fr:link>.</fr:mainmatter></fr:tree>

    </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Performance Limit of Variable Rate Source Codes">Performance Limit of Variable Rate Source Codes</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005P/</fr:uri><fr:display-uri>005P</fr:display-uri><fr:route>/005P/</fr:route><fr:title text="Variable rate code">Variable rate code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A variable rate code with parameter <fr:tex display="inline"><![CDATA[n]]></fr:tex> is a prefix-free code <fr:tex display="inline"><![CDATA[e : \mathcal {X}^n \to  \{0, 1\}^* ]]></fr:tex>, and a decoder <fr:tex display="inline"><![CDATA[f : \{0,1\}^* \to  \mathcal {X}^n ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005Q/</fr:uri><fr:display-uri>005Q</fr:display-uri><fr:route>/005Q/</fr:route><fr:title text="Variable rate achievability">Variable rate achievability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A nonnegative number <fr:tex display="inline"><![CDATA[R]]></fr:tex> is said to be achievable if for all <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, there exists an <fr:tex display="inline"><![CDATA[n(\epsilon )]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[n \geq  n(\epsilon )]]></fr:tex>, the following holds
<html:ul><html:li>There exists a variable rate code with <fr:tex display="inline"><![CDATA[\mathbb {E}[\ell (X^n)]/n = R]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {P}(X^n \neq  f(e(X^n))) = 0]]></fr:tex> for all <fr:tex display="inline"><![CDATA[n]]></fr:tex>.</html:li></html:ul></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005R/</fr:uri><fr:display-uri>005R</fr:display-uri><fr:route>/005R/</fr:route><fr:title text="Variable minimum rate">Variable minimum rate</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The minimum rate of variable rate source coding is <fr:tex display="inline"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}  ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005S/</fr:uri><fr:display-uri>005S</fr:display-uri><fr:route>/005S/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[R_s = H(X)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005T/</fr:uri><fr:display-uri>005T</fr:display-uri><fr:route>/005T/</fr:route><fr:title text="Shannon Fano Elias Code">Shannon Fano Elias Code</fr:title></fr:frontmatter><fr:mainmatter><html:p><html:strong>Idea</html:strong>: map symbol <fr:tex display="inline"><![CDATA[x]]></fr:tex> to interval in <fr:tex display="inline"><![CDATA[(0,1)]]></fr:tex> using the CDF of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p><html:ul><html:li>Assume <fr:tex display="inline"><![CDATA[x_{1} < x_{2} < \cdots  < x_m]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[X \sim  P_X]]></fr:tex> is <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with <fr:tex display="inline"><![CDATA[\mathbf {p}_X]]></fr:tex></html:li>
  <html:li>CDF of <fr:tex display="inline"><![CDATA[X = F_X(x) \coloneqq   \sum _{x_i \leq  x} P(x_i)]]></fr:tex></html:li>
  <html:li>Midpoint function: <fr:tex display="inline"><![CDATA[G(x) = \sum _{x_i < x} P_X(x) + \frac {P_X(x)}{2} = F_X(x) - \frac {P_X(x)}{2}]]></fr:tex></html:li>
  <html:li>Codeword: <fr:tex display="inline"><![CDATA[e(x) = \left \lfloor  G(x) \right \rfloor _{\ell (x)}=]]></fr:tex> first <fr:tex display="inline"><![CDATA[\ell (x)]]></fr:tex> bits of <fr:tex display="inline"><![CDATA[G(x)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\ell (x) = \left \lceil  \log (\frac {1}{P_X(x)}) \right \rceil  + 1]]></fr:tex></html:li></html:ul></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005Z/</fr:uri><fr:display-uri>005Z</fr:display-uri><fr:route>/005Z/</fr:route><fr:title text="Huffman Code">Huffman Code</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005W/</fr:uri><fr:display-uri>005W</fr:display-uri><fr:route>/005W/</fr:route><fr:title text="Huffman Code">Huffman Code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Given <fr:tex display="inline"><![CDATA[x_1, \ldots  x_m]]></fr:tex> proceed as follows:
<html:ol><html:li>Take two <fr:tex display="inline"><![CDATA[x_i, x_j]]></fr:tex> with smallest <fr:tex display="inline"><![CDATA[p(x_i), p(x_j)]]></fr:tex> append 0 and 1 to their respective codes.</html:li>
  <html:li>Combine them and treat them as a new value with <fr:tex display="inline"><![CDATA[p(x_i') = p(x_i) + p(x_j)]]></fr:tex></html:li>
  <html:li>Repeat</html:li></html:ol></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0060/</fr:uri><fr:display-uri>0060</fr:display-uri><fr:route>/0060/</fr:route><fr:title text="Optimality of Huffman Code">Optimality of Huffman Code</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X \sim  P_X]]></fr:tex> be an <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued random variable. Define <fr:tex display="block"><![CDATA[L_H = \mathbb {E}_{X \sim  P_X}[\ell _H(x)]]]></fr:tex> and <fr:tex display="block"><![CDATA[L^*(P_X) = \min _{\ell _1, \ldots , \ell _m} \sum _{i = 1}^{m} P_X(x_i) \ell _i.]]></fr:tex> Then <fr:tex display="inline"><![CDATA[L_H = L^*(P_X)]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
SFE satisfies <fr:tex display="inline"><![CDATA[L_H < H(X) + \frac {2}{n}]]></fr:tex> i.e. it achieves the optimal rate as <fr:tex display="inline"><![CDATA[n \to  \infty ]]></fr:tex>. Huffman coding achieves optimality for all finite values <fr:tex display="inline"><![CDATA[n]]></fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Method of Types">Method of Types</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005X/</fr:uri><fr:display-uri>005X</fr:display-uri><fr:route>/005X/</fr:route><fr:title text="type or empirical distribution">type or empirical distribution</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The "type" <fr:tex display="inline"><![CDATA[ \widehat {P}_{x^{n}} ]]></fr:tex> associated with <fr:tex display="inline"><![CDATA[ x^{n}\in \mathcal {X}^{n} ]]></fr:tex> is the probability distribution on <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> with pmf <fr:tex display="inline"><![CDATA[ \widehat {\boldsymbol {p}}_{x^{n}} ]]></fr:tex>, defined as

<fr:tex display="block"><![CDATA[ \widehat {\boldsymbol {p}}_{x^{n}}(a)=\frac {N(a|x^{n})}{n},\quad \text {where}\quad  N(a|x^{n}):=\sum _{i=1}^{n}\mathbf {1}_{x_{i}=a}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005Y/</fr:uri><fr:display-uri>005Y</fr:display-uri><fr:route>/005Y/</fr:route><fr:title text="Set of all types">Set of all types</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For any <fr:tex display="inline"><![CDATA[ n\geq 1 ]]></fr:tex>, let <fr:tex display="inline"><![CDATA[ \mathcal {P}_{n} ]]></fr:tex> denote the set of all possible types over the alphabet <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> with denominator <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>. That is,

<fr:tex display="block"><![CDATA[ \mathcal {P}_{n}=\{\widehat {P}_{x^{n}}:x^{n}\in \mathcal {X}^{n}\}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0061/</fr:uri><fr:display-uri>0061</fr:display-uri><fr:route>/0061/</fr:route><fr:title text="Type classes">Type classes</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For any type <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex>, we can associate the type class <fr:tex display="inline"><![CDATA[ T(P) ]]></fr:tex>, defined as

<fr:tex display="block"><![CDATA[ T(P)=\{x^{n}:\tilde {P}_{x^{n}}=P\}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
    Let <fr:tex display="inline"><![CDATA[\mathcal {X} = \{1,2,3\}.]]></fr:tex> For <fr:tex display="inline"><![CDATA[n = 2]]></fr:tex>, <fr:tex display="inline"><![CDATA[x^n = 12]]></fr:tex> the <fr:link href="/005X/" title="type or empirical distribution" uri="https://kellenkanarios.com/005X/" display-uri="005X" type="local">type</fr:link> is <fr:tex display="inline"><![CDATA[(\frac {1}{2},\frac {1}{2}, 0)]]></fr:tex> and the <fr:link href="/0061/" title="Type classes" uri="https://kellenkanarios.com/0061/" display-uri="0061" type="local">type class</fr:link> is <fr:tex display="inline"><![CDATA[\{12, 21\}  ]]></fr:tex>.
</fr:mainmatter></fr:tree>
 


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Properties"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Properties</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0062/</fr:uri><fr:display-uri>0062</fr:display-uri><fr:route>/0062/</fr:route><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

Suppose <fr:tex display="inline"><![CDATA[ |\mathcal {X}|=m ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ \mathcal {P}_{n} ]]></fr:tex> denotes the set of all distinct types that can be constructed using elements of <fr:tex display="inline"><![CDATA[ \mathcal {X}^{n} ]]></fr:tex>. Then, we have_

<fr:tex display="block"><![CDATA[ |\mathcal {P}_{n}|=\binom {n+m-1}{m-1}\leq (n+1)^{m}. ]]></fr:tex></html:p>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
<fr:tex display="inline"><![CDATA[\mathcal {X}^n]]></fr:tex> has exponentially many elements in <fr:tex display="inline"><![CDATA[n]]></fr:tex>. However, among the exponentially many elements they can only create polynomially many types in <fr:tex display="inline"><![CDATA[n]]></fr:tex> for fixed <fr:tex display="inline"><![CDATA[m]]></fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0063/</fr:uri><fr:display-uri>0063</fr:display-uri><fr:route>/0063/</fr:route><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex> denote a type with denominator <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>. Then, the type class associated with <fr:tex display="inline"><![CDATA[ P ]]></fr:tex>, defined as <fr:tex display="inline"><![CDATA[ T(P)=\{x^{n}:\hat {P}_{x^n}=P\} ]]></fr:tex> satisfies

<fr:tex display="block"><![CDATA[ |T(P)|=\prod _{i=1}^{n}\binom {n-N_{i-1}}{N_{i}},\quad \text {where}\quad  N_{0}=0,\text {and}\ N_{i}=n\times  P(a_{i}), ]]></fr:tex>

for all <fr:tex display="inline"><![CDATA[ a_{i}\in \mathcal {X}=\{a_{1},\ldots ,a_{m}\} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0065/</fr:uri><fr:display-uri>0065</fr:display-uri><fr:route>/0065/</fr:route><fr:taxon>Lemma</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>


Suppose <fr:tex display="inline"><![CDATA[ X_{1},X_{2},\ldots ,X_{n}\stackrel {{i.i.d.}}{{\sim }}Q ]]></fr:tex> for an arbitrary distribution <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex>. Then, we have

<fr:tex display="block"><![CDATA[ \mathbb {P}(X^{n}=x^{n}) \equiv  Q^{n}(x^{n}) = 2^{-n(H(\widehat {P}_{x^{n}})+D_{2n}(\widehat {P}_{x^{n}})=Q)}. ]]></fr:tex>

In other words, the probability that <fr:tex display="inline"><![CDATA[ X^{n} ]]></fr:tex> takes a value <fr:tex display="inline"><![CDATA[ x^{n} ]]></fr:tex> only depends on <fr:tex display="inline"><![CDATA[ x^{n} ]]></fr:tex> through its type <fr:tex display="inline"><![CDATA[ \widehat {P}_{x^{n}} ]]></fr:tex>. Furthermore, types that are far away from <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> in relative entropy are exponentially less probable than those that are close to <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex>.

An immediate consequence of this is that if <fr:tex display="inline"><![CDATA[ Q\in \mathcal {P}_{n} ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ x^{n}\in  T(Q) ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[ Q^{n}(x^{n})=2^{-nH(Q)} ]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0064/</fr:uri><fr:display-uri>0064</fr:display-uri><fr:route>/0064/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ T(P) ]]></fr:tex> denote its type class. Then, the following bounds hold:

<fr:tex display="block"><![CDATA[ (n+1)^{-m}2^{nH(P)}\leq |T(P)|\leq  2^{nH(P)}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0066/</fr:uri><fr:display-uri>0066</fr:display-uri><fr:route>/0066/</fr:route><fr:title text="The probability of a type class">The probability of a type class</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

Let <fr:tex display="inline"><![CDATA[ X^{n}=(X_{1},\ldots ,X_{n})\stackrel {{i.i.d.}}{{\sim }}Q ]]></fr:tex> for an arbitrary distribution <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> on <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex>. Then, we have the following:

<fr:tex display="block"><![CDATA[ (n+1)^{-m}2^{-nD_{KL}(P|Q)}\leq  Q^{n}(T(P))\leq 2^{-nD_{KL}(P|Q)}. ]]></fr:tex>

In other words, the probability that <fr:tex display="inline"><![CDATA[ X^{n}\stackrel {{i.i.d.}}{{\sim }}Q ]]></fr:tex> lies in the type class of <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex> is <fr:tex display="inline"><![CDATA[ \approx 2^{-nD_{KL}(P||Q)} ]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Large Deviation Theory">Large Deviation Theory</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0067/</fr:uri><fr:display-uri>0067</fr:display-uri><fr:route>/0067/</fr:route><fr:title text="Sanov's Theorem">Sanov's Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ X^{n}\sim  Q^{n} ]]></fr:tex> (i.e., the <fr:tex display="inline"><![CDATA[ X ]]></fr:tex>'s are drawn i.i.d. from <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex>), and <fr:tex display="inline"><![CDATA[ E\subset \Delta _{m} ]]></fr:tex> denote a subset of pmfs over the finite alphabet <fr:tex display="inline"><![CDATA[ X=\{a_{1},\ldots ,a_{m}\} ]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[ Q^{n}(E) ]]></fr:tex> denote the probability <fr:tex display="inline"><![CDATA[ \mathbb {P}_{X^{n}\sim  Q^{n}}(\widehat {P}_{X^{n}}\in  E) ]]></fr:tex>. Then, we have

<fr:tex display="block"><![CDATA[ Q^{n}(E)\leq 2^{-nD_{\mathbb {E}}(P^{n} \parallel  Q)}, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ P^{*}=\inf _{P^{n}\in  E}D_{\mathbb {E}}(P^{*}\mid  Q) ]]></fr:tex> is the closest element of <fr:tex display="inline"><![CDATA[ E ]]></fr:tex> to <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> in terms of relative entropy. Furthermore, if <fr:tex display="inline"><![CDATA[ E ]]></fr:tex> is the closure of its interior, we also have

<fr:tex display="block"><![CDATA[ \operatorname *{lim}_{n\to \infty }-{\frac {1}{n}}\log  Q^{n}(E)=D_{K L}(P^{*}\parallel  Q). ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Hypothesis testing">Hypothesis testing</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0069/</fr:uri><fr:display-uri>0069</fr:display-uri><fr:route>/0069/</fr:route><fr:title text="Hypothesis testing problem">Hypothesis testing problem</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A binary hypothesis testing problem involves three components: the data <fr:tex display="inline"><![CDATA[ X\sim  P ]]></fr:tex>, the null hypothesis class <fr:tex display="inline"><![CDATA[ \mathcal {P}_{0} ]]></fr:tex>, and the alternative distribution class <fr:tex display="inline"><![CDATA[ \mathcal {P}_{1} ]]></fr:tex>, and the goal is to use the data to decide between the null and alternative; that is,

<fr:tex display="block"><![CDATA[ \text {given}\ X\sim  P,\quad  \text {decide between}\quad  H_{0}:P\in \mathcal {P}_{0},\quad \text {versus}\quad  H_{1}:P\in \mathcal {P}_{1}. ]]></fr:tex>


When <fr:tex display="inline"><![CDATA[ {\cal  P}_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ {\cal  P}_{1} ]]></fr:tex> are singleton sets: that is <fr:tex display="inline"><![CDATA[ {\cal  P}_{0}=\{P_{0}\} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ {\cal  P}_{1}=\{P_{1}\} ]]></fr:tex> with known <fr:tex display="inline"><![CDATA[ P_{0},P_{1} ]]></fr:tex>, then the problem is called simple hypothesis testing, and this is what we will focus on mostly in this course:

<fr:tex display="block"><![CDATA[ \text {given}\ X\sim  P,\quad  \text {decide between} \quad  H_{0}:P=P_{0},\quad  \text {versus}\quad  H_{1}:P=P_{1}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006A/</fr:uri><fr:display-uri>006A</fr:display-uri><fr:route>/006A/</fr:route><fr:title text="Hypothesis test">Hypothesis test</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

A randomized hypothesis test is a channel which takes in the data <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> and outputs a <fr:tex display="inline"><![CDATA[ \{0,1\} ]]></fr:tex> valued random variable <fr:tex display="inline"><![CDATA[ Z ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[ Z=i ]]></fr:tex> represents that the test declares that <fr:tex display="inline"><![CDATA[ H_{i} ]]></fr:tex> is true, for <fr:tex display="inline"><![CDATA[ i\in \{0,1\} ]]></fr:tex>.

<fr:tex display="block"><![CDATA[ X\sim  P\longrightarrow \boxed {P_{Z|X}}\longrightarrow  Z ]]></fr:tex>
In some cases, it is sufficient to focus on non-randomized or deterministic tests, for which <fr:tex display="inline"><![CDATA[ P_{\mathbb {Z}|X=x} ]]></fr:tex> is a delta function. That is, for a given realization of <fr:tex display="inline"><![CDATA[ X ]]></fr:tex>, the output of the test is deterministic (it is equal to <fr:tex display="inline"><![CDATA[ H_{0} ]]></fr:tex> or <fr:tex display="inline"><![CDATA[ H_{1} ]]></fr:tex> with probability 1). Such deterministic tests can be equivalently represented by a function <fr:tex display="inline"><![CDATA[ \Psi  ]]></fr:tex>, or a subset <fr:tex display="inline"><![CDATA[ B ]]></fr:tex> of the domain <fr:tex display="inline"><![CDATA[ X ]]></fr:tex>:

<fr:tex display="block"><![CDATA[ \Psi (X)=\mathbf {1}_{B}(X)=\begin {cases}1,&\text {if}X\in  B\\ 0,&\text {if}X\not \in  B.\end {cases} ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006B/</fr:uri><fr:display-uri>006B</fr:display-uri><fr:route>/006B/</fr:route><fr:title text="Hypothesis error">Hypothesis error</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
In any binary hypothesis testing problem, a test <fr:tex display="inline"><![CDATA[ P_{Z|X|} ]]></fr:tex> can incur two types of errors:
<fr:tex display="block"><![CDATA[\begin {align*}
   \pi _{1|0}(P_{Z|X})&=\mathbb {P}_{H_{0}}\ (Z=1) \quad  \text {(type-I error of false alarm rate)} \\
 \pi _{01}(P_{Z|X})&=\mathbb {P}_{H_{1}}\ (Z=0) \quad   \text {(type-II error or missed detection rate)}
.\end {align*}]]></fr:tex></html:p></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Notions of optimality"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Notions of optimality</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006C/</fr:uri><fr:display-uri>006C</fr:display-uri><fr:route>/006C/</fr:route><fr:title text="Neyman-Pearson Framework">Neyman-Pearson Framework</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Given <fr:tex display="inline"><![CDATA[\alpha  \in  (0,1)]]></fr:tex>. The optimal hypothesis test in the <html:em>Neyman-Pearson</html:em> framework is one that satisfies
<fr:tex display="block"><![CDATA[\operatorname *{min}_{P_{Z\mid  X}}\;\mathbb {P}_{H_{1}}\left (Z=0\right ),\quad \mathrm {subject\,to}\quad \mathbb {P}_{H_{0}}\left (Z=1\right )\leq \alpha .]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006D/</fr:uri><fr:display-uri>006D</fr:display-uri><fr:route>/006D/</fr:route><fr:title text="Bayesian Framework">Bayesian Framework</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Assume we have prior distributions <fr:tex display="inline"><![CDATA[(\pi _{0}, \pi _{1})]]></fr:tex> over the two hypotheses and there exists costs <fr:tex display="inline"><![CDATA[C_{1|0}]]></fr:tex>, <fr:tex display="inline"><![CDATA[C_{0|1}]]></fr:tex> associated with <fr:link href="/006B/" title="Hypothesis error" uri="https://kellenkanarios.com/006B/" display-uri="006B" type="local">type I and type II error</fr:link> respectively. Then the Bayes optimal solution is the solution of 
<fr:tex display="block"><![CDATA[ \operatorname *{min}_{P_{Z|X}}\pi _{0}C_{1|0}\mathbb {P}_{H_{0}}(Z=1)+\pi _{1}C_{0|1}\mathbb {P}_{H_{1}}(Z=0). ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006E/</fr:uri><fr:display-uri>006E</fr:display-uri><fr:route>/006E/</fr:route><fr:title text="Minimax Optimal">Minimax Optimal</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Find a test that minimzes the maximum of the <fr:link href="/006B/" title="Hypothesis error" uri="https://kellenkanarios.com/006B/" display-uri="006B" type="local">two errors</fr:link> i.e. 
<fr:tex display="block"><![CDATA[ \operatorname *{min}_{P_{Z|X}}\operatorname *{max}\left \{\mathbb {P}_{H_{0}}(Z=1),\ \mathbb {P}_{H_{1}}(Z=0)\right \}=\operatorname *{min}_{P_{Z|X}}\operatorname *{max}\left \{\pi _{1|0}(P_{Z|X}),\ \pi _{0|1}(P_{Z|X})\right \}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Optimal NP Test"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Optimal NP Test</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0068/</fr:uri><fr:display-uri>0068</fr:display-uri><fr:route>/0068/</fr:route><fr:title text="Optimal NP Test">Optimal NP Test</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Consider a hypothesis testing problem with observations <fr:tex display="inline"><![CDATA[ X^{n}\stackrel {\text {i.i.d.}}{\sim }P_{X} ]]></fr:tex>, with the null <fr:tex display="inline"><![CDATA[ H_{0} : P_{X} =P_{0} ]]></fr:tex> and alternative <fr:tex display="inline"><![CDATA[ H_{1}:P_{X}=P_{1} ]]></fr:tex>. Then, the optimal NP test with level <fr:tex display="inline"><![CDATA[ \alpha \in  (0,1] ]]></fr:tex> has the following structure:

<fr:tex display="block"><![CDATA[ \Psi _{NP}^{*}(X^{n})=\begin {cases}1,&\text { if }L(X^{n})>\tau \\ \gamma ,&\text { if }L(X^{n})=\tau \\ 0,&\text { if }L(X^{n})<\tau .\end {cases} ]]></fr:tex>

In the above display, <fr:tex display="inline"><![CDATA[ L(X^{n}) ]]></fr:tex> denotes the likelihood ratio <fr:tex display="inline"><![CDATA[ p_{1}(X^{n})/p_{0}(X^{n}) ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ \gamma \in [0,1] ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ \tau \geq 0 ]]></fr:tex> are constants that ensure <fr:tex display="inline"><![CDATA[ \pi _{1|0}(\Psi ^*_{NP})=\mathbb {P}_{H_{0}}(\Psi ^*_{NP}(X^{n})=1)=\alpha  ]]></fr:tex>. Namely, 
<fr:tex display="block"><![CDATA[\tau  = \inf \{\tau  \mid  \alpha  \geq  \mathbb {P}(L(X^n) > \tau )\}]]></fr:tex> and <fr:tex display="block"><![CDATA[\gamma  = \frac {\alpha  - \mathbb {P}(L(X^n) > \tau )}{\mathbb {P}(L(X^n) = \tau )}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006F/</fr:uri><fr:display-uri>006F</fr:display-uri><fr:route>/006F/</fr:route><fr:title text="Optimal Bayesian Test">Optimal Bayesian Test</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ X^{n}\stackrel {{i.i.d.}}{{\sim }}P_{X} ]]></fr:tex>, and consider a binary hypothesis testing problem with <fr:tex display="inline"><![CDATA[ H_{0}:P_{X}=P_{0} ]]></fr:tex> versus <fr:tex display="inline"><![CDATA[ H_{1}:P_{X}=P_{1}. ]]></fr:tex> Let <fr:tex display="inline"><![CDATA[ (\pi _{0},\pi _{1}) ]]></fr:tex> denote the prior distribution of the two hypotheses being true. Then, the Bayes optimal hypothesis test with uniform loss is defined as

<fr:tex display="block"><![CDATA[ \Psi _{D}^{*}(X^{n})=\operatorname *{argmin}_{\Psi }\pi _{0}\pi _{10}(\Psi )+\pi _{1}\pi _{01}(\Psi )=\begin {cases}1&\text { if }L(X^{n})>\pi _{0}/\pi _{1}\\ 0&\text {otherwise.}\end {cases}, ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Error Exponents in Hypothesis Testing"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Error Exponents in Hypothesis Testing</fr:title></fr:frontmatter><fr:mainmatter>
In the previous section, we consider the optimal test in the non-asymptotic regime i.e. for finite <fr:tex display="inline"><![CDATA[n]]></fr:tex> what test minimizes the error according to some notion of error. In this section, we ask the question of what is the rate that this error converges to <fr:tex display="inline"><![CDATA[0]]></fr:tex>. More specifically, if <fr:tex display="inline"><![CDATA[\text {error}_n \leq  2^{-nV}]]></fr:tex> then what is the best (largest) <fr:tex display="inline"><![CDATA[V]]></fr:tex> we can hope to achieve?

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › NP Error Exponent"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › NP Error Exponent</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006G/</fr:uri><fr:display-uri>006G</fr:display-uri><fr:route>/006G/</fr:route><fr:title text="Optimal Error Exponent in NP setting">Optimal Error Exponent in NP setting</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say that an error exponent <fr:tex display="inline"><![CDATA[ V ]]></fr:tex> is achievable with type-1 error <fr:tex display="inline"><![CDATA[ \alpha >0 ]]></fr:tex>, if there exist a sequence of tests <fr:tex display="inline"><![CDATA[ (\Psi _{n}) ]]></fr:tex> with errors <fr:tex display="inline"><![CDATA[ (\alpha _{n},\beta _{n}) ]]></fr:tex>, satisfying

<fr:tex display="block"><![CDATA[ \alpha _{n}\leq \alpha ,\quad \text {and}\quad -\frac {1}{n}\log \beta _{n}\geq  V. ]]></fr:tex>

Let <fr:tex display="inline"><![CDATA[ V_{\alpha }:=\sup \{V:V\text { is achievable with type-1 error }\alpha \} ]]></fr:tex>. The optimal error exponent is defined as <fr:tex display="inline"><![CDATA[ V^{*}=\inf \{V_{\alpha }:\alpha >0\}=\lim _{\alpha \downarrow 0}V_{\alpha } ]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006H/</fr:uri><fr:display-uri>006H</fr:display-uri><fr:route>/006H/</fr:route><fr:title text="Stein's Lemma">Stein's Lemma</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

For any <fr:tex display="inline"><![CDATA[ \alpha >0 ]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[ V_{\alpha }=D_{KL}(P_{0}\parallel  P_{1}) ]]></fr:tex>, which also implies that <fr:tex display="inline"><![CDATA[ V^{*}=D_{KL}(P_{0}\parallel  P_{1}) ]]></fr:tex>. In other words, the relative entropy between <fr:tex display="inline"><![CDATA[ P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ P_{1} ]]></fr:tex> is the optimal type-II error exponent associated with a binary hypothesis testing problem with <fr:tex display="inline"><![CDATA[ H_{0}:P_{X}=P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ H_{1}:P_{X}=P_{1} ]]></fr:tex>.

  </html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Bayesian Error Exponent"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Bayesian Error Exponent</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006I/</fr:uri><fr:display-uri>006I</fr:display-uri><fr:route>/006I/</fr:route><fr:title text="Optimal Bayesian Error Exponent">Optimal Bayesian Error Exponent</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

Consider a binary Bayesian hypothesis testing problem with prior distribution <fr:tex display="inline"><![CDATA[ (\pi _{0},\pi _{1}) ]]></fr:tex>. Then, we say that an exponent <fr:tex display="inline"><![CDATA[ V>0 ]]></fr:tex> is achievable, if there exist a sequence of tests <fr:tex display="inline"><![CDATA[ \{\Psi _{n}:n\geq 1\} ]]></fr:tex>, with probability of errors <fr:tex display="inline"><![CDATA[ \{p_{n}(\Psi _{n})=\pi _{0}\psi _{0}(\Psi _{n})+\pi _{1}\psi _{01}(\Psi _{n}):n\geq 1\} ]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[ \liminf _{n\to \infty }\frac {1}{n}\log \left (\frac {1}{p_{n}}\right )=\liminf _{n\to \infty }\frac {1}{n}\log \left (\frac {1}{\pi _{0}\psi _{10}(\Psi _{n})+\pi _{1}\psi _{01}(\Psi _{n})}\right )\geq  V. ]]></fr:tex>

The optimal Bayesian error exponent for binary hypothesis testing with distributions <fr:tex display="inline"><![CDATA[ P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ P_{1} ]]></fr:tex> is defined as <fr:tex display="inline"><![CDATA[ V^{*}\equiv  V^{*}(P_{0},P_{1})=\sup \{V>0:V\text {is achievable}\} ]]></fr:tex>.

  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006J/</fr:uri><fr:display-uri>006J</fr:display-uri><fr:route>/006J/</fr:route><fr:title text="Optimal Bayesian Error Exponent">Optimal Bayesian Error Exponent</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For any <fr:tex display="inline"><![CDATA[ \lambda \in [0,1] ]]></fr:tex> let <fr:tex display="inline"><![CDATA[ P_{\lambda } ]]></fr:tex> denote the distribution over <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> such that <fr:tex display="inline"><![CDATA[ P_{\lambda }(x)\propto  P_{0}^{\lambda }(x)\times  P_{1}^{\lambda -1}(x) ]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[ \lambda ^{*}\in [0,1] ]]></fr:tex> denote the value at which <fr:tex display="inline"><![CDATA[ D_{KL}(P_{\lambda ^{*}}\parallel  P_{0})=D_{KL}(P_{\lambda ^{*}}\parallel  P_{1}) ]]></fr:tex>. Then, the optimal error exponent in the Bayesian hypothesis testing problem with distributions <fr:tex display="inline"><![CDATA[ P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ P_{1} ]]></fr:tex> satisfies:

<fr:tex display="block"><![CDATA[ V^{*}(P_{0},P_{1})=D_{KL}(P_{\lambda ^{*}}\parallel  P_{0})=D_{KL}(P_{\lambda ^{*}}\parallel  P_{1}). ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Fixed-Rate Universal Source Coding">Fixed-Rate Universal Source Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006K/</fr:uri><fr:display-uri>006K</fr:display-uri><fr:route>/006K/</fr:route><fr:title text="Fixed rate universal code">Fixed rate universal code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  
A sequence of fixed-rate source codes <fr:tex display="inline"><![CDATA[ \{(e_{n},f_{n}):n \geq  1\} ]]></fr:tex> with parameters <fr:tex display="inline"><![CDATA[ \{(n,2^{nR_{n}}):n \geq  1\} ]]></fr:tex> is said to be universal with rate <fr:tex display="inline"><![CDATA[ R ]]></fr:tex> if the following are true:
<html:ol><html:li>
The limiting rate satisfies <fr:tex display="inline"><![CDATA[ \lim _{n\to \infty }R_{n}\leq  R ]]></fr:tex>.
    </html:li>
  <html:li>
For any distribution <fr:tex display="inline"><![CDATA[ P ]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> with <fr:tex display="inline"><![CDATA[ H(P)<R ]]></fr:tex>, the probability of error, <fr:tex display="inline"><![CDATA[ \mathbb {P}_{X^{n}\sim  P^{n}} \left (f_{n}(e_{n}(X^{n})) \neq  X^{n}\right )=0]]></fr:tex>.</html:li></html:ol></html:p></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Construction of universal fixed rated code"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Construction of universal fixed rated code</fr:title></fr:frontmatter><fr:mainmatter>
    To construct, a universal fixed rate code, we need a code that satisfies (i) and (ii) from <fr:link href="/006K/" title="Fixed rate universal code" uri="https://kellenkanarios.com/006K/" display-uri="006K" type="local">Fixed rate universal code</fr:link>. 
    <html:ul><html:li>
Let <fr:tex display="inline"><![CDATA[ |\mathcal {X}|=m ]]></fr:tex>, and for any <fr:tex display="inline"><![CDATA[ n\geq 1 ]]></fr:tex> and a given <fr:tex display="inline"><![CDATA[ R>0 ]]></fr:tex>, define <fr:tex display="inline"><![CDATA[ R_n=R-m \frac {\log  n+1}{n}]]></fr:tex></html:li>
      <html:li>Consider the subset <fr:tex display="inline"><![CDATA[A_n \subset  \mathcal {X}^n]]></fr:tex>, defined as <fr:tex display="block"><![CDATA[A_n = \{x^n \in  \mathcal {X}^n \mid  H(\hat {P}_{x^n} \leq  R_n)\}  ]]></fr:tex></html:li>
      <html:li>Then just define the encoder in the usual way i.e. for encoder <fr:tex display="inline"><![CDATA[e_n]]></fr:tex> give every <fr:tex display="inline"><![CDATA[x^n \in  A_n]]></fr:tex> a unique code and everything else map to the same code.</html:li>
      <html:li>Then the decoder can easily identify everything in <fr:tex display="inline"><![CDATA[A_n]]></fr:tex> and it suffices to show that in the limit the probabilities concentrate around <fr:tex display="inline"><![CDATA[A_n]]></fr:tex>.</html:li></html:ul>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006L/</fr:uri><fr:display-uri>006L</fr:display-uri><fr:route>/006L/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The code constructed above is a universal fixed-rate code, such that <fr:tex display="inline"><![CDATA[ \lim _{n\to \infty }\mathbb {P}_{X^{n}\sim  P^{n}}(f_{n}(e_{n}(X^{n}))\neq  X^{n})=0 ]]></fr:tex> for all <fr:tex display="inline"><![CDATA[ P ]]></fr:tex> with <fr:tex display="inline"><![CDATA[ H(P)<R ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Variable-Rate Universal Source Coding">Variable-Rate Universal Source Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006M/</fr:uri><fr:display-uri>006M</fr:display-uri><fr:route>/006M/</fr:route><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose <fr:tex display="inline"><![CDATA[ X\sim  Q ]]></fr:tex>, but we encode it using an optimal code for <fr:tex display="inline"><![CDATA[ P ]]></fr:tex>. Then, the redundancy incurred is approximately equal to <fr:tex display="inline"><![CDATA[ D_{KL}(Q\parallel  P) ]]></fr:tex>.
  </html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  We know that the optimal codeword for <fr:tex display="inline"><![CDATA[ P ]]></fr:tex> has lengths approximately equal to <fr:tex display="inline"><![CDATA[ \ell _{P}(x)\approx \log (1/p(x)) ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[ p ]]></fr:tex> denotes the pmf of <fr:tex display="inline"><![CDATA[ P ]]></fr:tex>. Whereas the optimal codeword for <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> assigns lengths <fr:tex display="inline"><![CDATA[ \ell _{Q}(x)\approx \log (1/q(x)) ]]></fr:tex>. Then, the redundancy is

<fr:tex display="block"><![CDATA[
\begin {align*}
 \mathcal {R}(Q,P)&=\mathbb {E}_{X\sim  Q}[\ell _{P}(X)-\ell _{Q}(X)]\approx \mathbb {E}_{X\sim  Q}[-\log (p(X))+\log (q(X))] \\
&=\mathbb {E}_{X\sim  Q}\left [\log \left (\frac {q(X)}{p(X)}\right )\right ]=D_{\mathrm {KL}}(Q\parallel  P)
.\end {align*}
]]></fr:tex>

  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Redundancy-Capacity Theorem"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Redundancy-Capacity Theorem</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006N/</fr:uri><fr:display-uri>006N</fr:display-uri><fr:route>/006N/</fr:route><fr:title text="Minimax Redundancy">Minimax Redundancy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> denote an alphabet of size <fr:tex display="inline"><![CDATA[ m ]]></fr:tex>, and let <fr:tex display="inline"><![CDATA[ \mathcal {P}=\{P_{1},\ldots ,P_{k}\} ]]></fr:tex> denote a collection of <fr:tex display="inline"><![CDATA[ k ]]></fr:tex> distinct distributions on <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> (every <fr:tex display="inline"><![CDATA[ P_{i} ]]></fr:tex> can be identified with a pmf in <fr:tex display="inline"><![CDATA[ \Delta _{m} ]]></fr:tex>). Now, consider the following two-player game:
<html:ul><html:li>Player 1, representing adversary, chooses a distribution <fr:tex display="inline"><![CDATA[P]]></fr:tex> from the set <fr:tex display="inline"><![CDATA[\mathcal {P}]]></fr:tex></html:li>
  <html:li>Player 2, representing source coder, constructs a code according to the distribution <fr:tex display="inline"><![CDATA[Q \in  \Delta _m]]></fr:tex> without knowledge of <fr:tex display="inline"><![CDATA[P]]></fr:tex></html:li></html:ul>
The goal of Player 2is to identify a <fr:tex display="inline"><![CDATA[Q]]></fr:tex> that minimizes the worst-case <fr:link href="/006N/" title="Minimax Redundancy" uri="https://kellenkanarios.com/006N/" display-uri="006N" type="local">redundancy</fr:link>
<fr:tex display="block"><![CDATA[{\mathcal {R}}^{*}\equiv {\mathcal {R}}^{*}({\mathcal {P}}):=\operatorname *{min}_{Q\in \Delta _{m}}\operatorname *{max}_{P\in {\mathcal {P}}}{\mathcal {R}}(P,Q)=\operatorname *{min}_{Q\in \Delta _{m}}\operatorname *{max}_{P\in {\mathcal {P}}}D_{\mathrm {KL}}(P\parallel  Q).]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
It will turn out the optimal choice of <fr:tex display="inline"><![CDATA[Q]]></fr:tex> is the centroid associated with the <fr:tex display="inline"><![CDATA[k]]></fr:tex> elements of <fr:tex display="inline"><![CDATA[\mathcal {P}]]></fr:tex>.
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006O/</fr:uri><fr:display-uri>006O</fr:display-uri><fr:route>/006O/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\mathcal {R}^*(\mathcal {P}) = C(\mathcal {P}) \coloneqq  \sup _{\pi  \in  \Delta _k} I(W; X)]]></fr:tex>, where <fr:tex display="inline"><![CDATA[I(W; X)]]></fr:tex> is the mutual information between <fr:tex display="inline"><![CDATA[W \sim  \mathbf {\pi } ]]></fr:tex> and the output <fr:tex display="inline"><![CDATA[X]]></fr:tex>, with <fr:tex display="inline"><![CDATA[X | (W = i) \sim  P_i]]></fr:tex>. The optimal <fr:tex display="inline"><![CDATA[Q^*]]></fr:tex> is <fr:tex display="inline"><![CDATA[Q_{\pi }^* = \sum _{i = 1}^{k} \pi _i^* P_i]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006P/</fr:uri><fr:display-uri>006P</fr:display-uri><fr:route>/006P/</fr:route><fr:title text="Lempel-Ziv Algorithm">Lempel-Ziv Algorithm</fr:title></fr:frontmatter><fr:mainmatter><html:p>
    The algorithm proceed as follows:
    <html:ol><html:li>Initalize the dictionary to an empty set</html:li>
      <html:li>Make one pass through the stream of data</html:li>
      <html:li>Add every new "phrase" to the dictionary</html:li>
      <html:li>Encode only the elements of the dictionary</html:li></html:ol></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Channel Coding">Channel Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006S/</fr:uri><fr:display-uri>006S</fr:display-uri><fr:route>/006S/</fr:route><fr:title text="Channel coding problem">Channel coding problem</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A code with parameter <fr:tex display="inline"><![CDATA[(M, n)]]></fr:tex> i.e. (number of messages, number of channel users) consists of an encoder decoder pair
<html:ul><html:li><fr:tex display="inline"><![CDATA[e : [M] \to  \mathcal {X}^n]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[f: \mathcal {Y}^n \to  [M]]]></fr:tex></html:li>
    <html:li>
The rate is <fr:tex display="inline"><![CDATA[\log _{2}\frac {M}{n} = ]]></fr:tex> (log of the number of distinct pairs)/(number of channel users)
        </html:li>
        <html:li><fr:tex display="inline"><![CDATA[P_{e, \text {max}} = \max _{1 \leq  i \leq  m}\mathbb {P}(f(Y^n) \neq  i \mid  W = i)]]></fr:tex> - worst case over all transmitted messages prob of error.
            </html:li>
            <html:li><fr:tex display="inline"><![CDATA[P_{e} = \frac {1}{M}\sum _{i = 1}^{M} \mathbb {P}(f(Y^n) \neq  i \mid  W = i)]]></fr:tex> - average prob of error.
</html:li></html:ul></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006T/</fr:uri><fr:display-uri>006T</fr:display-uri><fr:route>/006T/</fr:route><fr:title text="Discrete memoryless channel">Discrete memoryless channel</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    We have the following components
    <html:ul><html:li><fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> - input alphabet <fr:tex display="inline"><![CDATA[|\mathcal {X}| < \infty ]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> - output alphabet <fr:tex display="inline"><![CDATA[|\mathcal {Y}| < \infty ]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[P_{Y|X}]]></fr:tex> - transition prob matrix</html:li></html:ul></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006U/</fr:uri><fr:display-uri>006U</fr:display-uri><fr:route>/006U/</fr:route><fr:title text="Achievable rates">Achievable rates</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A rate <fr:tex display="inline"><![CDATA[R \geq  0]]></fr:tex> is achievable if
<html:ol><html:li><fr:tex display="inline"><![CDATA[\lim _{n\to \infty } P_{e, \text {max}} = 0]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log _{2}M_n}{n} = R]]></fr:tex></html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006V/</fr:uri><fr:display-uri>006V</fr:display-uri><fr:route>/006V/</fr:route><fr:title text="Channel capacity">Channel capacity</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The channel capacity is the maximum <fr:link href="/006U/" title="Achievable rates" uri="https://kellenkanarios.com/006U/" display-uri="006U" type="local">achievable rate</fr:link> i.e. 
<fr:tex display="block"><![CDATA[C = \sup  \{R \geq  0 \mid  R \text { is achievable}\}  ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
    We make the following simplifying assumptions (for now)
    <html:ul><html:li>
We assume no feedback. This means that if we have <fr:tex display="inline"><![CDATA[W \to  X_{1} \to  Y_{1} \to  X_{2} \to  \cdots ]]></fr:tex> then <fr:tex display="inline"><![CDATA[X_i]]></fr:tex> does not use the knowledge of previous channel outputs i.e. <fr:tex display="inline"><![CDATA[Y^{i - 1} \leftrightarrow  (W, X^{i - 1}) \leftrightarrow  X_i]]></fr:tex>.
            </html:li>
            <html:li>
Random encoding: <fr:tex display="inline"><![CDATA[X^n(i)]]></fr:tex> is drawn i.i.d from some specified distribution <fr:tex display="inline"><![CDATA[P_X]]></fr:tex>.
                </html:li></html:ul>
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006W/</fr:uri><fr:display-uri>006W</fr:display-uri><fr:route>/006W/</fr:route><fr:title text="Information channel capacity">Information channel capacity</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The information channel capacity  of a <fr:link href="/006T/" title="Discrete memoryless channel" uri="https://kellenkanarios.com/006T/" display-uri="006T" type="local">DMC</fr:link> <fr:tex display="inline"><![CDATA[(\mathcal {X}, \mathcal {Y}, P_{Y|X})]]></fr:tex> is defined as
<fr:tex display="block"><![CDATA[C(P_{Y|X}) = \max _{P_X}I(X; Y)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006X/</fr:uri><fr:display-uri>006X</fr:display-uri><fr:route>/006X/</fr:route><fr:title text="Shannon's coding theorem">Shannon's coding theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Non rigorous: says that <fr:link href="/006V/" title="Channel capacity" uri="https://kellenkanarios.com/006V/" display-uri="006V" type="local">channel capacity</fr:link> and <fr:link href="/006W/" title="Information channel capacity" uri="https://kellenkanarios.com/006W/" display-uri="006W" type="local">information channel capacity</fr:link> are equal.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006Y/</fr:uri><fr:display-uri>006Y</fr:display-uri><fr:route>/006Y/</fr:route><fr:title text="Symmetric Channels">Symmetric Channels</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A channel is symmetric if
<html:ol><html:li>each row is a permutation of the first row</html:li> 
  <html:li>
  each column is a permutation of the first column
    </html:li></html:ol>
 It is weakly symmetric if it satisfies <fr:tex display="inline"><![CDATA[1]]></fr:tex> but the columns only sum to the same value.
</html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The capacity of a <fr:link href="/006Y/" title="Symmetric Channels" uri="https://kellenkanarios.com/006Y/" display-uri="006Y" type="local">symmetric or weakly symmetric</fr:link> channel is <fr:tex display="inline"><![CDATA[\log (|\mathcal {Y}|) - H(r)]]></fr:tex>, where <fr:tex display="inline"><![CDATA[r]]></fr:tex> is the first row of <fr:tex display="inline"><![CDATA[P_{Y|X}]]></fr:tex>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Channel Coding">Channel Coding</fr:title></fr:frontmatter><fr:mainmatter>
    <html:p>We have three components to the channel coding problem:</html:p>
    <html:ol><html:li>Channel encoder</html:li>
      <html:li>Noisy channel</html:li>
      <html:li>Channel decoder</html:li></html:ol>
    <html:p>We first pass <fr:tex display="inline"><![CDATA[W]]></fr:tex> to the channel encoder get some <fr:tex display="inline"><![CDATA[X^n]]></fr:tex> which goes into noisy channel and becomes <fr:tex display="inline"><![CDATA[Y^n]]></fr:tex>. Then the goal is for the channel decoder to recover <fr:tex display="inline"><![CDATA[W]]></fr:tex> from <fr:tex display="inline"><![CDATA[Y^n]]></fr:tex>. This means that the goal of the encoder is to reduce redundancy while also ensuring that there is no overlap when passed through the noisy channel.</html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0070/</fr:uri><fr:display-uri>0070</fr:display-uri><fr:route>/0070/</fr:route><fr:title text="General definition of channel">General definition of channel</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A channel (with memory) is a sequence of conditional distributions:_

<fr:tex display="block"><![CDATA[ P_{Y_{1}|X_{1}},P_{Y_{2}|Y_{1},X^{2}},P_{Y_{3}|Y^{2},X^{3}},\ldots ,P_{Y_{n}|Y^{n-1},X^{n}}, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ P_{Y_{n}|Y^{n-1},X^{n}} ]]></fr:tex> is a collection of distributions on <fr:tex display="inline"><![CDATA[ \mathcal {Y} ]]></fr:tex> one for every <fr:tex display="inline"><![CDATA[ (y^{n-1},x^{n})\in \mathcal {Y}^{n-1}\times \mathcal {X}^{n} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0071/</fr:uri><fr:display-uri>0071</fr:display-uri><fr:route>/0071/</fr:route><fr:title text="Encoder">Encoder</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
An encoder (with feedback) with parameter <fr:tex display="inline"><![CDATA[ (n,\Theta ) ]]></fr:tex> for a channel is a vector of mappings <fr:tex display="inline"><![CDATA[ e_{i} ]]></fr:tex> for <fr:tex display="inline"><![CDATA[ i=1,2,\ldots ,n ]]></fr:tex>, where

<fr:tex display="block"><![CDATA[ e_{i}:\{1,2,\ldots ,\Theta \}\times \mathcal {Y}^{i-1}\to \mathcal {X}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We can decompose the joint distribution <fr:tex display="inline"><![CDATA[P_{X^n, Y^n}]]></fr:tex> in terms of the what depends on the channel and the what depends on the encoder. Namely,
<fr:tex display="block"><![CDATA[P_{X^n, Y^n} = \prod _{i=1}^{n} P_{X_i | X^{i - 1}, Y^{i - 1}} \prod _{i=1}^{n}  P_{Y_i | X^{i}, Y^{i - 1}}]]></fr:tex>
Note that the first term depends only on the encoder and the second term depends only on the channel.
</fr:mainmatter></fr:tree>

<html:p><html:ul><html:strong>Assumptions:</html:strong>
  <html:li>The encoder is a deterministic function of <fr:tex display="inline"><![CDATA[\mathbf {W}]]></fr:tex></html:li>
  <html:li>The channel does not have access to the message <fr:tex display="inline"><![CDATA[\mathbf {W}]]></fr:tex>.</html:li></html:ul></html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Differential Entropy">Differential Entropy</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007C/</fr:uri><fr:display-uri>007C</fr:display-uri><fr:route>/007C/</fr:route><fr:title text="Differential Entropy">Differential Entropy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The differential entropy <fr:tex display="inline"><![CDATA[ h(X) ]]></fr:tex> of a continuous random variable <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> with density <fr:tex display="inline"><![CDATA[ f(x) ]]></fr:tex> is defined as

<fr:tex display="block"><![CDATA[ h(X)=-\int _{S}f(x)\log  f(x)\,dx, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ S ]]></fr:tex> is the support set of the random variable.
</html:p></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › AEP for Continuous Random Variables"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › AEP for Continuous Random Variables</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007E/</fr:uri><fr:display-uri>007E</fr:display-uri><fr:route>/007E/</fr:route><fr:title text="Typical Set for Continuous Random Variables">Typical Set for Continuous Random Variables</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For <fr:tex display="inline"><![CDATA[ \epsilon >0 ]]></fr:tex> and any <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>, we define the typical set <fr:tex display="inline"><![CDATA[ A_{\epsilon }^{(n)} ]]></fr:tex> with respect to <fr:tex display="inline"><![CDATA[ f(x) ]]></fr:tex> as follows:

<fr:tex display="block"><![CDATA[ A_{\epsilon }^{(n)}=\left \{(x_{1},x_{2},\ldots ,x_{n})\in  S^{n}:\left |-\frac {1}{n}\log  f(x_{1},x_{2},\ldots ,x_{n})-h(X)\right |\leq \epsilon \right \}, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ f(x_{1},x_{2},\ldots ,x_{n})=\prod _{i=1}^{n}f(x_{i}) ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007D/</fr:uri><fr:display-uri>007D</fr:display-uri><fr:route>/007D/</fr:route><fr:title text="Volume of set">Volume of set</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
 The volume Vol(<fr:tex display="inline"><![CDATA[ A ]]></fr:tex>) of a set <fr:tex display="inline"><![CDATA[ A\subset \mathcal {R}^{n} ]]></fr:tex> is defined as
<fr:tex display="block"><![CDATA[ \text {Vol}(A)=\int _{A}dx_{1}\,dx_{2}\,\cdots \,dx_{n}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007F/</fr:uri><fr:display-uri>007F</fr:display-uri><fr:route>/007F/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The typical set <fr:tex display="inline"><![CDATA[ A_{\epsilon }^{(n)} ]]></fr:tex> has the following properties:

<html:ol><html:li><fr:tex display="inline"><![CDATA[ \Pr \left (A_{\epsilon }^{(n)}\right )>1-\epsilon  ]]></fr:tex> for <fr:tex display="inline"><![CDATA[ n ]]></fr:tex> sufficiently large.
    </html:li>
  <html:li><fr:tex display="inline"><![CDATA[ \mathrm {Vol}\left (A_{\epsilon }^{(n)}\right )\leq 2^{n(h(X)+\epsilon )} ]]></fr:tex> for all <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>.
    </html:li>
  <html:li><fr:tex display="inline"><![CDATA[ \mathrm {Vol}\left (A_{\epsilon }^{(n)}\right )\geq (1-\epsilon )2^{n(h(X)-\epsilon )} ]]></fr:tex> for <fr:tex display="inline"><![CDATA[ n ]]></fr:tex> sufficiently large.
    </html:li></html:ol></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Discrete Approximation"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Discrete Approximation</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007G/</fr:uri><fr:display-uri>007G</fr:display-uri><fr:route>/007G/</fr:route><fr:title text="Discrete Approximation of Differential Entropy">Discrete Approximation of Differential Entropy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    For,
    <fr:tex display="block"><![CDATA[ p_{i}=\int _{i\,\Delta }^{(i+1)\,\Delta }f(x)\,d x=f(x_{i})\Delta \,. ]]></fr:tex>
    We define the discrete approximation of the differential entropy as
    <fr:tex display="block"><![CDATA[\begin {align*}
H(X^{\Delta })&\coloneqq  -\sum _{-\infty }^{\infty }p_{i}\log  p_{i} \\
&=-\sum _{-\infty }^{\infty }f(x_{i})\Delta \log (f(x_{i})\Delta ) \\ 
&=-\sum \Delta  f(x_{i})\log  f(x_{i})-\sum  f(x_{i})\Delta \log \Delta  \\ 
&=-\sum \Delta  f(x_{i})\log  f(x_{i})-\log \Delta ,
    .\end {align*}]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Taking <fr:tex display="inline"><![CDATA[\Delta  = 2^{-n}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[X^{\Delta }]]></fr:tex> is an "<fr:tex display="inline"><![CDATA[n]]></fr:tex>-bit" approximation of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007H/</fr:uri><fr:display-uri>007H</fr:display-uri><fr:route>/007H/</fr:route><fr:title text="Information dimension">Information dimension</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> be any real valued random variable, and let <fr:tex display="inline"><![CDATA[ X^{(1/n)} ]]></fr:tex> denote the discretization of <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> with parameter <fr:tex display="inline"><![CDATA[ \Delta =1/n ]]></fr:tex>. Then, the information dimension associated with <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> is defined as

<fr:tex display="block"><![CDATA[ d=\lim _{n\to \infty }\frac {H(X^{(1/n)})}{\log  n}, ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Gaussian Channel">Gaussian Channel</fr:title></fr:frontmatter><fr:mainmatter>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>6</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/DER0/</fr:uri>
            <fr:display-uri>DER0</fr:display-uri>
            <fr:route>/DER0/</fr:route>
            <fr:title text="Operations that preserve convexity">Operations that preserve convexity</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>The following operations preserve <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">convexity</fr:link></html:p>
            <html:ul><html:li><html:strong>Nonnegative weighted sums:</html:strong> if <fr:tex display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex and <fr:tex display="inline"><![CDATA[\alpha _1, \ldots , \alpha _n > 0]]></fr:tex> then we have <fr:tex display="inline"><![CDATA[f(\boldsymbol {x}) = \sum _{i = 1}^{n} \alpha _i f_i(\boldsymbol {x})]]></fr:tex> is convex</html:li>
    <html:li><html:strong>Pointwise maximum:</html:strong> if <fr:tex display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex then <fr:tex display="inline"><![CDATA[f(\boldsymbol {x}) = \max _i \{f_i(\boldsymbol {x})\}]]></fr:tex> is convex </html:li></html:ul>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>2</fr:month>
              <fr:day>3</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/004N/</fr:uri>
            <fr:display-uri>004N</fr:display-uri>
            <fr:route>/004N/</fr:route>
            <fr:title text="Suboptimality of Gradient Descent">Suboptimality of Gradient Descent</fr:title>
            <fr:taxon>Theorem</fr:taxon>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
Suppose the iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{i}\}_{i\geq 0}]]></fr:tex> is generated from a <html:em>black-box model</html:em>:

<fr:tex display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathcal {F}_{k}\left (\left \{\mathbf {x}_{i}\right \}_{i=0}^{k},\ \left \{f(\mathbf {x}_{i})\right \}_{i=0}^{k},\ \left \{\nabla  f(\mathbf {x}_{i})\right \}_{i=0}^{k}\right )]]></fr:tex></html:p>
            <html:p>
For every positive <fr:tex display="inline"><![CDATA[L]]></fr:tex> and <fr:tex display="inline"><![CDATA[R]]></fr:tex>, there exists a <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">convex</fr:link> differentiable <fr:tex display="inline"><![CDATA[f]]></fr:tex> with <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>, and an initial point <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}\leq  R]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \geq \ c\frac {LR}{k^{2}}\ =\ \Omega (\frac {1}{k^{2}}),]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\ c>0]]></fr:tex> is some numerical constant.

  </html:p>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>1</fr:month>
              <fr:day>26</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/0033/</fr:uri>
            <fr:display-uri>0033</fr:display-uri>
            <fr:route>/0033/</fr:route>
            <fr:title text="Notebook: Optimization Theory">Notebook: Optimization Theory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Convex Optimization Background">Convex Optimization Background</fr:title></fr:frontmatter><fr:mainmatter>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0034/</fr:uri><fr:display-uri>0034</fr:display-uri><fr:route>/0034/</fr:route><fr:title text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x}
\rangle ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0035/</fr:uri><fr:display-uri>0035</fr:display-uri><fr:route>/0035/</fr:route><fr:title text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER0/</fr:uri><fr:display-uri>DER0</fr:display-uri><fr:route>/DER0/</fr:route><fr:title text="Operations that preserve convexity">Operations that preserve convexity</fr:title></fr:frontmatter><fr:mainmatter><html:p>The following operations preserve <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">convexity</fr:link></html:p><html:ul><html:li><html:strong>Nonnegative weighted sums:</html:strong> if <fr:tex display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex and <fr:tex display="inline"><![CDATA[\alpha _1, \ldots , \alpha _n > 0]]></fr:tex> then we have <fr:tex display="inline"><![CDATA[f(\boldsymbol {x}) = \sum _{i = 1}^{n} \alpha _i f_i(\boldsymbol {x})]]></fr:tex> is convex</html:li>
    <html:li><html:strong>Pointwise maximum:</html:strong> if <fr:tex display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex then <fr:tex display="inline"><![CDATA[f(\boldsymbol {x}) = \max _i \{f_i(\boldsymbol {x})\}]]></fr:tex> is convex </html:li></html:ul></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0036/</fr:uri><fr:display-uri>0036</fr:display-uri><fr:route>/0036/</fr:route><fr:title text="Strong convexity">Strong convexity</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A function <fr:tex display="inline"><![CDATA[f]]></fr:tex> is <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex if and only if 
<fr:tex display="block"><![CDATA[g(\boldsymbol {x}) = f(\boldsymbol {x}) - \frac {\mu }{2} ||\boldsymbol {x}||_2^2]]></fr:tex>
is convex, <fr:tex display="inline"><![CDATA[\forall  \boldsymbol {x} \in  \mathrm {dom} f]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0037/</fr:uri><fr:display-uri>0037</fr:display-uri><fr:route>/0037/</fr:route><fr:title text="Smooth Problem">Smooth Problem</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A problem is <html:em>smooth</html:em> if both the objective function and the constraints are differentiable.</html:p></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0038/</fr:uri><fr:display-uri>0038</fr:display-uri><fr:route>/0038/</fr:route><fr:title text="Subgradient">Subgradient</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> be convex. A <html:em>subgradient</html:em> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> at <fr:tex display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex> is any <fr:tex display="inline"><![CDATA[\boldsymbol {u}]]></fr:tex> satisfying
<fr:tex display="block"><![CDATA[f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0039/</fr:uri><fr:display-uri>0039</fr:display-uri><fr:route>/0039/</fr:route><fr:title text="Subdifferential">Subdifferential</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The <html:em>subdifferential</html:em> is the set of all <fr:link href="/0038/" title="Subgradient" uri="https://kellenkanarios.com/0038/" display-uri="0038" type="local">subgradient's</fr:link> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> at <fr:tex display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex>.
<fr:tex display="block"><![CDATA[\partial  f(\boldsymbol {x}_0) \coloneqq  \{\boldsymbol {u} | f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle  \}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Useful Miscellanous Math Background">Useful Miscellanous Math Background</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
  In this section, we cover many random math facts / tools that come up / are useful in later optimization problems.
  </html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER1/</fr:uri><fr:display-uri>DER1</fr:display-uri><fr:route>/DER1/</fr:route><fr:title text="Basic Matrix Analysis">Basic Matrix Analysis</fr:title></fr:frontmatter><fr:mainmatter><html:ul><html:li><html:strong>Matrix inner product:</html:strong>
<fr:tex display="block"><![CDATA[\langle \mathbf {x},\mathbf {z}\rangle \ =\ \sum _{i=1}^{n}x_{i}z_{i}\quad \Longrightarrow \quad \langle \mathbf {X},\mathbf {Z}\rangle \ :=\ \sum _{i=1}^{m}\sum _{j=1}^{n}X_{i j}Z_{i j}]]></fr:tex></html:li>
    <html:li><html:strong>Matrix trace:</html:strong> <fr:tex display="inline"><![CDATA[{{M}}\in \mathbb {R}^{n\times  n};\ {{\mathrm {tr}}}({{M}}):=\sum _{i=1}^{n}M_{i i}]]></fr:tex>
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      &\langle {\boldsymbol  X},{\boldsymbol  Z}\rangle \ =\ \mathrm {tr}\left ({\boldsymbol  X}^{\top }{\boldsymbol  Z}\right )\ =\ \mathrm {tr}\left ({\boldsymbol  X}{\boldsymbol  Z}^{\top }\right ) \\
    &\operatorname {tr}(\mathbf {A}\mathbf {B})=\operatorname {tr}(\mathbf {B}\mathbf {A})\\
      &\operatorname {tr}(\mathbf {A}_{1}\mathbf {A}_{2}\cdots \mathbf {A}_{n})=\operatorname {tr}(\mathbf {A}_{\pi (1)}\mathbf {A}_{\pi (2)}\cdots \mathbf {A}_{\pi (n)})
      \end {align*}
    ]]></fr:tex>
    Where <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex> is a cyclic permutation on <fr:tex display="inline"><![CDATA[\{1,2,\cdots ,n\}]]></fr:tex></html:li></html:ul><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003A/</fr:uri><fr:display-uri>003A</fr:display-uri><fr:route>/003A/</fr:route><fr:title text="Positive (semi)definiteness">Positive (semi)definiteness</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A <html:em>symmetric</html:em> matrix <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{n\times  n}]]></fr:tex> is <html:em>positive definite</html:em> if <fr:tex display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}>0]]></fr:tex> for all nonzero <fr:tex display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. It is <html:em>positive semidefinite (p.s.d.)</html:em> if <fr:tex display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}\geq 0]]></fr:tex> for all <fr:tex display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. 
  </html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003B/</fr:uri><fr:display-uri>003B</fr:display-uri><fr:route>/003B/</fr:route><fr:title text="Singular Value Decomposition">Singular Value Decomposition</fr:title><fr:taxon>Fact</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with <fr:tex display="inline"><![CDATA[\operatorname {rank}(\mathbf {A})=r]]></fr:tex>. There exist <fr:tex display="inline"><![CDATA[\sigma _{1}\geq \sigma _{2}\geq \cdots \geq \sigma _{r}>0]]></fr:tex>, and matrices <fr:tex display="block"><![CDATA[\mathbf {U}\in \mathbb {R}^{m\times  r},\ \mathbf {V}\in \mathbb {R}^{n\times  r},]]></fr:tex> with <html:em>orthonormal</html:em> columns <fr:tex display="inline"><![CDATA[(\mathbf {U}^{\top }\mathbf {U}=\mathbf {I},\ \mathbf {V}^{\top }\mathbf {V}=\mathbf {I})]]></fr:tex> such that <fr:tex display="block"><![CDATA[\mathbf {A}\ =\ \mathbf {U}\mathbf {\Sigma }\mathbf {V}^{\top }\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }\,,\quad \mathbf {\Sigma }\ =\ \operatorname {diag}\left (\sigma _{1},\cdots ,\sigma _{r}\right ).]]></fr:tex></html:p><html:p>Relationship between eigen decomposition and SVD
  <html:ul><html:li>The columns of <fr:tex display="inline"><![CDATA[\boldsymbol {V}]]></fr:tex> are eigenvectors of <fr:tex display="inline"><![CDATA[\boldsymbol {A}^T\boldsymbol {A}]]></fr:tex></html:li>
      <html:li>The columns of <fr:tex display="inline"><![CDATA[\boldsymbol {U}]]></fr:tex> are eigenvectors of <fr:tex display="inline"><![CDATA[\boldsymbol {A}\boldsymbol {A}^T]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[{{\sigma _{i}({\mathbf {A}})}}={\sqrt {\lambda _{i}({{{\mathbf {A}}{\mathbf {A}}^{\mathsf {T}}}})}}={\sqrt {\lambda _{i}({\mathbf {A}}^{\mathsf {T}}{\mathbf {A}})}}]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003C/</fr:uri><fr:display-uri>003C</fr:display-uri><fr:route>/003C/</fr:route><fr:title text="Best rank-r approximation">Best rank-<fr:tex display="inline"><![CDATA[r]]></fr:tex> approximation</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
 Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with SVD, <fr:tex display="inline"><![CDATA[\mathbf {A}=\sum _{i=1}^{\min \{m,n\}}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }]]></fr:tex>. Then an optimal solution to the best rank-<fr:tex display="inline"><![CDATA[r]]></fr:tex> approximation problem <fr:tex display="block"><![CDATA[\min _{\mathbf {X}}||\mathbf {X}-\mathbf {A}||_{2}\,,\quad \text {s.t.}\quad \text {rank}(\mathbf {X})\ \leq \ r]]></fr:tex> is the truncated SVD of the following form <fr:tex display="block"><![CDATA[\boxed {\widehat {\mathbf {A}}_{r}\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }}\,,\ \ \text {if}\ \ \sigma _{r}>\sigma _{r+1}\,,\,\text {it is unique.}]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Suppose <fr:tex display="inline"><![CDATA[m \geq  n]]></fr:tex>, then we observe that
<fr:tex display="block"><![CDATA[\left |\left |{\widehat {\mathbf {A}}}_{r}-{\mathbf {A}}\right |\right |_{2}\;=\;\left |\left |\sum _{i=r+1}^{n}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\mathsf {T}}\right |\right |_{2} \leq  \sigma _{r+1}]]></fr:tex>

Second, to prove our result, we want to show that <fr:tex display="block"><![CDATA[\left |\left |\mathbf {B}_{r}-\mathbf {A}\right |\right |_{2}\ \geq \ \sigma _{r+1},\quad \forall \mathbf {B}_{r}\ \text {with}\ \mathrm {rank}(\mathbf {B}_{r})=r.]]></fr:tex> We suppose <fr:tex display="inline"><![CDATA[\ \mathbf {B}_{r}=\widetilde {\mathbf {U}}\widetilde {\mathbf {V}}^{\top },\quad \widetilde {\mathbf {U}}\in \mathbb {R}^{m\times  r},\ \widetilde {\mathbf {V}}\in \mathbb {R}^{n\times  r}.]]></fr:tex>
Note
<fr:tex display="block"><![CDATA[
\begin {align*}
||\mathbf {B}_r - A||_2^2 &= \sup _{||\boldsymbol {z}||_2 \leq  1} ||(\mathbf {B}_r - \mathbf {A})\mathbf {z}||_2^2 \\
&\geq  ||(\mathbf {B}_r - \mathbf {A})\mathbf {w}||_2^2
\end {align*}
]]></fr:tex>
Since <fr:tex display="inline"><![CDATA[\widetilde {V}]]></fr:tex> has <fr:tex display="inline"><![CDATA[r]]></fr:tex> columns, then there must be a nontrivial linear combination of the first <fr:tex display="inline"><![CDATA[r{+}1]]></fr:tex> columns of <fr:tex display="inline"><![CDATA[V]]></fr:tex>, i.e., <fr:tex display="block"><![CDATA[\mathbf {w}=\gamma _{1}\mathbf {v}_{1}+\cdots +\gamma _{r+1}\mathbf {v}_{r+1}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\widetilde {V}^{\top }\mathbf {w}=\mathbf {0}\,.]]></fr:tex> Wlog, we can scale <fr:tex display="inline"><![CDATA[\left |\left |\mathbf {w}\right |\right |_{2}=1]]></fr:tex> and <fr:tex display="inline"><![CDATA[\,\sum _{i=1}^{r+1}\gamma _{i}^{2}=1]]></fr:tex>
Then 
<fr:tex display="block"><![CDATA[||\mathbf {A}-\mathbf {B}_{k}||_{2}^{2}\geq ||(\mathbf {A}-\mathbf {B}_{k})\,\mathbf {w}||_{2}^{2}=||\mathbf {A}\mathbf {w}||_{2}^{2}=\gamma _{1}^{2}\sigma _{1}^{2}+\cdots +\gamma _{r+1}^{2}\sigma _{r+1}^{2}\geq \sigma _{r+1}^{2}.]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003G/</fr:uri><fr:display-uri>003G</fr:display-uri><fr:route>/003G/</fr:route><fr:title text="Matrix Operator Norm">Matrix Operator Norm</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. If <fr:tex display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{a}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{b}]]></fr:tex> are norms on <fr:tex display="inline"><![CDATA[\mathbb {R}^{n}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {R}^{m}]]></fr:tex>, we have <fr:tex display="block"><![CDATA[\left |\left |\mathbf {A}\right |\right |_{a\to  b}\ :=\ \sup _{\left |\left |\mathbf {x}\right |\right |_{a}\leq  1}\left |\left |\mathbf {A}\mathbf {x}\right |\right |_{b}.]]></fr:tex>
It satisfies the <html:em>three criteria</html:em> for norm, and is <html:em>submultiplicative</html:em> <fr:tex display="block"><![CDATA[||\boldsymbol {A}\boldsymbol {B}||_{a\to  b}\ \leq \ ||\boldsymbol {A}||_{a\to  b}\cdot  ||\boldsymbol {B}||_{a\to  b};]]></fr:tex>. 
<fr:tex display="block"><![CDATA[||{\cal  A}||_{2\to 2}\;=\;\sigma _{1}({\cal  A})\;\;(\mathrm {{spectral\ norm}},\;\mathrm {{write\ as}}\;||{\cal  A}||\;\;);\;]]></fr:tex>
<fr:tex display="block"><![CDATA[\begin {array}{l}{{||{\boldsymbol {A}}||_{1\to  b}\ =\ \operatorname *{max}_{j=1,\cdots ,n}||{\boldsymbol {A e}}_{j}||_{b}}}\\ {{||{\boldsymbol {A}}||_{a\to \infty }\ =\ \operatorname *{max}_{i=1,\cdots ,m}||{\boldsymbol {e}}_{i}^{*}{\boldsymbol {A}}||_{b}^{*}\,,\ \ ||{\boldsymbol {v}}||_{b}^{*}\ :=\ \operatorname *{sup}_{||{\boldsymbol {u}}||_{b}\leq 1}\langle {\boldsymbol {u}},{\boldsymbol {v}}\rangle \,,}}\end {array}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003H/</fr:uri><fr:display-uri>003H</fr:display-uri><fr:route>/003H/</fr:route><fr:title text="Unitary Invariant Matrix Norm">Unitary Invariant Matrix Norm</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}.]]></fr:tex> We say the matrix norm is unitary invariant if <fr:tex display="block"><![CDATA[\left ||\mathbf {A}\right ||_{\sharp }\ =\ \left ||\mathbf {PAQ}\right ||_{\sharp },\quad \forall \ \mathbf {P}\in  O(m),\ \mathbf {Q}\in  O(n).]]></fr:tex></html:p><html:p>Eg.
  <html:ul><html:li><html:strong>Spectral norm</html:strong> <fr:tex display="block"><![CDATA[||A||_{2 \to  2}=\sigma _{1}(A)=||\sigma (A)||_{\infty }]]></fr:tex></html:li>
    <html:li><html:strong>Frobenius norm</html:strong> <fr:tex display="block"><![CDATA[\left ||\mathbf {A}\right ||_{F}\ =\ \sqrt {\sum _{i=1}^{\min \{m,n\}}\sigma _{i}^{2}(\mathbf {A})}\ =\ \left ||\mathbf {\sigma }(\mathbf {A})\right ||_{2}]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003I/</fr:uri><fr:display-uri>003I</fr:display-uri><fr:route>/003I/</fr:route><fr:title text="Schatten p-norm">Schatten <fr:tex display="inline"><![CDATA[p]]></fr:tex>-norm</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. For any <fr:tex display="inline"><![CDATA[p \in  [1,+\infty ]]]></fr:tex>, the function <fr:tex display="block"><![CDATA[\left ||\mathbf {A}|\right |_{\mathrm {S}_{p}}\,:=\,\left ||\mathbf {\sigma }(\mathbf {A})|\right |_{p}]]></fr:tex> is a norm on <fr:tex display="inline"><![CDATA[\,\mathbb {R}^{m\times  n}]]></fr:tex>. 
</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER2/</fr:uri><fr:display-uri>DER2</fr:display-uri><fr:route>/DER2/</fr:route><fr:title text="Taylor Expansion and Lipschitz Functions">Taylor Expansion and Lipschitz Functions</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003J/</fr:uri><fr:display-uri>003J</fr:display-uri><fr:route>/003J/</fr:route><fr:title text="Lipschitz Continous">Lipschitz Continous</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose that 
<html:ul><html:li><fr:tex display="inline"><![CDATA[f:\mathcal {X}\mapsto \mathcal {Y}]]></fr:tex> with <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> being open sets;</html:li> 
  <html:li><fr:tex display="inline"><![CDATA[||\cdot ||_{\mathcal {X}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[||\cdot ||_{\mathcal {Y}}]]></fr:tex> are norms on <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {Y}]]></fr:tex>, respectively.</html:li></html:ul>
<fr:tex display="inline"><![CDATA[f(\cdot )]]></fr:tex> is Lipschitz continuous over <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> if <fr:tex display="inline"><![CDATA[\exists  L<\infty \,,]]></fr:tex> such that <fr:tex display="block"><![CDATA[||f(\boldsymbol {y})-f(\boldsymbol {x})||_{\mathcal {Y}}\ \leq \ L(\boldsymbol {x})\,||\boldsymbol {y}-\boldsymbol {x}||_{\mathcal {X}}\,,\quad \forall \boldsymbol {x},\ \boldsymbol {y}\in \mathcal {X}.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003K/</fr:uri><fr:display-uri>003K</fr:display-uri><fr:route>/003K/</fr:route><fr:title text="Smooth Function">Smooth Function</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
     A differentiable function <fr:tex display="inline"><![CDATA[f(\mathbf {x})]]></fr:tex> is called smooth iff it has a Lipschitz continuous gradient, i.e., iff <fr:tex display="inline"><![CDATA[L< \infty ]]></fr:tex> such that <fr:tex display="block"><![CDATA[||\nabla  f(\mathbf {x})-\nabla  f(\mathbf {z}) ||_{2}\ \leq  L ||\mathbf {x}-\mathbf {z} ||_{2},\quad  \forall  \mathbf {x},\ \mathbf {z}\in \mathbb {R}^{n}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003L/</fr:uri><fr:display-uri>003L</fr:display-uri><fr:route>/003L/</fr:route><fr:title text="Mean Value Theorem I">Mean Value Theorem I</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
 Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be continuously differentiable. For any fixed <fr:tex display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex display="block"><![CDATA[\,f(\mathbf {y})\,=\,f(\mathbf {x})\,+\,\langle \nabla  f(\mathbf {z}(t_{L})),\mathbf {y}-\mathbf {x}\rangle \,]]></fr:tex> for some <fr:tex display="inline"><![CDATA[\mathbf {z}(t_{L})=(1-t_{L})\cdot \mathbf {x}+t_{L}\cdot \mathbf {y}]]></fr:tex> with <fr:tex display="inline"><![CDATA[t_{L}\in (0,1)\,]]></fr:tex>. 
  </html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        <html:ul><html:li> If <fr:tex display="inline"><![CDATA[f:\mathbb {R}^n\mapsto \mathbb {R}]]></fr:tex> is continuously differentiable, <fr:tex display="block"><![CDATA[\begin {aligned}      |f(\pmb {x})-f(\pmb {y})| &\leq  & \sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2 \, ||\pmb {x}-\pmb {y}||_2   \end {aligned}]]></fr:tex> so that the Lipschitz constant of <fr:tex display="inline"><![CDATA[f]]></fr:tex> is <fr:tex display="inline"><![CDATA[\sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2]]></fr:tex>.</html:li>
          <html:li>If <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is twice continuously differentiable, <fr:tex display="block"><![CDATA[||\nabla  f(\boldsymbol {x})-\nabla  f(\boldsymbol {y})||_{2}\ \leq \ \sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}\,||\boldsymbol {x}-\boldsymbol {y}||_{2}]]></fr:tex> so that the Lipschitz constant of <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> is <fr:tex display="inline"><![CDATA[\sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}]]></fr:tex></html:li></html:ul>
      </fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003M/</fr:uri><fr:display-uri>003M</fr:display-uri><fr:route>/003M/</fr:route><fr:title text="Mean Value Theorem II">Mean Value Theorem II</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be twice continuously differentiable. For any fixed <fr:tex display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex display="block"><![CDATA[\nabla  f(\mathbf {y})\;=\;\nabla  f(\mathbf {x})\,+\,\int _{0}^{1}\nabla ^{2}f(\mathbf {z}(t))\cdot (\mathbf {y}-\mathbf {x})dt]]></fr:tex> for some <fr:tex display="inline"><![CDATA[\mathbf {z}(t)=(1-t)\mathbf {x}+t\mathbf {y}]]></fr:tex> with <fr:tex display="inline"><![CDATA[t\in (0,1)\,,]]></fr:tex> and that <fr:tex display="block"><![CDATA[\boxed {f(\mathbf {y})\;=\;f(\mathbf {x})+(\nabla  f(\mathbf {x}),\mathbf {y}-\mathbf {x})+\frac {1}{2}(\mathbf {y}-\mathbf {x})^{\top }\nabla ^{2}f(\mathbf {z}(t_{Q}))(\mathbf {y}-\mathbf {x})}]]></fr:tex> for some <fr:tex display="inline"><![CDATA[t_{Q}\in (0,1)\,.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003N/</fr:uri><fr:display-uri>003N</fr:display-uri><fr:route>/003N/</fr:route><fr:title text="First-order approximation">First-order approximation</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be continuously differentiable, and <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:tex display="inline"><![CDATA[\gamma _{L}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{L}(\mathbf {x}_{0})}{2}\,||\mathbf {x}-\mathbf {x}_{0}||_{2}^{2}\,,]]></fr:tex> where we define <fr:tex display="block"><![CDATA[\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\ :=\ f(\mathbf {x}_{0})\ +\ \langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle \,.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003O/</fr:uri><fr:display-uri>003O</fr:display-uri><fr:route>/003O/</fr:route><fr:title text="Second-order approximation">Second-order approximation</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be twice continuously differentiable, and suppose <fr:tex display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x})]]></fr:tex> is <fr:tex display="inline"><![CDATA[\gamma _{Q}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{Q}(\mathbf {x}_{0})}{6}\left ||\mathbf {x}-\mathbf {x}_{0}\right ||_{2}^{3},]]></fr:tex> where we define <fr:tex display="block"><![CDATA[\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0}):=f(\mathbf {x}_{0})+\langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle ]]></fr:tex> <fr:tex display="block"><![CDATA[+\frac {1}{2}(\mathbf {x}-\mathbf {x}_{0})^{\top }\nabla ^{2}f(\mathbf {x}_{0})(\mathbf {x}-\mathbf {x}_{0}).]]></fr:tex></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER3/</fr:uri><fr:display-uri>DER3</fr:display-uri><fr:route>/DER3/</fr:route><fr:title text="Optimality Conditions">Optimality Conditions</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003P/</fr:uri><fr:display-uri>003P</fr:display-uri><fr:route>/003P/</fr:route><fr:title text="Stationary point">Stationary point</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    A point <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a stationary point of <fr:tex display="inline"><![CDATA[f(\cdot )]]></fr:tex>, if <fr:tex display="block"><![CDATA[\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.]]></fr:tex> Here, <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is also known as a critical point.
  </html:p></fr:mainmatter></fr:tree><html:ul><html:li><html:strong>First order necessary condition</html:strong>:
    If <fr:tex display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex display="inline"><![CDATA[\ f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f]]></fr:tex> is continuously differentiable in an open neighborhood of <fr:tex display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex display="block"><![CDATA[\boxed {\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.}]]></fr:tex>
    <html:li><html:strong>Second order necessary condition:</html:strong>
    If <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f]]></fr:tex> is twice continuously differentiable in an open neighborhood around <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex display="block"><![CDATA[(i)\ \nabla  f(\mathbf {x_{\star }})=\mathbf {0};]]></fr:tex> <fr:tex display="block"><![CDATA[(ii)\ \nabla ^{2}f(\mathbf {x_{\star }})\succeq \mathbf {0}.]]></fr:tex>
    <html:ul><html:li>If <fr:tex display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x_{\star }})\succ \mathbf {0}]]></fr:tex> then the above is a sufficient condition.</html:li></html:ul></html:li></html:li></html:ul>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be a convex function, then 
  <html:ul><html:li>A local minimizer of <fr:tex display="inline"><![CDATA[f]]></fr:tex> is also its global minimizer. If <fr:tex display="inline"><![CDATA[f]]></fr:tex> is strictly convex, the global minimizer is unique</html:li>
    <html:li>A point is a global minimizer of <fr:tex display="inline"><![CDATA[f]]></fr:tex> iff <fr:tex display="block"><![CDATA[\mathbf {0}\ \in \ \partial  f(\mathbf {x_{\star }}).]]></fr:tex></html:li></html:ul>
  If <fr:tex display="inline"><![CDATA[f\in \mathcal {C}^{1}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x_{\star }})=\mathbf {0}]]></fr:tex> implies that <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a global minimizer.
  </fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER4/</fr:uri><fr:display-uri>DER4</fr:display-uri><fr:route>/DER4/</fr:route><fr:title text="Constrained Optimality">Constrained Optimality</fr:title></fr:frontmatter><fr:mainmatter><html:p>
    Consider a smooth contained problem with <fr:tex display="block"><![CDATA[\min _{\mathbf {x}}f(\mathbf {x}),\quad  \text {s.t.} \quad  r_{i}(\mathbf {x})\ =\ 0,\ 1\leq  i\leq  p,]]></fr:tex> <fr:tex display="block"><![CDATA[h_{j}(\mathbf {x})\ \leq \ 0,\ 1\leq  j\leq  q.]]></fr:tex> Consider its Lagrangian function <fr:tex display="block"><![CDATA[\mathscr {L}(\mathbf {x},\mathbf {u},\mathbf {v})\ =\ f(\mathbf {x})+\sum _{i=1}^{p}u_{i}\cdot  r_{i}(\mathbf {x})+\sum _{j=1}^{q}v_{j}\cdot  h_{j}(\mathbf {x}).]]></fr:tex>
    <html:strong>KKT-conditions:</html:strong>
    <html:ul><html:li>Stationary <fr:tex display="block"><![CDATA[\nabla _{\mathbf {x}}{\mathcal {L}}(\mathbf {x_*},\mathbf {u_*},\mathbf {v_*})\;=\;\mathbf {0}]]></fr:tex></html:li>
    <html:li>Primal Feasibility: <fr:tex display="block"><![CDATA[\begin {array}{l}{{r_{i}(x_{\star })\ =\ 0,\ 1\leq  i\leq  p,}}\\ {{h_{j}(x_{\star })\ \leq \ 0,\ 1\leq  j\leq  q.}}\end {array}]]></fr:tex></html:li>
    <html:li>Dual Feasibility: <fr:tex display="block"><![CDATA[v_{\star }\geq  0.]]></fr:tex></html:li>
    <html:li>Complimentary slackness: <fr:tex display="block"><![CDATA[h_{j}(x_{\star })\cdot  v_{\star  j}\ =\ 0,\quad \forall \ 1\leq  j\leq  q.]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER5/</fr:uri><fr:display-uri>DER5</fr:display-uri><fr:route>/DER5/</fr:route><fr:title text="Rate of Convergence">Rate of Convergence</fr:title></fr:frontmatter><fr:mainmatter><html:p>
  Want to find
<fr:tex display="block"><![CDATA[\operatorname *{min}_{\mathbf {x}}\ f(\mathbf {x}),\quad \text {s.t.}\quad \mathbf {x}\ \in \ \mathcal {C}.]]></fr:tex> Solve the problem via iterative methods of optimization, which produce a sequence of points <fr:tex display="block"><![CDATA[\mathbf {x}_{1},\ \mathbf {x}_{2},\ \cdots ,\mathbf {x}_{k},\cdots ]]></fr:tex> starting from an initialization <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>. 
  </html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003R/</fr:uri><fr:display-uri>003R</fr:display-uri><fr:route>/003R/</fr:route><fr:title text="First-order convergence">First-order convergence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
     First-order function value convergence 
     <fr:tex display="block"><![CDATA[||\nabla  f(\mathbf {x}_k)||_2 \; \leq  \; \varepsilon .]]></fr:tex>
       <html:ul><html:li> For convex functions, this also means convergence to the global minimizer</html:li>
        <html:li>For nonconvex functions, this only means   convergence to a <fr:link href="/003P/" title="Stationary point" uri="https://kellenkanarios.com/003P/" display-uri="003P" type="local">Stationary point</fr:link> (e.g., a local minimizer or a saddle point).</html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003Q/</fr:uri><fr:display-uri>003Q</fr:display-uri><fr:route>/003Q/</fr:route><fr:title text="Q-convergence"><fr:tex display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say the <fr:tex display="inline"><![CDATA[Q]]></fr:tex>-convergence is of order <fr:tex display="inline"><![CDATA[(p \geq 1)]]></fr:tex> and with factor <fr:tex display="inline"><![CDATA[(\gamma  > 0)]]></fr:tex>, if <fr:tex display="inline"><![CDATA[\exists  k_{0}]]></fr:tex>, such that <fr:tex display="inline"><![CDATA[\forall  k\geq  k_{0}]]></fr:tex>: <fr:tex display="block"><![CDATA[\boxed {\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k}}-\mathbf {x_{*}}||_{2}\ \leq \ \gamma \cdot \left (\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k-1}}-\mathbf {x_{*}}||_{2}\right )^{p}.}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003S/</fr:uri><fr:display-uri>003S</fr:display-uri><fr:route>/003S/</fr:route><fr:title text="R-convergence"><fr:tex display="inline"><![CDATA[R]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say the <fr:tex display="inline"><![CDATA[R]]></fr:tex>-convergence is of order <fr:tex display="inline"><![CDATA[p\;(\geq 1)]]></fr:tex>, <fr:tex display="block"><![CDATA[\min _{\mathbf {x}_{*}\in \mathcal {X}}||\mathbf {x}_{k}-\mathbf {x}_{*}||_{2}\;\leq \;\rho _{k},]]></fr:tex> if the sequence <fr:tex display="inline"><![CDATA[\{\rho _{k}\}_{k\geq 1}]]></fr:tex> is <fr:link href="/003Q/" title="Q-convergence" uri="https://kellenkanarios.com/003Q/" display-uri="003Q" type="local"><fr:tex display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:link> of the order <fr:tex display="inline"><![CDATA[p]]></fr:tex>. 
  </html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Iterative Methods">Iterative Methods</fr:title></fr:frontmatter><fr:mainmatter>
  <html:strong>Assume:</html:strong>
  <html:ul><html:li><fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is a <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">Convex Function</fr:link> and a <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">Smooth Function</fr:link>.</html:li>
      <html:li>The gradient <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>.</html:li></html:ul>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER6/</fr:uri><fr:display-uri>DER6</fr:display-uri><fr:route>/DER6/</fr:route><fr:title text="Convergence of Gradient Descent">Convergence of Gradient Descent</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004L/</fr:uri><fr:display-uri>004L</fr:display-uri><fr:route>/004L/</fr:route><fr:title text="Sufficient Value">Sufficient Value</fr:title><fr:taxon>Lemma</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
With step size <fr:tex display="inline"><![CDATA[\tau _{k}=1/L\,,]]></fr:tex> the gradient descent iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by

<fr:tex display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathbf {x}_{k}\ -\ \tau _{k}\cdot \nabla  f(\mathbf {x}_{k})]]></fr:tex>

satisfy the following:

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k+1})\ \leq \ f(\mathbf {x}_{k})\ -\ \frac {1}{2L}\,||\nabla  f(\mathbf {x}_{k})||_{2}^{2}]]></fr:tex> <fr:tex display="block"><![CDATA[<\ f(\mathbf {x}_{k})\quad (||\nabla  f(\mathbf {x}_{k})||_{2}\neq 0)]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Because <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> is Lipschitz, by 1st-order Taylor approximation

<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})+\langle \nabla  f(\mathbf {x}),\mathbf {x}^{\prime }-\mathbf {x}\rangle +\frac {L}{2}\left ||\mathbf {x}^{\prime }-\mathbf {x}\right ||_{2}^{2},\quad \forall \ \mathbf {x}^{\prime },\mathbf {x}]]></fr:tex>
Now take <fr:tex display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \tau  \nabla  f( \mathbf {x})]]></fr:tex>. Then
<fr:tex display="block"><![CDATA[
  \begin {align*}
    f(\mathbf {x}^{\prime }) &\leq  f(\mathbf {x})+ \tau  ||\nabla  f( \mathbf {x} )||_2^2 + \frac {\tau ^2 L}{2} ||\nabla  f( \mathbf {x})||_2^2 \\
    &= f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2
  \end {align*}
]]></fr:tex>
  Take <fr:tex display="inline"><![CDATA[\tau  = \frac {1}{L}]]></fr:tex>, such that
<fr:tex display="block"><![CDATA[
    \begin {align*}
f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2 &= f( \mathbf {x}) - \frac {1}{2L}||\nabla  f( \mathbf {x})||_2^2
    \end {align*}
  ]]></fr:tex>
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004M/</fr:uri><fr:display-uri>004M</fr:display-uri><fr:route>/004M/</fr:route><fr:title text="Sublinear convergence of GD">Sublinear convergence of GD</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. If we run GD for <fr:tex display="inline"><![CDATA[k]]></fr:tex> iterations with a fixed step size <fr:tex display="inline"><![CDATA[\tau =1/L]]></fr:tex>, it will yield a sequence <fr:tex display="inline"><![CDATA[\left \{\mathbf {x}_{k}\right \}_{k\geq 1}]]></fr:tex> such that

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}\ =\ O(\frac {1}{k}),]]></fr:tex>

Moreover, as <fr:tex display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.

  </html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Given <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex and smooth, and <fr:tex display="inline"><![CDATA[\mathbf {x}_*]]></fr:tex> is an optimal solution, then
<fr:tex display="block"><![CDATA[f(\mathbf {x}_{\star })\geq  f(\mathbf {x})+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}_{\star }-\mathbf {x})]]></fr:tex>
Flipping the inequality yields
<fr:tex display="block"><![CDATA[f(\mathbf {x})\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })]]></fr:tex>
By <fr:link href="/004L/" title="Sufficient Value" uri="https://kellenkanarios.com/004L/" display-uri="004L" type="local">previous lemma</fr:link>, taking <fr:tex display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \frac {1}{L} \nabla  f( \mathbf {x})]]></fr:tex> yields
<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
such that
<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
Equivalently,
<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })\leq {\frac {L}{2}}\left [{\frac {2}{L}}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{L^{2}}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ]]]></fr:tex>
Completing the square,
<fr:tex display="block"><![CDATA[
\begin {align*}
 f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })&\leq \frac {L}{2}\left [\frac {2}{L}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-\frac {1}{L^{2}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ] \\ 
 &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}-\frac {1}{L}\nabla  f(\mathbf {x})-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \\ 
 &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}^{\prime }-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]
\end {align*}
]]></fr:tex>
Let <fr:tex display="inline"><![CDATA[\mathbf {x}_{k}=\mathbf {x}_{k-1}-\frac {1}{L}\nabla  f(\mathbf {x}_{k-1})]]></fr:tex>, then we have

<fr:tex display="block"><![CDATA[
\begin {align*}
 \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right ) &\leq  \frac {L}{2}\sum _{i=1}^{k}\left [\left ||\mathbf {x}_{i-1}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{i}-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]
 \\ &=\frac {L}{2}\left [\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{k}-\mathbf {x}_{0}\right ||_{2}^{2}\right ] \\ 
 &\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2} 
\end {align*}
]]></fr:tex>
Therefore, given <fr:tex display="inline"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\leq  f(\mathbf {x}_{i})-f(\mathbf {x}_{*}) \text { for } \forall  i\leq  k\,,]]></fr:tex>

<fr:tex display="block"><![CDATA[k\left (f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\right )\leq \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right )\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004N/</fr:uri><fr:display-uri>004N</fr:display-uri><fr:route>/004N/</fr:route><fr:title text="Suboptimality of Gradient Descent">Suboptimality of Gradient Descent</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose the iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{i}\}_{i\geq 0}]]></fr:tex> is generated from a <html:em>black-box model</html:em>:

<fr:tex display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathcal {F}_{k}\left (\left \{\mathbf {x}_{i}\right \}_{i=0}^{k},\ \left \{f(\mathbf {x}_{i})\right \}_{i=0}^{k},\ \left \{\nabla  f(\mathbf {x}_{i})\right \}_{i=0}^{k}\right )]]></fr:tex></html:p><html:p>
For every positive <fr:tex display="inline"><![CDATA[L]]></fr:tex> and <fr:tex display="inline"><![CDATA[R]]></fr:tex>, there exists a <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">convex</fr:link> differentiable <fr:tex display="inline"><![CDATA[f]]></fr:tex> with <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>, and an initial point <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}\leq  R]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \geq \ c\frac {LR}{k^{2}}\ =\ \Omega (\frac {1}{k^{2}}),]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\ c>0]]></fr:tex> is some numerical constant.

  </html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER7/</fr:uri><fr:display-uri>DER7</fr:display-uri><fr:route>/DER7/</fr:route><fr:title text="Accelerated Gradient Descent">Accelerated Gradient Descent</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004O/</fr:uri><fr:display-uri>004O</fr:display-uri><fr:route>/004O/</fr:route><fr:title text="Nesterov's Method">Nesterov's Method</fr:title></fr:frontmatter><fr:mainmatter><html:p>
Generate two sequences <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}{\mathrm {~and~}}\{\mathbf {p}_{k}\}_{k\geq 1}]]></fr:tex>
<fr:tex display="block"><![CDATA[
\begin {align*}
{\mathbf {\mathit {p}}}_{k+1}\ &=\ {\mathbf {\mathit {x}}}_{k}\ +\ \beta _{k}\cdot ({\mathbf {\mathit {x}}}_{k}-{\mathbf {\mathit {x}}}_{k-1}), \\
x_{k+1} &= p_{k+1}-\alpha \nabla  f(p_{k+1})
\end {align*}
]]></fr:tex>
<html:ul><html:li><html:strong>Not</html:strong> a descent method.</html:li>
<html:li>With properly chosen <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\beta ]]></fr:tex> can achieve <fr:link href="/004N/" title="Suboptimality of Gradient Descent" uri="https://kellenkanarios.com/004N/" display-uri="004N" type="local">optimal</fr:link> convergence rate <fr:tex display="inline"><![CDATA[O(1/k^2)]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004P/</fr:uri><fr:display-uri>004P</fr:display-uri><fr:route>/004P/</fr:route><fr:title text="Convergence of accelerated GD">Convergence of accelerated GD</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. The iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by the accelerated GD method satisfy

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2(k+1)^{2}}\ ||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}^{2}\ =\ O(\frac {1}{k^{2}}).]]></fr:tex>

Moreover, as <fr:tex display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER8/</fr:uri><fr:display-uri>DER8</fr:display-uri><fr:route>/DER8/</fr:route><fr:title text="Line Search">Line Search</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004Q/</fr:uri><fr:display-uri>004Q</fr:display-uri><fr:route>/004Q/</fr:route><fr:title text="Exact Linesearch">Exact Linesearch</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    For 
<fr:tex display="block"><![CDATA[x_{k+1}\ =\ x_{k}\ -\ \tau _{k}\cdot \nabla  f(x_{k})]]></fr:tex>
Choose step size by solving
<fr:tex display="block"><![CDATA[\tau _{k}\;=\;\arg \operatorname *{min}_{t\geq 0}\;f({\mathbf {x}}_{k}-t\cdot \nabla  f({\mathbf {x}}_{k}))]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Way to computationally expensive to use in practice.</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004R/</fr:uri><fr:display-uri>004R</fr:display-uri><fr:route>/004R/</fr:route><fr:title text="Armijo Condition">Armijo Condition</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  For some <fr:tex display="inline"><![CDATA[c_1 \in  (0,1)]]></fr:tex>,
<fr:tex display="block"><![CDATA[f( \mathbf {x}_k + \tau _k \cdot  \mathbf {d}_k) < f( \mathbf {x}_k) + c_1 \cdot  \tau _k \cdot  \mathbf {d}_{k}^{\top } \nabla  f(\mathbf {x}_k)]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004S/</fr:uri><fr:display-uri>004S</fr:display-uri><fr:route>/004S/</fr:route><fr:title text="Wolfe condition">Wolfe condition</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  For some <fr:tex display="inline"><![CDATA[0 < c_1 < c_2 < 1]]></fr:tex>,
<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k}+\tau _{k}\cdot \mathbf {d}_{k})\ <\ f(\mathbf {x}_{k})+c_{1}\cdot \tau _{k}\cdot \mathbf {d}_{k}^{\intercal }\nabla  f(\mathbf {x}_{k})]]></fr:tex>
<fr:tex display="block"><![CDATA[d_{k}^{\top }\nabla  f({\mathbf {x}}_{k}+\tau _{k}{\mathbf {d}}_{k})\ \geq \ c_{2}{\mathbf {d}}_{k}^{\top }\nabla  f({\mathbf {x}}_{k})]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        Wolfe condition requires evaluating gradient of function each update to <fr:tex display="inline"><![CDATA[\tau _k]]></fr:tex>. However,  <fr:link href="/004R/" title="Armijo Condition" uri="https://kellenkanarios.com/004R/" display-uri="004R" type="local">Armijo Condition</fr:link> only requires evaluating gradient once. Therefore, it is primarily used in practice.
      </fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        Backtracking is not used in optimizing DNNs because even function evaluation is very expensive.
      </fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004T/</fr:uri><fr:display-uri>004T</fr:display-uri><fr:route>/004T/</fr:route><fr:title text="Convergence of GD with backtracking">Convergence of GD with backtracking</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let the function <fr:tex display="inline"><![CDATA[f(\pmb {x})]]></fr:tex> be <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex and <fr:tex display="inline"><![CDATA[L]]></fr:tex>-smooth. With backtracking

linesearch, the GD method converges with

<fr:tex display="block"><![CDATA[f(\pmb {x}_k)-f(\pmb {x}_\star )\ \le \ \left (1-\min \left \{2c_1\mu ,\dfrac {2\alpha  c_1\mu }{L}\right \}\right )^k(f(\pmb {x}_0)-f(\pmb {x}_\star ))]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\pmb {x}_\star ]]></fr:tex> is the unique minimizer.
</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER9/</fr:uri><fr:display-uri>DER9</fr:display-uri><fr:route>/DER9/</fr:route><fr:title text="How function properties affect convergence">How function properties affect convergence</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004U/</fr:uri><fr:display-uri>004U</fr:display-uri><fr:route>/004U/</fr:route><fr:title text="Linear convergence for strong convexity">Linear convergence for strong convexity</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be smooth and <fr:link href="/0036/" title="Strong convexity" uri="https://kellenkanarios.com/0036/" display-uri="0036" type="local"><fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex</fr:link>, and suppose its gradient <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>. Choose a fixed step size <fr:tex display="inline"><![CDATA[\tau _{k}\equiv \tau =\frac {2}{\mu +L}]]></fr:tex>, then

<fr:tex display="block"><![CDATA[\left ||\mathbf {x}_{k}-\mathbf {x}_{\star }\right ||_{2}\ \leq \ \left (\frac {\kappa -1}{\kappa +1}\right )^{k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2},]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\kappa =\frac {L}{\mu }]]></fr:tex> is the condition number, and <fr:tex display="inline"><![CDATA[\mathbf {x}_{\star }]]></fr:tex> is the minimizer.
</html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        <fr:link href="/0036/" title="Strong convexity" uri="https://kellenkanarios.com/0036/" display-uri="0036" type="local">Strong convexity</fr:link> is a sufficient but not necessary condition for linear convergene of gradient descent.
      </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DERA/</fr:uri><fr:display-uri>DERA</fr:display-uri><fr:route>/DERA/</fr:route><fr:title text="Newton and Quasi-Newton Method">Newton and Quasi-Newton Method</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004V/</fr:uri><fr:display-uri>004V</fr:display-uri><fr:route>/004V/</fr:route><fr:title text="Newton's Method">Newton's Method</fr:title></fr:frontmatter><fr:mainmatter><html:p>Consider <fr:link href="/003O/" title="Second-order approximation" uri="https://kellenkanarios.com/003O/" display-uri="003O" type="local">second-order taylor approximation</fr:link> of <fr:tex display="inline"><![CDATA[f]]></fr:tex>
<fr:tex display="block"><![CDATA[ f(\mathbf {x}_{k}+\mathbf {d})\ \approx \ \underbrace {f(\mathbf {x}_{k})+\mathbf {d}^{\top }\nabla  f(\mathbf {x}_{k})+{\frac {1}{2}}\mathbf {d}^{\top }\nabla ^{2}f(\mathbf {x}_{k})\mathbf {d}}_{Q_k( \mathbf {d})}]]></fr:tex>
Then setting <fr:tex display="inline"><![CDATA[\nabla  Q_k( \mathbf {d})]]></fr:tex> and solving for <fr:tex display="inline"><![CDATA[\mathbf {d}]]></fr:tex>, we get
<fr:tex display="block"><![CDATA[
  \nabla  f( \mathbf {x}_k) + \frac {1}{2}\nabla ^2 f( \mathbf {x}_k) \mathbf {d} = 0
]]></fr:tex>
Thus, take <html:em>Newton's direction</html:em>
<fr:tex display="block"><![CDATA[\mathbf {d}_{k}^{N}=-\left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}\nabla  f(\mathbf {x}_{k}).]]></fr:tex></html:p>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  Some notes
    <html:ul><html:li><html:strong>Fast convergence:</html:strong> Newton's method usually has local quadratic convergence.</html:li>
      <html:li><html:strong>Expensive:</html:strong> requires storing and inverting <fr:tex display="inline"><![CDATA[\nabla ^2 f( \mathbf {x})]]></fr:tex>.</html:li>
      <html:li><html:strong>Unstable:</html:strong> <fr:tex display="inline"><![CDATA[\nabla ^2 f \succ  0]]></fr:tex> might not hold for general nonlinear problems.</html:li></html:ul>
  </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004W/</fr:uri><fr:display-uri>004W</fr:display-uri><fr:route>/004W/</fr:route><fr:title text="Quasi-Newton's Method">Quasi-Newton's Method</fr:title></fr:frontmatter><fr:mainmatter><html:p>Get around computing and inverting hessian by using a surrogate i.e. 
<fr:tex display="block"><![CDATA[\mathbf {d}_{k}^{QN}=-\underbrace {\mathbf {H}_k}_{\text {surrogate for } \left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}} \nabla  f(\mathbf {x}_{k}).]]></fr:tex>
Want
<fr:tex display="block"><![CDATA[{\mathbf {H}}_{k+1}^{-1}\cdot \underbrace {({\mathbf {x}}_{k+1}-{\mathbf {x}}_{k})}_{{\mathbf {s}}_{k}}\;=\;\underbrace {\nabla  f({\mathbf {x}}_{k+1})-\nabla  f({\mathbf {x}}_{k})}_{{\mathbf {y}}_{k}}]]></fr:tex>
BFGS rank-2 update:
<fr:tex display="block"><![CDATA[{\mathbf {H}}_{k+1}\ =\ {\mathbf {H}}_{k}+{\frac {\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}+{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}{\mathbf {y}}_{k}\right ){\mathbf {s}}_{k}{\mathbf {s}}_{k}^{\top }}{\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}\right )^{2}}}-{\frac {{\mathbf {H}}_{k}{\mathbf {y}}_{k}{\mathbf {s}}_{k}^{\top }+{\mathbf {s}}_{k}{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}}{{\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}}}]]></fr:tex></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DERB/</fr:uri><fr:display-uri>DERB</fr:display-uri><fr:route>/DERB/</fr:route><fr:title text="Optimization on the Riemmanian Manifold">Optimization on the Riemmanian Manifold</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0073/</fr:uri><fr:display-uri>0073</fr:display-uri><fr:route>/0073/</fr:route><fr:title text="Smooth Manifold">Smooth Manifold</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say <fr:tex display="inline"><![CDATA[ \mathcal {M}\subseteq \mathbb {R}^{n} ]]></fr:tex> is an embedded smooth submanifold of codimension <fr:tex display="inline"><![CDATA[ k ]]></fr:tex> if there exists a <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth function</fr:link> <fr:tex display="inline"><![CDATA[ g:\mathbb {R}^{n}\mapsto \mathbb {R}^{k} ]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[ \mathcal {M}\equiv \left \{\boldsymbol {x}\in \mathbb {R}^{n}\mid  g(\boldsymbol {x})=\boldsymbol {0}\right \}, ]]></fr:tex>

<fr:tex display="block"><![CDATA[ \mathrm {D}g(\boldsymbol {x}):\mathbb {R}^{n}\mapsto \mathbb {R}^{k}\text { has rank }k,\ \forall \boldsymbol {x}\in \mathcal {M}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0072/</fr:uri><fr:display-uri>0072</fr:display-uri><fr:route>/0072/</fr:route><fr:title text="Riemannian Manifold">Riemannian Manifold</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A Riemannian manifold <fr:tex display="inline"><![CDATA[ (\mathcal {M},\langle \cdot ,\cdot \rangle ) ]]></fr:tex> is a <fr:link href="/0073/" title="Smooth Manifold" uri="https://kellenkanarios.com/0073/" display-uri="0073" type="local">smooth manifold</fr:link>
<fr:tex display="inline"><![CDATA[ \mathcal {M} ]]></fr:tex> equipped with positive-definite inner product <fr:tex display="inline"><![CDATA[ \langle \cdot ,\cdot \rangle  ]]></fr:tex> on the tangent space <fr:tex display="inline"><![CDATA[ \mathrm {T}_{\pmb {x}}\mathcal {M} ]]></fr:tex> at each point <fr:tex display="inline"><![CDATA[ \pmb {x}\in \mathcal {M} ]]></fr:tex>. 
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0075/</fr:uri><fr:display-uri>0075</fr:display-uri><fr:route>/0075/</fr:route><fr:title text="Tangent Space">Tangent Space</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The tangent space <fr:tex display="inline"><![CDATA[ \mathrm {T}_{\pmb {x}}\mathcal {M} ]]></fr:tex> at a point <fr:tex display="inline"><![CDATA[ \pmb {x}\in \mathcal {M} ]]></fr:tex> is defined as
<fr:tex display="block"><![CDATA[T_x \mathcal {M} = \ker  Dg(\mathbf {x})]]></fr:tex>
which is a linear subspace of <fr:tex display="inline"><![CDATA[ \mathbb {R}^{n} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0074/</fr:uri><fr:display-uri>0074</fr:display-uri><fr:route>/0074/</fr:route><fr:title text="Tangent Bundle">Tangent Bundle</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The tangent bundle of <fr:tex display="inline"><![CDATA[ {\cal  M} ]]></fr:tex> is the disjoint union of all <fr:link href="/0075/" title="Tangent Space" uri="https://kellenkanarios.com/0075/" display-uri="0075" type="local">tangent spaces</fr:link>:
<fr:tex display="block"><![CDATA[ {\rm  T}{\cal  M}\ =\ \{(\mathbf {x},\mathbf {v})\ \mid \ \mathbf {x}\in {\cal  M},\ {\rm  and}\ \mathbf {v}\in {\rm  T}_{\mathbf {x}}{\cal  M}\} ]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0076/</fr:uri><fr:display-uri>0076</fr:display-uri><fr:route>/0076/</fr:route><fr:title text="Retraction">Retraction</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A retraction is a <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth map</fr:link> <fr:tex display="inline"><![CDATA[ R:\mathrm {T}\mathcal {M}\mapsto \mathcal {M} ]]></fr:tex> such that if <fr:tex display="inline"><![CDATA[ h(t)=R(\mathbf {x},t\mathbf {v})=R_{\mathbf {x}}(t\mathbf {v}) ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[ h(0)=\mathbf {x} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ h^{\prime }(0)=\mathbf {v} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0079/</fr:uri><fr:display-uri>0079</fr:display-uri><fr:route>/0079/</fr:route><fr:title text="Riemannian Metric">Riemannian Metric</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A choice of inner product <fr:tex display="inline"><![CDATA[\langle  \cdot , \cdot  \rangle _x]]></fr:tex> for each tangent space <fr:tex display="inline"><![CDATA[\mathrm {T}_x \mathcal {M}]]></fr:tex> defines a Riemannian metric on <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0078/</fr:uri><fr:display-uri>0078</fr:display-uri><fr:route>/0078/</fr:route><fr:title text="Riemmanian Metric">Riemmanian Metric</fr:title><fr:taxon>Claim</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[ \langle \cdot ,\cdot \rangle _{\textbf {x}} ]]></fr:tex> defines a <fr:link href="/0078/" title="Riemmanian Metric" uri="https://kellenkanarios.com/0078/" display-uri="0078" type="local">Riemmanian Metric</fr:link> on <fr:tex display="inline"><![CDATA[ \mathcal {M} ]]></fr:tex> if for any two smooth vector fields <fr:tex display="inline"><![CDATA[\mathbf {V}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbf {W}]]></fr:tex>, the function <fr:tex display="inline"><![CDATA[ \textbf {x}\mapsto \left \langle \mathbf {V}(\textbf {x}),\mathbf {W}(\textbf {x})\right \rangle _{\textbf {x}} ]]></fr:tex> is smooth.
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0077/</fr:uri><fr:display-uri>0077</fr:display-uri><fr:route>/0077/</fr:route><fr:title text="Riemannian Gradient">Riemannian Gradient</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ f:\mathcal {M}\mapsto \mathbb {R} ]]></fr:tex> be <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth</fr:link> on the <fr:link href="/0072/" title="Riemannian Manifold" uri="https://kellenkanarios.com/0072/" display-uri="0072" type="local">Riemannian manifold</fr:link> <fr:tex display="inline"><![CDATA[ \mathcal {M} ]]></fr:tex>. The Riemannian gradient <fr:tex display="inline"><![CDATA[ \,\operatorname {grad}f(\boldsymbol {x})\, ]]></fr:tex> of <fr:tex display="inline"><![CDATA[ f ]]></fr:tex> at <fr:tex display="inline"><![CDATA[ \boldsymbol {x}\in \mathcal {M} ]]></fr:tex> is the unique tangent vector at <fr:tex display="inline"><![CDATA[ \boldsymbol {x} ]]></fr:tex> such that

<fr:tex display="block"><![CDATA[ \mathrm {D}f(\boldsymbol {x})[\boldsymbol {v}]\ =\ \langle \operatorname {grad}f(\boldsymbol {x}),\boldsymbol {v}\rangle _{\boldsymbol {x}}\,,\quad \forall \,\boldsymbol {v}\in \mathrm {T}_{\boldsymbol {x}}\mathcal {M}. ]]></fr:tex>
By extending the definition of <fr:tex display="inline"><![CDATA[ f ]]></fr:tex> to the ambient Euclidean space <fr:tex display="inline"><![CDATA[ \mathbb {R}^{n} ]]></fr:tex>, we can show that

<fr:tex display="block"><![CDATA[\mathrm {grad} f(\mathbf {x}) = \mathcal {P}_{T_x \mathcal {M}}(\nabla  f(\mathbf {x}))]]></fr:tex>
where <fr:tex display="inline"><![CDATA[  {\mathcal {P}}_{\mathrm {T}_{\mathbf {x}}\mathcal {M}}]]></fr:tex> is the orthogonal projector from <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex> to <fr:tex display="inline"><![CDATA[T_x \mathcal {M}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007A/</fr:uri><fr:display-uri>007A</fr:display-uri><fr:route>/007A/</fr:route><fr:title text="Riemannian Hessian">Riemannian Hessian</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ f:{\cal  M}\mapsto \mathbb {R} ]]></fr:tex> be <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth</fr:link> on the <fr:link href="/0072/" title="Riemannian Manifold" uri="https://kellenkanarios.com/0072/" display-uri="0072" type="local">Riemannian Manifold</fr:link> <fr:tex display="inline"><![CDATA[ {\cal  M} ]]></fr:tex>. The Riemannian Hessian <fr:tex display="inline"><![CDATA[ {\rm  Hess}\,f(\mathbf {x}):{\rm  T}_{\mathbf {x}}{\cal  M}\mapsto {\rm  T}_{\mathbf {x}}{\cal  M} ]]></fr:tex> of <fr:tex display="inline"><![CDATA[ f ]]></fr:tex> at <fr:tex display="inline"><![CDATA[ \mathbf {x}\in {\cal  M} ]]></fr:tex> is a mapping from <fr:tex display="inline"><![CDATA[ {\rm  T}_{\mathbf {x}}{\cal  M} ]]></fr:tex> to <fr:tex display="inline"><![CDATA[ {\rm  T}_{\mathbf {x}}{\cal  M} ]]></fr:tex> with

<fr:tex display="block"><![CDATA[ {\rm  Hess}\,f(\mathbf {x})[\mathbf {v}]\ :=\ \widetilde {\nabla }_{\mathbf {v}}\,{\rm  grad}\,f(\mathbf {x}). ]]></fr:tex>
<html:ul><html:li>Here, <fr:tex display="inline"><![CDATA[\tilde {\nabla }]]></fr:tex> is the Riemannian connection.</html:li>
  <html:li>
On a Riemannian submanifold embedded in <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex>
<fr:tex display="block"><![CDATA[\tilde {\nabla }_{\mathbf {u}} V = \mathcal {P}_{T_{\mathbf {x}} \mathcal {M}}(\mathrm {D}V(\mathbf {x})[\mathbf {u}])]]></fr:tex>
and
<fr:tex display="block"><![CDATA[\mathrm {Hess}\,f(\mathbf {x})[\mathbf {v}]\ =\ {\mathcal {P}}_{\mathrm {T}_{\mathbf {x}}{\mathcal {M}}}\,(\mathrm {D}\,\mathrm {grad}\,f(\mathbf {x})[\mathbf {v}])]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007B/</fr:uri><fr:display-uri>007B</fr:display-uri><fr:route>/007B/</fr:route><fr:title text="Riemannian Gradient Descent">Riemannian Gradient Descent</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For <fr:tex display="inline"><![CDATA[f : \mathcal {M} \mapsto  \mathbb {R}]]></fr:tex>,
<fr:tex display="block"><![CDATA[ x_{k+1}\ =\ R_{{\mathbf {x}}_{k}}(-\tau _{k}\operatorname {grad}f({\mathbf {x}}_{k})) ]]></fr:tex></html:p><html:p>
  Can do backtracking line search i.e.

<html:strong>while</html:strong> <fr:tex display="block"><![CDATA[f(R_{x_{k}}(-\tau \,{\rm  grad}\,f(\mathbf {x}_{k}))) > f(\mathbf {x}_{k}) - c_{1}\tau \, | |{\rm  grad}\,f(\mathbf {x}_{k})| |_{2}^{2} ]]></fr:tex> <html:strong>do</html:strong> <fr:tex display="block"><![CDATA[ \tau \ \leftarrow \ \alpha \cdot \tau  ]]></fr:tex></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
