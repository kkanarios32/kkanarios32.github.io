<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors />
    <fr:date>
      <fr:year>2024</fr:year>
      <fr:month>11</fr:month>
      <fr:day>25</fr:day>
    </fr:date>
    <fr:uri>https://kellenkanarios.com/0015/</fr:uri>
    <fr:display-uri>0015</fr:display-uri>
    <fr:route>/0015/</fr:route>
    <fr:title text="Notebooks">Notebooks</fr:title>
  </fr:frontmatter>
  <fr:mainmatter>
    <html:p>More formal notes that follow a textbook / curriculum.</html:p>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>7</fr:month>
          <fr:day>1</fr:day>
        </fr:date>
        <fr:uri>https://kellenkanarios.com/0084/</fr:uri>
        <fr:display-uri>0084</fr:display-uri>
        <fr:route>/0084/</fr:route>
        <fr:title text="Notebook: Three Easy Pieces">Notebook: <fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">Three Easy Pieces</fr:link></fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <html:p>Part of my <fr:link href="/004H/" title="The Computer in Computer Science" uri="https://kellenkanarios.com/004H/" display-uri="004H" type="local">revisiting CS fundamentals journey</fr:link></html:p>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:contributor>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:contributor>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>8</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/SE66/</fr:uri>
            <fr:display-uri>SE66</fr:display-uri>
            <fr:route>/SE66/</fr:route>
            <fr:title text="Processes">Processes</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>6</fr:month>
                  <fr:day>23</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/007V/</fr:uri>
                <fr:display-uri>007V</fr:display-uri>
                <fr:route>/007V/</fr:route>
                <fr:title text="TEE Processes Intro"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TEE</fr:link> Processes Intro</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (1/66)</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="The Abstraction">The Abstraction</fr:title></fr:frontmatter><fr:mainmatter>
<html:p><html:em>A process</html:em> consists of a few primary components
<html:ol><html:li><html:strong>Memory</html:strong>: each process requires its own portion of memory for (i) to store the instructions of the program to execute and (ii) for the memory required by the calling program. This is referred to as the <html:em>address space</html:em>.</html:li>
  <html:li><html:strong>Registers</html:strong>: for those familiar with computers, instructions typically deal with registers, where information is loaded from memory into registers to perform computation. Additionally, there are special registers reserved for certain mechanisms i.e.
  <html:ul><html:li><html:strong>Program Counter (PC)</html:strong>: This register is in charge of telling us what instruction we are currently on in the executing program.</html:li>
    <html:li><html:strong>Stack and Frame Pointer:</html:strong> Used to manage where we currently are on the stack.</html:li></html:ul></html:li></html:ol></html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Process API">Process API</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>In order to implement a process, one must support each of the following operations</html:p>
  <html:ol><html:li><html:strong>Create:</html:strong> <html:p>The operating system must implement a mechanism to create a process. This consists of loading the program from disk, initializing memory (i.e. stack and heap), and jumping to <html:code>main</html:code> (typically).</html:p></html:li>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The stack is allocated up front and does not change. However, typically a small amount of memory is allocated for the heap and it grows via <html:code>malloc</html:code>. This is non-trivial because if <html:code>malloc</html:code> is called without available heap memory then memory must be allocated by the OS. I need to look into <fr:link href="https://gee.cs.oswego.edu/dl/html/malloc.html" type="external">how</fr:link> this is done more.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  The OS will also initialize the parameters to <html:code>main</html:code> i.e. <html:code>argc</html:code> or <html:code>argv</html:code>.
</fr:mainmatter></fr:tree>

    <html:li><html:strong>Destroy:</html:strong> Clearly, if a process is misbehaved or the user just does not want it to run any longer, there must be some mechanism to <html:em>kill</html:em> the process.
      </html:li>
    <html:li><html:strong>Wait:</html:strong> In the case of dependencies (piping?), it may be useful to wait for a process to complete.
      </html:li>
    <html:li><html:strong>Miscellaneous Control:</html:strong> The example provided in the book is to <html:em>suspend</html:em> a process.
      </html:li>
    <html:li><html:strong>Status:</html:strong> It is helpful to be able to get information about running processes.
    </html:li></html:ol>
<html:p>There are also process <html:em>states</html:em>. These states are <html:strong>running</html:strong>, <html:strong>ready</html:strong>, and <html:strong>blocked</html:strong>. These states are pretty self-explanatory.
  </html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Data Structures">Data Structures</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>It seems throughout the book we will be seeing implementation examples from the smaller <fr:link href="https://github.com/mit-pdos/xv6-public" type="external">xv6</fr:link> OS.</html:p>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  In addition to the process implementation below, there is also a data structure that must keep track of all the processes. This is the <html:strong>process list</html:strong> or <html:strong>process control block</html:strong>.
  </fr:mainmatter></fr:tree>

<html:p><html:pre><![CDATA[// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
  char *mem; // Start of process memory
  uint sz; // Size of process memory
  char *kstack; // Bottom of kernel stack for this process
  enum proc_state state; // Process state
  int pid; // Process ID
  struct proc *parent; // Parent process
  void *chan; // If non-zero, sleeping on chan
  int killed; // If non-zero, have been killed
  struct file *ofile[NOFILE]; // Open files
  struct inode *cwd; // Current directory
  struct context context; // Switch here to run process
  struct trapframe *tf; // Trap frame for the current interrupt
};]]></html:pre></html:p>
</fr:mainmatter></fr:tree>

  

  <fr:tree show-metadata="false" expanded="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:title text="Homework">Homework</fr:title></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>Run <html:code>process.py</html:code> with the flags <html:code>-l 5:100, 5:100</html:code>. What should the CPU utilization be?
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>The flags correspond to running two processes each with <fr:tex display="inline"><![CDATA[5]]></fr:tex> instructions where each instruction has probability one of using the CPU. The output from the program is 
    <html:pre><![CDATA[  Process 0
    cpu
    cpu
    cpu
    cpu
    cpu

  Process 1
    cpu
    cpu
    cpu
    cpu
    cpu]]></html:pre>
    with this, we can conclude that the utilization is 100%. We will execute one instruction for the first process until it completes, then the five instructions of the next process. If both are waiting on IO, then I do not think this would be the case? 
    </fr:mainmatter></fr:tree>

    
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
    Using the solution flags <html:code>-cp</html:code>, there is 100% utilization. 
    </fr:mainmatter></fr:tree></html:li>
    <html:li>Run <html:code>process.py</html:code> with the flags <html:code>-l 4:100, 1:0</html:code>. How long does it take to complete both processes?
    
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>The flags correspond to running one process with <fr:tex display="inline"><![CDATA[4]]></fr:tex> instructions with each instruction having probability one of using the CPU and one process with one instruction that uses the IO. The output from the program is 
    <html:pre><![CDATA[Process 0
  cpu
  cpu
  cpu
  cpu

Process 1
  io
  io_done]]></html:pre>
It will take <fr:tex display="inline"><![CDATA[4 + \text {time of IO}]]></fr:tex>. Since the process with <fr:tex display="inline"><![CDATA[4]]></fr:tex> non-IO-dependent instructions will run each of those instructions and then the next process will begin which must wait for the entire duration of IO.
    </fr:mainmatter></fr:tree>

    
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>Using the <html:code>-cp</html:code> flags it takes <fr:tex display="inline"><![CDATA[11]]></fr:tex> timesteps to complete which is <fr:tex display="inline"><![CDATA[\approx  4 + \text {time of IO}]]></fr:tex>.
  </fr:mainmatter></fr:tree></html:li>
<html:li>
Now switch the order of the processes: <html:code>./process-run.py -l
1:0,4:100</html:code>. What happens now? Does switching the order mat-
ter? Why?
  
    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
The output of the code is
    <html:pre><![CDATA[Process 0
  io
  io_done

Process 1
  cpu
  cpu
  cpu
  cpu]]></html:pre>
    Depending on the time of IO (<html:code>the -L flag</html:code>), it should take <fr:tex display="inline"><![CDATA[\max (5, 1 + \text {time IO})]]></fr:tex>. Switching the order does matter because we can run the CPU instructions while waiting for non-blocking IO. This motivates the idea of scheduling.
  </fr:mainmatter></fr:tree>

  
 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
    It only takes <fr:tex display="inline"><![CDATA[7]]></fr:tex> timesteps because we are able to perform the IO operations off the CPU as expected.
  </fr:mainmatter></fr:tree></html:li>
  <html:li>
We’ll now explore some of the other flags. One important flag is <html:code>-S</html:code>, which determines how the system reacts when a process issues an I/O. With the flag set to <html:code>SWITCH_ON_END</html:code>, the system will NOT switch to another process while one is doing I/O, instead waiting until the process is completely finished. What happens when you run the following two processes, one doing I/O and the other doing CPU work? (<html:code>-l 1:0,4:100 -c -S SWITCH_ON_END</html:code>)

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The output of the code is:
<html:pre><![CDATA[Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1          
  2        BLOCKED         READY                           1
  3        BLOCKED         READY                           1
  4        BLOCKED         READY                           1
  5        BLOCKED         READY                           1
  6        BLOCKED         READY                           1
  7*   RUN:io_done         READY             1          
  8           DONE       RUN:cpu             1          
  9           DONE       RUN:cpu             1          
 10           DONE       RUN:cpu             1          
 11           DONE       RUN:cpu             1]]></html:pre>
As expected, it runs the IO process, blocking the CPU process until it is completed.
</fr:mainmatter></fr:tree></html:li>
    <html:li>Now, run the same processes, but with the switching behavior set
to switch to another process whenever one is <html:code>WAITING</html:code> for I/O (<html:code>-l 1:0,4:100 -c -S SWITCH ON IO</html:code>). What happens now? Use <html:code>-c</html:code>
and <html:code>-p</html:code> to confirm that you are right</html:li>

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  I assume that at timestep <fr:tex display="inline"><![CDATA[1]]></fr:tex> we will still <html:code>RUN:io</html:code>. However, we will then switch the <html:code>PID: 1</html:code> for the next <fr:tex display="inline"><![CDATA[4]]></fr:tex> timesteps until it is completed. After one additional <html:code>BLOCKED</html:code> timestep, we will run <html:code>RUN:io_done</html:code> and complete both processes. 
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The output of the code is:
  <html:pre><![CDATA[Time        PID: 0        PID: 1           CPU           IOs
  1         RUN:io         READY             1          
  2        BLOCKED       RUN:cpu             1             1
  3        BLOCKED       RUN:cpu             1             1
  4        BLOCKED       RUN:cpu             1             1
  5        BLOCKED       RUN:cpu             1             1
  6        BLOCKED          DONE                           1
  7*   RUN:io_done          DONE             1]]></html:pre>
</fr:mainmatter></fr:tree>
 

<html:li>
One other important behavior is what to do when an I/O completes. With -I IO RUN LATER, when an I/O completes, the process that issued it is not necessarily run right away; rather, whatever was running at the time keeps running. What happens when you run this combination of processes? (<html:code>./process-run.py -l 3:0,5:100,5:100,5:100 -S SWITCH ON IO -I IO RUN LATER -c -p</html:code>) Are system resources being effectively utilized?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The resources are not efficiently utilized because we end up waiting until all of our CPU-bound processes finish before returning to the IO-bound process, which calls another <html:code>IO:run</html:code> and we do not get any concurrency benefit.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The code output is pretty long but the end output is
  <html:pre><![CDATA[Stats: Total Time 31
Stats: CPU Busy 21 (67.74%)
Stats: IO Busy  15 (48.39%)]]></html:pre>
</fr:mainmatter></fr:tree></html:li>
<html:li>
Now run the same processes, but with <html:code>-I IO RUN IMMEDIATE</html:code> set, which immediately runs the process that issued the I/O. How does this behavior differ? Why might running a process that just completed an I/O again be a good idea?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  The behavior differs by returning to the IO-bound process, which can then immediately call the next <html:code>IO:run</html:code> before returning access to the CPU-bound processes, improving concurrency. In an attempt to predict the next IO call, it might be a good idea to run the process that just completed IO because it is more likely to make another IO call.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  The corresponding statistics are
  <html:pre><![CDATA[Stats: Total Time 21
Stats: CPU Busy 21 (100.00%)
Stats: IO Busy  15 (71.43%)]]></html:pre>
</fr:mainmatter></fr:tree></html:li>
<html:li>
Now run with some randomly generated processes, e.g., <html:code>-s 1 -l
3:50,3:50, -s 2 -l 3:50,3:50, -s 3 -l 3:50,3:50</html:code>. See
if you can predict how the trace will turn out. What happens when
you use <html:code>-I IO RUN IMMEDIATE</html:code> vs. <html:code>-I IO RUN LATER</html:code>? What hap-
pens when you use <html:code>-S SWITCH ON IO</html:code> vs. <html:code>-S SWITCH ON END</html:code>?

    <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  Since each instruction has a 50% chance of being CPU or I/O, I do not think there will be much benefit to <html:code>IO_RUN_LATER</html:code> vs. <html:code>IO_RUN_IMMEDIATE</html:code>. However, I believe it will be crucial to enable <html:code>-S SWITCH_ON_IO</html:code> over <html:code>-S SWITCH_ON_END</html:code> as the number of processes grow because we should always have waiting CPU instructions to run. In the case of two processes, we still may not improve that much because they will likely both be IO-bound at some point.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" expanded="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>6</fr:month><fr:day>23</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  For <html:code>-s 1</html:code> (aka the seed), the observed performance between <html:code>IO_RUN_IMMEDIATE</html:code> and <html:code>IO_RUN_LATER</html:code> is the same. However, we do observe an improvement on both IO and CPU usage when we enable <html:code>SWITCH_ON_IO</html:code>.
</fr:mainmatter></fr:tree></html:li></html:ol>
  </fr:mainmatter></fr:tree>

</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>1</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/007Y/</fr:uri>
                <fr:display-uri>007Y</fr:display-uri>
                <fr:route>/007Y/</fr:route>
                <fr:title text="TPE Process Interlude"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Process Interlude</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (3/66)</html:p><html:p>This was a very short chapter just introducing the actual API for some very important system calls. Namely</html:p>
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="fork()"><html:code>fork()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
The <html:em>fork</html:em> system call allows a program to duplicate itself in a new process from the current instruction. This is quite literally a duplication which entails giving the child its own
<html:ol><html:li>Address space</html:li>
  <html:li>Registers</html:li>
  <html:li>Program counter</html:li></html:ol></html:p>
<html:p>
A fork is invoked in the parent process like
  <html:pre><![CDATA[  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
    else
      printf("in parent");]]></html:pre></html:p>
<html:p>
Importantly, you identify whether you are in the child or the parent via the return value of <html:code>rc</html:code> (0 for child), (PID of child for parent).
</html:p>

    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Which process is run first (the parent or the child) is non-deterministic and depends on the CPU scheduling algorithm.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="wait()"><html:code>wait()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
  Due to the remark, we need some way to enforce ordering among parent and child. This is the motivation for the <html:em>wait</html:em> system call. Namely, when the parent calls <html:code>wait()</html:code> it tells the CPU not to schedule it until the child completes. 
  </html:p>
  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
    From the previous <fr:link href="/007V/" title="TEE Processes Intro" uri="https://kellenkanarios.com/007V/" display-uri="007V" type="local">section</fr:link>, we saw the data structure for a process included the state. I assume <html:code>wait()</html:code> is implemented by adjusting the process state in the PCB somehow?
  </fr:mainmatter></fr:tree>

  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Doing a bit more research, it seems this is on the right track. Additionally, when a child completes it enters the <html:code>ZOMBIE</html:code> state, where it stores all the relevant information of the process, so that the parent process can then use this information. How this is actually coordinated seems to involve <html:em>signals</html:em> and <html:em>wait_entries</html:em> that essentially track all the children of a parent. The OS can then get a signal of completion from a child and find the corresponding parent?
  </fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="exec()"><html:code>exec()</html:code></fr:title></fr:frontmatter><fr:mainmatter>
<html:p>While <html:code>fork()</html:code> is useful in the sense that it allows us to spawn new processes from a parent process, it is still limited in that it can only execute instructions following the line of the <html:code>fork()</html:code> call in the parent process.</html:p>
<html:p>In practice, we do not want to have to compile massive C projects that contain all the necessary files for every possible binary we may want to run. To get around this, we can use the <html:code>exec()</html:code> system call. <html:code>exec()</html:code> allows us to transform a process into the desired executable. What this entails:
<html:ol><html:li>Loading the code and static data for the executable and overwriting the current coad and static data.</html:li>
  <html:li>Re-initializing stack and heap memory.</html:li>
  <html:li>Running the program, where the arguments passed to <html:code>exec()</html:code> are treated as <html:code>argv</html:code> for the program.</html:li></html:ol>
For a parent process to invoke <html:code>ls</html:code>, they could do something like
  <html:pre><![CDATA[  int main()
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      printf("in child");
      exec(ls);
    else
      printf("in parent");]]></html:pre>
  This spawns a child process and overwrites it with the <html:code>ls</html:code> executable.
</html:p>
</fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
Combining <html:code>fork()</html:code> and <html:code>exec()</html:code> is where the true power lies. In particular, with this combination you can practically implement an entire shell. Below is some (hybrid) pseudocode.
<html:pre><![CDATA[int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      exec(command);
    else
      int rc = wait(NULL);
  }]]></html:pre>
You can also implement redirection by opening a file prior to calling <html:code>exec()</html:code> i.e.
<html:pre><![CDATA[int main()
  while (true) {
    command = getcommand();
    int rc = fork();
    if (rc < 0) 
      printf("error with fork");
    else if (rc == 0)
      close(STD_OUT_FILENO);
      open(output.txt);
      exec(command);
    else
      int rc = wait(NULL);
  }]]></html:pre>
</fr:mainmatter></fr:tree>
 

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Signals">Signals</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>They briefly mention <html:em>signals</html:em>: what I expect to be an important topic in the future. Namely, you can send a signall to a process via <html:code>kill()</html:code> and the recipient program can "catch" this signal via the system call <html:code>signal()</html:code>.
</html:p>
<html:p>This naturally leads to the introduction of a <html:em>user</html:em>. The <html:em>user</html:em> determines which processes they are allowed to signal, where the <html:em>superuser</html:em> can arbitrarily signal all processes.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Coding Homework">Coding Homework</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (6/66).</html:p>
  <html:ol><html:li>Write a program that calls <html:code>fork()</html:code>. Before calling <html:code>fork()</html:code>, have the main process access a variable (e.g., <html:code>x</html:code>) and set its value to something (e.g., 100). What value is the variable in the child process? What happens to the variable when both the child and parent change the value of <html:code>x</html:code></html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Both the parent and the child get a copy of the variable values i.e. <fr:tex display="inline"><![CDATA[x]]></fr:tex>. When they modify <fr:tex display="inline"><![CDATA[x]]></fr:tex> it only affects the copy of <fr:tex display="inline"><![CDATA[x]]></fr:tex> in their local address space.
    </fr:mainmatter></fr:tree>

    <html:li>
Write a program that opens a file (with the <html:code>open()</html:code> system call) and then calls <html:code>fork()</html:code> to create a new process. Can both the child and parent access the file descriptor returned by <html:code>open()</html:code>? What happens when they are writing to the file concurrently, i.e., at the same time?
      </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Both do have access to the same file descriptor. I believe that they can interleave writes if writing at the same time but for me whichever process got ran first always finished writing prior the other starting. This may be a scheduling thing, where one process is able to complete before the other is scheduled?
    </fr:mainmatter></fr:tree>

    <html:li>
Write another program using <html:code>fork()</html:code>. The child process should
print “hello”; the parent process should print “goodbye”. You should
try to ensure that the child process always prints first; can you do
this without calling <html:code>wait()</html:code> in the parent?
    </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Using the previous problem, in the child, we can write something to a file. Then, in the parent, we can enforce an ordering by making the parent wait in a <html:code>while</html:code> loop until it reads the value written by the child. However, this is terribly inconvenient (and probably why <html:code>wait()</html:code> exists).
    </fr:mainmatter></fr:tree>

    <html:li>
Now write a program that uses <html:code>wait()</html:code> to wait for the child process to finish in the parent. What does <html:code>wait()</html:code> return? What happens if you use <html:code>wait()</html:code> in the child?
      </html:li>
      
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
        <html:code>wait()</html:code> returns the pid of the child process that died. Using <html:code>wait()</html:code> in the child just immediately returns <fr:tex display="inline"><![CDATA[-1]]></fr:tex>.
      </fr:mainmatter></fr:tree>

      <html:li>
Write a program that calls <html:code>fork()</html:code> and then calls some form of <html:code>exec()</html:code> to run the program <html:code>/bin/ls</html:code>. See if you can try all of the variants of <html:code>exec()</html:code>, including <html:code>execl()</html:code>, <html:code>execle()</html:code>, <html:code>execlp()</html:code>, <html:code>execv()</html:code>, <html:code>execvp()</html:code>, and <html:code>execvP()</html:code>. Why do you think there are so many variants of the same basic call?
        </html:li>
        
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
          It seems that some of them support different types of arguments i.e. <html:code>execv</html:code> family allows variable size argument list. Additionally, there is a distinction in the <html:em>environment</html:em>. This seems to be a list of environment variable values that <html:code>exec{l,v}e()</html:code> will search over. The <fr:tex display="inline"><![CDATA[p]]></fr:tex> family use the same search as the shell i.e. the <html:code>PATH</html:code>.
        </fr:mainmatter></fr:tree>

    <html:li>
Write a slight modification of the previous program, this time us- ing <html:code>waitpid()</html:code> instead of <html:code>wait()</html:code>. When would <html:code>waitpid()</html:code> be useful?
    </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      If a parent process has multiple children, then <html:code>wait()</html:code> will only wait until the first one dies. <html:code>waitpid()</html:code> lets you specify waiting on a specific child process.
    </fr:mainmatter></fr:tree>

    <html:li> Write a program that creates a child process, and then in the child closes standard output (<html:code>STDOUT_FILENO</html:code>). What happens if the child calls <html:code>printf()</html:code> to print some output after closing the descriptor? </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      Nothing prints in the child process. However, stdout is still open in the parent process and able to print.
    </fr:mainmatter></fr:tree>

    <html:li>
Write a program that creates two children, and connects the standard output of one to the standard input of the other, using the <html:code>pipe()</html:code> system call
      </html:li>
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
      This required <html:code>fflush()</html:code> for me. I am not sure if this is true in general?
    </fr:mainmatter></fr:tree></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>19</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/VE8C/</fr:uri>
                <fr:display-uri>VE8C</fr:display-uri>
                <fr:route>/VE8C/</fr:route>
                <fr:title text="TPE Limited Direct Execution"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Limited Direct Execution</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p><fr:link href="/007U/" title="Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local">Deliberate-Practice</fr:link> (7/66)</html:p><html:p>The contents of this chapter were revolved around two fundamental questions:</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:ol><html:li><html:em>How do we make sure a program doesn't do what we don't want it to do?</html:em></html:li>
    <html:li><html:em>How do we enable timesharing?</html:em></html:li></html:ol>
</html:div>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="modes">modes</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>For the first question, we introduce two modes <html:em>user mode</html:em> and <html:em>kernel mode</html:em>. In <html:em>user mode</html:em>, we are restricted with what sort of operations we can run.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
More importantly, in user mode, we are limited with what we can <html:em>see</html:em>. We will see later on in memory, but in user mode we have a limited address space allocated for the current process. However, in kernel mode, the address space is the entire computer and can therefore be very dangerous if we are not careful.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  How do we switch from user and kernel mode without allowing processes to run instructions in kernel mode?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  We must have some cooperation from the hardware. Namely, on boot, the OS code is run and sets up a <html:em>trap table</html:em>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="trapping">trapping</fr:title></fr:frontmatter><fr:mainmatter>
The hardware has some responsibility when switching to kernel mode. Namely, it must store two types of registers (1) user registers (2) kernel register.
<html:ol><html:li>The user registers are registers that contain the current program context i.e. stack variables, such as <html:code>x = 1</html:code>.</html:li>
  <html:li>The kernel registers hold more meta-information, such as the PC, the syscall number of the calling syscall, etc.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Each time we return to a process or switch between processes the hardware must perform a <html:em>context switch</html:em>. This is when they store all of the context of the current program before replacing it with the context of another program. The cost of such a switch is the tradeoff when performing <html:em>scheduling</html:em> of processes.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="syscall implementation">syscall implementation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
In order to implement the syscall, there needs to be some pre-agreed upon arrangement on where certain things go. For example, the syscall number must be stored in a pre-defined register. The general procedure (I think?) is as follows:
  </html:p>
<html:ol><html:li>syscall calls trap instruction defined by hardware.</html:li>
  <html:li>hardware stores all information necessary to restore processes in pre-determined location.</html:li>
  <html:li>hardware switches to kernel mode from user mode.</html:li>
  <html:li>hardware jumps to code in OS to handle syscall (trap handler / interrupt handler?).</html:li>
  <html:li>OS code checks pre-arranged register for the syscall number</html:li>
  <html:li>OS executes corresponding syscall code.</html:li>
  <html:li>OS restores program.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Due to relying on pre-determined registers, the syscalls are typically hand coded in assembly.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The OS must also perform checks regarding the safety of the requested operation i.e. we cannot let a process read the kernel code...
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is a similar mechanism for interrupts via an interrupt handler.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="timesharing">timesharing</fr:title></fr:frontmatter><fr:mainmatter>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  If the CPU is running a process, then how can the kernel decide to stop running it?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
It can't... Instead the hardware performs period interrupts that trap to the OS code. The OS code can then decide what process to run via the <html:em>scheduler</html:em> (next section).
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>19</fr:day></fr:date><fr:title text="booting up">booting up</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>This section is a summary of my findings:</html:p>
<html:ol><html:li>Power signals reset of CPU state.</html:li>
  <html:li>CPU runs BIOS, which checks that hardware works.</html:li>
  <html:li>BIOS then runs bootloader (i.e. grub).</html:li>
  <html:li>Bootloader places kernel code in right place and runs it.</html:li>
  <html:li>Kernel then specifies things like trap table location (which is a special hardware instruction). Also must set timer.</html:li></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/B8GC/</fr:uri>
                <fr:display-uri>B8GC</fr:display-uri>
                <fr:route>/B8GC/</fr:route>
                <fr:title text="TPE Scheduling"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Scheduling</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Toward the end of the previous section we alluded to the ominuous entity known as the <html:em>scheduler</html:em>. There is only one question that needs answering</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How should we pick what process to run at any given time?</html:em>
</html:div>
<html:p>It turns out there is no right answer to this question (at least that is my takeaway from these three sections in the book). The reason for this is the conflicting priorities of various metrics. Namely,
<html:ol><html:li><html:strong>turnaround time:</html:strong> the time to complete a process i.e.
  <fr:tex display="block"><![CDATA[T_{\text {completion}} - T_{\text {arrival}}]]></fr:tex>
  <html:li><html:strong>fairness:</html:strong> this is computed according to some arbitrary index. However, the main idea is that worst case jobs should not be neglected</html:li>
  <html:li><html:strong>response time:</html:strong> how long it takes from issuing the command to it being scheduled.</html:li></html:li></html:ol></html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Naive First Attempts">Naive First Attempts</fr:title></fr:frontmatter><fr:mainmatter>
<html:p><html:strong>FIFO:</html:strong> A naive and fair scheduler is to just serve each job in a <html:em>first-in-first-out</html:em> manner. However this suffers from the <html:em>convoy effect</html:em>. Namely, if we consider the case where the first job is very long. Then subsequent much shorter jobs will have much longer service times than they should.</html:p>

<html:p><html:strong>SJF:</html:strong> To counteract this, we can try the <html:em>shortest job first</html:em>. If all jobs arrive at the same time, then SJF actually provably minimizes turnaround time. However, all jobs do not arrive at the same time and if the same problematic sequence for FIFO arrives sequentially it will also break SJF.</html:p>
<html:p><html:strong>STCF:</html:strong> Up to this point, we have assumed that all jobs must be run to completion. However, we can relax this assumption and allow the OS to <html:em>preempt</html:em> a job (pausing it and starting a new job). With this, we introduce <html:em>shortest to completion first</html:em>, where we periodically preempt the current running job and then schedule the job with the shortest amount of time remaining until completion.</html:p>
<html:p><html:strong>RR:</html:strong> While the previous algorithm is optimal with respect to turnaround time, it is not very good with respect to response time. In particular, long jobs may not be serviced for a very long time. The best we can do with respect to response time is just <html:em>round robin</html:em>, where we periodically randomly switch between processes. The intervals between switching are referred to as <html:em>strides</html:em> or <html:em>time slices</html:em> or <html:em>quantum lengths</html:em>.</html:p>
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Each time we switch between processes, we incur the cost of a context switch. Choosing larger time slices allows us to <html:em>amortize</html:em> this cost.
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Prior to this, we had been ignoring I/O of the processes. A very simple way to not suffer substantial performance loss due to I/O is to simply divide the process up into its non I/O components and schedule them individually.
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Partial Homework Solutions">Partial Homework Solutions</fr:title></fr:frontmatter><fr:mainmatter>
<html:ol><html:li>For what types of workloads does SJF deliver the same turnaround as FIFO?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  For workloads that arrive in increasing order of total job time.
  </fr:mainmatter></fr:tree>

  <html:li>For what types of workloads and quantum lengths does SJF deliver the same response times as RR?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
  For shorter jobs and longer quantum lengths, RR and SJF should deliver similar response times.
  </fr:mainmatter></fr:tree>

  <html:li>What happens to response time with SJF as job lengths increase?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Response time degrades because the longest jobs have to wait for each of the shorter jobs to finish. If these shorter jobs become longer than the response time grows linearly(?).
  </fr:mainmatter></fr:tree>

  <html:li>What happens to response time with RR as quantum lengths increase? Can you write an equation that gives the worst-case response time, given <fr:tex display="inline"><![CDATA[N]]></fr:tex> jobs?</html:li>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    The response time is the average over stride length number of preceding jobs. The formula can be written as
    <fr:tex display="block"><![CDATA[\mathrm {RT} = \frac {1}{N} \sum _{i = 1}^{N} (i - 1)S = \frac {S(N - 1) N}{N} = S(N - 1)]]></fr:tex>
  </fr:mainmatter></fr:tree></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>26</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/HN3M/</fr:uri>
                <fr:display-uri>HN3M</fr:display-uri>
                <fr:route>/HN3M/</fr:route>
                <fr:title text="TPE Scheduling cont."><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TPE</fr:link> Scheduling cont.</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>In the previous section, we discussed algorithms that minimize turnaround time OR response time. Here, we will look at how to find a happy middle ground</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Multi-Level Feedback Queue">Multi-Level Feedback Queue</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The main idea is to maintain multiple queues with varying levels of priority. Each queue will then be scheduled round-robin within priority groups and lower priorities will not be scheduled until all processes of higher priority are completed. This introduces a few problems that we must remedy</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we assign priorities?</html:em>
</html:div>

<html:p>One approach is the idea of <html:em>allotment</html:em>. Essentially, each process is given an alloted amount of time at each priority. Once the process has run for the alloted amount of time at a given priority it moves down to the next priority.
</html:p>
<html:p>
Clearly, this achieves a good response time because it essentially reduces to round robin. This also does not tank performance because, if we recall that STCF is the optimal algorithm for turnaround time, we see that short jobs will still finish relatively quickly because they will spend all of their time at high priority (assuming a high enough allotment).</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We also saw in the previous section that one way to handle I/O is by breaking it into multiple jobs. However, this can result in gaming an allotment scheduler by I/O-ing right before you reach allotment essentially ensuring your process always remains the highest priority. To deal with this, we can count the total time spent by each of the jobs toward the allotment.
</fr:mainmatter></fr:tree>


 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we prevent starvation of lower priority queues?</html:em>
</html:div>

<html:p>It seems the easiest way for this is to just periodically move all processes back to the highest priority.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Proportional Share">Proportional Share</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The key idea here is rather than maintain queues of priorities we instead assign each job a certain <html:em>proportion</html:em> of the CPU time. The obvious question:</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>How do we ensure the jobs actually match the desired proportion?</html:em>
</html:div>

The first approach is the concept of <html:em>ticket currency</html:em>. The idea is to give each user a finite amount of tickets and have them allocate them amongs their processes. 

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
They also allow <html:em>ticket transfer</html:em> and <html:em>ticket inflation</html:em>, where a process can transfer tickets i.e. client / server, or temporarily increase their number of tickets.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The benefit of the <html:em>ticket currency</html:em> approach is the simplicity of the implementation. You simply draw a random number in the range of the total number of tickets and select the process with that number.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The natural question of how to actually assign tickets is very difficult and not solved.
</fr:mainmatter></fr:tree>

<html:p><html:strong>Deterministic version:</html:strong> The ambitious observer might wonder if there is a deterministic algorithm to achieve the same effect. Luckily, the answer is actually yes! Rather than randomly sample tickets, we set the <html:em>stride</html:em> to be inversely proportional to the ticket count. We then track the <html:em>pass</html:em> (a running sum for each process that is incremented by the processes stride). To formalize-ish,
<html:ol><html:li>Choose process with lowest <html:em>pass</html:em>.</html:li>
  <html:li>Increment the chosen process pass by the process stride.</html:li>
  <html:li>Repeat.</html:li></html:ol>
We see that a low stride (high ticket count) results in being scheduled more frequently.
</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is still an advantage of lottery-based scheduling: no global state. If new processes join, it is unclear what to set their initial pass at. 
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
On linux, the user can manually set priorities using <html:code>nice</html:code> and setting the <html:em>niceness</html:em> of a process in <![CDATA[[]]>-20, 20<![CDATA[)]]>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>8</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/TQSZ/</fr:uri>
            <fr:display-uri>TQSZ</fr:display-uri>
            <fr:route>/TQSZ/</fr:route>
            <fr:title text="TEP Memory"><fr:link href="/arpaci2018operating/" title="Operating Systems: Three Easy Pieces" uri="https://kellenkanarios.com/arpaci2018operating/" display-uri="arpaci2018operating" type="local">TEP</fr:link> Memory</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/SAYD/</fr:uri>
                <fr:display-uri>SAYD</fr:display-uri>
                <fr:route>/SAYD/</fr:route>
                <fr:title text="Memory Intro">Memory Intro</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>
We are now moving on from scheduling into the wonderful world of all things memory.
  </html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Address Spaces">Address Spaces</fr:title></fr:frontmatter><fr:mainmatter>
If we think about what we have done so far, we have an assortment of processes that are constantly being switched between. However, each of these process has their own assortment of register states, but more importantly they each have their own state in <html:em>memory</html:em>.
<html:ol><html:li>For register states, the OS has its own reserved memory, where it can easily store and switch between register states.</html:li>
  <html:li>For memory, when we switch processes, are we expected to clear out memory for the next process by storing to disk? <html:strong>NO!</html:strong></html:li></html:ol>
This motivates the idea behind <html:em>address spaces</html:em>. Namely, each process is given its own address space (chunk in memory) to use at its own discretion. This will then ensure that other processes do not overwrite the program state of one another. The address space of a process typically consists of three components
<html:ol><html:li>Code of the program</html:li>
  <html:li>Stack: local var, arguments, return values</html:li>
  <html:li>Heap: dynamically allocated memory</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
As we will see later, every address we see is actually <html:em>virtual</html:em>, meaning it is not the location in physical memory.
</fr:mainmatter></fr:tree>

<html:p><html:strong>API:</html:strong> We only really need two methods, a way to get memory and a way to release memory. These are implemented via <html:code>malloc</html:code> and <html:code>free</html:code>. However, the use of these is usually accompanied with a handful of common errors:</html:p>
<html:ol><html:li>Forget to initialize mem.</html:li>
  <html:li>Forget to free mem.</html:li>
  <html:li>Freeing memory early: <html:em>dangling pointer</html:em>.</html:li>
  <html:li>Freeing the same memory twice: <html:em>double free</html:em>.</html:li>
  <html:li>Passing something not allocated earlier: <html:em>invalid free</html:em>.</html:li></html:ol>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
When a process dies, the OS reclaims all of that process memory. This means that as long as your program memory is bounded, leakage will not do any sort of catastrophic damage. However, it is still not good practice.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:code>malloc</html:code> and <html:code>free</html:code> are not syscalls. The heap is pre-allocated with some allotment of memory. If the program exceeds this memory then <html:code>malloc</html:code> will call a syscall <html:code>brk</html:code> / <html:code>sbrk</html:code> to increment / decrement heap mem pointer.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
You can actually initialize and use your own heap-like memory through <html:code>mmap</html:code>. This memory is not associated with any particular file and is an <html:em>anonymous</html:em> memory region within your program.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Address Translation">Address Translation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>The next question is once each program has their own address space, how do we unify the experience for the user.</html:p>
  <html:ol><html:li>We want every process to have the <html:em>illusion</html:em> that is starts at address <fr:tex display="inline"><![CDATA[0]]></fr:tex></html:li>
    <html:li>We want every process to have the <html:em>illusion</html:em> of a large address space.</html:li></html:ol>
  <html:p>However, we also do not want to give up the protection / speed of the address space abstraction. The overarching idea is <html:em>virualizing</html:em> the address space. This means that the address the user sees is not the true address in physical memory. How we achieve this will be a longstanding topic for the next few entries of these notes.</html:p>
  <html:p><html:strong>Base and Bounds:</html:strong> The first approach is <html:em>base and bounds</html:em>. For this approach, the hardware has a dedicated base and bound register to indicate where the address space for a given process begins and ends. It is the OSes job to ensure that these registers are filled with the correct values for the current process.
  <html:ul><html:li>The hardware must provide protected instructions to allow the OS to modify the base and bound registers.</html:li></html:ul></html:p>
  <html:p>An <html:em>address translation</html:em> is then performed by the hardware by adding the base to the virtual address and checking it remains within the bounds. This is done by the <html:em>memory management unit</html:em> (MMU). A common theme we will see is that hardware support is crucial to achieve good virtualization.</html:p>
  
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
    <html:strong>Problem:</html:strong> <html:em>to support a large addres space with base and bounds we suffer significant <html:em>internal fragmentation</html:em> i.e. in between the base and bound there is a lot of unused memory.</html:em>
  </html:div>

  <html:p>To better understand why fragmentation is such an issue: if we have 16kb total memory and each process requests 4kb but only uses 2kb, then we can only maintain 4 processes despite having the memory to service 8! To attempt to remedy this, we will introduce the idea of <html:em>segmentation</html:em>.</html:p> 
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Segmentation">Segmentation</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>Instead of pre-allocating the memory between the heap and stack, why don't we <html:em>allocate on demand</html:em>. To do so, we can treat the code, heap, and stack as their own <html:em>segments</html:em> with their own base and bound registers. An address could then be decomposed as 
<fr:tex display="block"><![CDATA[\underbrace {0 1}_{\text {segment}}\underbrace {0 1 \cdots  11}_{\text {offset}}]]></fr:tex>
This also enables an idea of <html:em>memory sharing</html:em>, where process can share a portion of memory (such as the code) to save memory on the system.
<html:ul><html:li>Need to add a protection bit to indicate whether a process can modify certain addrs.</html:li></html:ul></html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
This limits flexibility in the sense that we have no control over where the middle region was allocated and therefore we cannot grow beyond the initial bound.
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The hardware also has to support the stack growing backwards when it checks the bounds. To do so, it has to perform an additional check based on the segment number.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>29</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/67X5/</fr:uri>
                <fr:display-uri>67X5</fr:display-uri>
                <fr:route>/67X5/</fr:route>
                <fr:title text="Free-Space Management">Free-Space Management</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>We have been talking a lot about how to abstract physical address to provide ease of use for the programmer. However, we have yet to discuss how to actually allocate these physical addresses in the first place. When allocating memory, there are a few issues we need to be careful about
<html:ol><html:li><html:em>External fragmentation</html:em>: lots of small unallocated non-contiguous chunks of memory.</html:li>
  <html:li><html:em>Internal fragmentation</html:em>: allocated memory that is unused in the process it is allocated for.</html:li></html:ol>
To start, we make a few simplifying assumptions:
<html:ol><html:li>After memory has been allocated, it cannot be moved.</html:li>
  <html:li>The size of memory is fixed.</html:li>
  <html:li>The user does not specify the size in <html:code>free</html:code>.</html:li></html:ol>
First, we can quickly deal with the last problem by introducing a <html:em>header</html:em>. The OS stores additional metadata, such as the size of the allocated memory in a header directly preceding the returned pointer in memory.
<html:ul><html:li>If <html:code>int* x = malloc(sizeof(int))</html:code> then <html:code>header = (header_t)* x - 1</html:code>.</html:li>
  <html:li>OS needs to find memory for the requested memory + size of the header.</html:li></html:ul></html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Malloc Policies">Malloc Policies</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>The general allocation algorithm consists of maintaining some <html:em>free-list</html:em> that contains the address and length of free memory. An allocation is done by some policy over this list. When memory is re-claimed, the list is searched for adjacent memory and if it is found then it is <html:em>coalesced</html:em> into a larger chunk of free memory.</html:p>
<html:ol><html:li><html:em>Best fit</html:em>: find smallest chunk that is big enough</html:li>
  <html:ul><html:li>leaves lots of small chunks</html:li></html:ul>
  <html:li><html:em>Worst fit</html:em>: find largest chunk</html:li></html:ol>
Both of these require searching the entire list, so instead we can introduce some heuristics.
<html:ol><html:li><html:em>First fit</html:em>: find first block that can service.</html:li>
  <html:li><html:em>Next fit</html:em>: find first block that can service starting from the previous allocation.</html:li></html:ol>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Segregated Lists">Segregated Lists</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>Outside of the allocation policy, we can make data-structure level optimization. One such optimization is segmentation lists. The idea is to maintain different lists that correspond to different commonly allocated object types.</html:p>
  <html:ul><html:li>Grow list by requesting segments as multiple size of the objects.</html:li>
    <html:li>Can return to main list when no references.</html:li>
    <html:li>Can also leave objects pre-iitialized on list to eliminate calls to constructor / destructor.</html:li></html:ul>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>29</fr:day></fr:date><fr:title text="Buddy Allocation">Buddy Allocation</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>Assume memory is size <fr:tex display="inline"><![CDATA[2^n]]></fr:tex>. Search through memory to find smallest block that can service request.</html:p>
<html:figure><html:img width="50%" src="/bafkrmigwzou6llta75hya6llhd6ixa6gjzeoyjqecitht2op5xxutkjgnu.png" />
<html:figcaption>Memory <fr:tex display="inline"><![CDATA[2^n]]></fr:tex>.</html:figcaption></html:figure>
<html:p>When block is freed,
<html:ol><html:li>Check if the buddy is free.</html:li>
  <html:li>If the buddy is free.</html:li>
  <html:ul><html:li>Coalesce into larger block</html:li>
    <html:li>Repeat.</html:li></html:ul></html:ol>
Can easily check buddy because address differ by one bit at each level. Just modify the corresponding bit and check the free data structure (bitmap?) if the address is free. If it is then move up and check the next bit.
</html:p>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>31</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/SB61/</fr:uri>
                <fr:display-uri>SB61</fr:display-uri>
                <fr:route>/SB61/</fr:route>
                <fr:title text="Paging">Paging</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Previously, we have only dealt with memory allocations as variable sized chunks i.e. the amount of memory allocated can be anything. A simple idea to avoid the drastic fragmentation this can induce is to instead divide memory into fixed size chunks. This idea is called <html:em>paging</html:em>, where each chunk is a <html:em>page</html:em>.</html:p>
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:strong>Main question:</html:strong> <html:em>how do we virtualize memory with pages?</html:em>
</html:div>
<html:p><html:strong>Idea:</html:strong> we decompose the address into a <html:em>virtual page number</html:em> (VPN) and offset i.e. 
<fr:tex display="block"><![CDATA[\underbrace {01}_{\text {VPN}}\underbrace {110\cdots  01}_{\text {offset}}]]></fr:tex>
we then maintain a datastructure to map <fr:tex display="inline"><![CDATA[\text {VPN} \mapsto  \text {PPN}]]></fr:tex>, where the PPN is the <html:em>physical page number</html:em> (we divide both virtual and physical memory into pages). We call this data structure a <html:em>page table</html:em>.
</html:p><html:p><html:strong>Problem 1:</html:strong> The page table can get ridiculously large.</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
For now, we consider a linear page table (an array with entry for each VPN). If we support a 32 bit address space with 4kb pages and each entry in the page table is 4 bytes then this is <fr:tex display="inline"><![CDATA[2^{32} / 2^{12} * 4 = 2^{22}]]></fr:tex> bytes of memory for the page table!
</fr:mainmatter></fr:tree>
 
<html:p>Before, we relied on the MMU to translate between physical and virtual addresses via simple operations like base and bound. However, there is no way the MMU could support this many arbitrary translations. Therefore, the page table itself must be stored in physical memory.</html:p><html:p>In addition to the address translation, the page table also keeps track of the following bits:
<html:ol><html:li>
Valid bit: whether this particular VPN has memory allocated to it i.e. mem between stack / heap does not need to be allocated.
  </html:li>
  <html:li>
Protection bit: determines whether the calling program can read / write / execute.
  </html:li>
  <html:li>
Present bit: whether the page currently resides in physical memory.
  </html:li>
  <html:li>
Dirty bit: has the page been modified since being paged in.
  </html:li>
  <html:li>
Reference bit: has the page been accessed (used for eviction policy).
    </html:li></html:ol></html:p><html:p><html:strong>Problem 2:</html:strong> Every time we want to perform an address translation (very often) we must
<html:ol><html:li>Compute VPN from address</html:li>
  <html:li>Access page table entry in physical memory (slow)</html:li>
  <html:li>Compute address with offset + PPN.</html:li>
  <html:li>Access corresponding physical page in physical memory.</html:li></html:ol>
This is very slow!
</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:title text="TLB">TLB</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>Due to the previously discussed issues, we need a faster way of performing address translation to make paging a feasible option. A common theme: we will throw hardware at it</html:p>
<html:p>Specifically, we will add an additional cache known as the <html:em>translation lookaside buffer</html:em> that caches address translations. Generally, an address translation proceeds as:
<html:ol><html:li>Extract VPN</html:li>
  <html:li>Check if VPN in TLB</html:li>
  <html:li>If in TLB: get translation</html:li>
  <html:li>Otherwise: TLB miss -&gt; trap to OS (RISC)</html:li></html:ol></html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We have to be a little careful. The OS code itself is located in memory and is therefore subject to our paging system. We can imagine that on TLB miss the hardware tries to load the TLB miss handler code by checking the TLB, getting the translation, and loading the code. But what if the translation for the TLB miss handler is not in the TLB?!?! To not worry about these things the TLB miss handler gets a permanent spot in physical memory.
</fr:mainmatter></fr:tree>

<html:p>Formally, an entry in the TLB consists of 
<html:ol><html:li>VPN</html:li>
  <html:li>PPN</html:li>
  <html:li>Other bits</html:li>
  <html:ul><html:li>Valid bit: has valid translation (different from PTE valid bit) can be invalid on initialization, eviction, or context switch.</html:li>
    <html:li>Protection bit: whether the requested access can be performed.</html:li></html:ul></html:ol></html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Problem</fr:taxon></fr:frontmatter><fr:mainmatter>
  Each process has different address translations corresponding to the same VPN.
</fr:mainmatter></fr:tree>


 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  Keep additional <html:em>address space identifier</html:em> (ASID) in TLB entry. We also need an ASID register that we set at every process switch to identify the current running process.
</fr:mainmatter></fr:tree>
 

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:uri>https://kellenkanarios.com/P9UM/</fr:uri><fr:display-uri>P9UM</fr:display-uri><fr:route>/P9UM/</fr:route><fr:title text="Culler's Law">Culler's Law</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><html:em>"Ram is not always ram"</html:em>. Referring to the fact that a physical memory access takes a substantial different amount of time depending on whether it hit in the TLB.</html:p></fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
In a real software managed TLB, the TLB consisted of the following components:
<html:ol><html:li>Global bits for globally shared pages,</html:li>
  <html:li>8 bit ASID,</html:li>
  <html:li>Coherence bits for cache-coherence,</html:li>
  <html:li>32-64 TLB entries,</html:li>
  <html:li>A wired register to indicate how many slots to reserve in the TLB for things like TLB miss handler.</html:li></html:ol>
</fr:mainmatter></fr:tree>
 


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Another important tidbit: when using very fast caches, even an access to the TLB is a CPU bottleneck (accessing TLB is longer than accessing cache). To get around this, there are <html:em>virtually indexed caches</html:em> that circumvent the need for performing an address translation.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:title text="Smaller Tables">Smaller Tables</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>As previously discussed, as it currently stands, the page table takes up too much memory.</html:p>
<html:p><html:strong>Solution 1:</html:strong> Just use bigger pages! Unfortunately, this will suffer from severe internal fragmentation (processes not using their allocated memory) and so we would prefer to avoid this solution.</html:p>
<html:p><html:strong>Solution 2:</html:strong> Paging + segmentation. Instead of a page table for all of memory, keep 3 page tables: one for code, stack, and heap. This only partially resolves the problem.
<html:ol><html:li>Same problems as segmentation. Variable sized page tables will cause external fragmentation</html:li>
  <html:li>We can do better. Within each heap, there is still a (smaller) version of the same problem: a bunch of unused allocated PTEs.</html:li></html:ol></html:p>
<html:p><html:strong>Multi-level page tables:</html:strong> Finally, we have arrived to the idea of a multi-level page table. The idea can be summarized as</html:p>
<html:ol><html:li>Chop page table up into pages.</html:li>
  <html:li>Do not allocated pages with no valid references (i.e. none of the corresponding are being used).</html:li></html:ol>
<html:figure><html:img width="80%" src="/bafkrmihf7gcws2u2ay4ecuwqwpgnziozltgjbsn7zo6x5bs6ismwq76jby.png" /></html:figure>
<html:p>This has a few advantages:</html:p>
<html:ol><html:li>Fits easily in memory. Allocate one page when an entry is used.</html:li> 
 <html:li>Proportional to the amount of address space actually in use.</html:li></html:ol>
<html:p>The obvious downside is the added complexity. Namely, on every TLB miss we must make two loads of memory (1) the page directory entry and (2) the page table entry.</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:title text="What happens when memory is full?">What happens when memory is full?</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>We reserve space on disk for pages that cannot fit in physical memory. This is referred to as <html:em>swap space</html:em>.</html:p>
<html:p>We need to add an additional <html:em>present bit</html:em> to the PTE. On a TLB miss, the hardware (or software) will check the page table and see the present bit to indicate whether the page is in physical memory. If not, we must trap to the OS and this is known as a <html:em>page fault</html:em>.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>31</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The hardware <html:strong>never</html:strong> handles page faults because this would require understanding swap space + knowing how to perform I/O with disk.
</fr:mainmatter></fr:tree>

<html:p>Three important cases to consider:</html:p>
<html:ol><html:li>Page is <html:strong>present</html:strong> and <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Hardware can just grab physical address from PTE.</html:li></html:ul>
  <html:li>Page is not <html:strong>present</html:strong> but <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Hardware must call page fault handler to retrieve page.</html:li></html:ul>
  <html:li>Page is not <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Throw exception and likely terminate process as it is accessing invalid memory.</html:li></html:ul></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>8</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/HK73/</fr:uri>
                <fr:display-uri>HK73</fr:display-uri>
                <fr:route>/HK73/</fr:route>
                <fr:title text="Beyond Physical Memory">Beyond Physical Memory</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>
Up to this point, we have reduced our focus to assuming physical memory was sufficiently large memory. In practice, this is rarely the case. To complete our discussion on memory, we must lift this assumption.
  </html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:title text="Mechanisms">Mechanisms</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>In order to handle overflowing memory, we must reserve some space on physical disk to store the additional pages. This space is referred to as <html:em>swap space</html:em>.
</html:p>
<html:p>
To keep track of such memory, the page table entry instead contains a <html:em>disk address</html:em>. The OS knows what to do because of the additional present bit indicating whether the page is in physical memory. If not, we must trap to the OS and this is known as a <html:em>page fault</html:em>.</html:p>
</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The hardware <html:strong>never</html:strong> handles page faults because this would require understanding swap space + knowing how to perform I/O with disk.
</fr:mainmatter></fr:tree>
<html:p>Three important cases to consider:</html:p><html:ol><html:li>Page is <html:strong>present</html:strong> and <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Hardware can just grab physical address from PTE.</html:li></html:ul>
  <html:li>Page is not <html:strong>present</html:strong> but <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Hardware must call page fault handler to retrieve page.</html:li></html:ul>
  <html:li>Page is not <html:strong>valid</html:strong>.</html:li>
  <html:ul><html:li>Throw exception and likely terminate process as it is accessing invalid memory.</html:li></html:ul></html:ol>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:title text="Policies">Policies</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>Now that we know we must occasionally <html:em>page out</html:em> some pages from physical memory to swap spaces. The large question remains:</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:em>What page do you evict at any given time?</html:em>
</html:div>

<html:p>Such a decision is a <html:em>policy</html:em>, and the quality of a policy is often weighed by the <html:em>average mean access time</html:em> (AMAT) given by 
<fr:tex display="block"><![CDATA[AMAT = (1 - P_{miss})T_P + P_{miss} T_D ]]></fr:tex>
where <fr:tex display="inline"><![CDATA[T_P]]></fr:tex> is the time to access physical memory and <fr:tex display="inline"><![CDATA[T_D]]></fr:tex> is time to access disk. For large discrepancies in <fr:tex display="inline"><![CDATA[T_M]]></fr:tex> and <fr:tex display="inline"><![CDATA[T_D]]></fr:tex>, we can have a substantial difference in AMAT for even very low <fr:tex display="inline"><![CDATA[P_{miss}]]></fr:tex>.
</html:p>
<html:p>The "optimal" policy is one that evicts the page whose next use is farthest away. Unfortunately, this is not feasible to implement as we do not know the future.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
A desirable and surprisingly not guaranteed property we want in our policy is the <html:em>stack property</html:em>, which guarantess that if the cache size increases our miss rate gets no worse. This is not the case with FIFO and is known as <html:em>Belady's anomaly</html:em>.
</fr:mainmatter></fr:tree>

<html:p>We instead consider the <html:em>least recently used</html:em> (LRU) heuristic. The effectiveness of such a policy can be attributed to the <html:em>principle of locality</html:em>. Namely, in this case, we enforce temporal locality, where resident pages are close in terms of time accessed. </html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
In practice, we do not implement pure LRU either. This would require maintaining a separate data structure and modifying at every memory access. Instead, we utilize the <html:em>clock algorithm</html:em>, where a reference bit is set to <fr:tex display="inline"><![CDATA[1]]></fr:tex> each time an access occurs. The algorithm then proceeds by looping through all pages 
<html:ol><html:li>If reference bit is <fr:tex display="inline"><![CDATA[1]]></fr:tex>, set to <fr:tex display="inline"><![CDATA[0]]></fr:tex> and proceed to next page.</html:li>
  <html:li>If reference bit is <fr:tex display="inline"><![CDATA[0]]></fr:tex> evict the current page.</html:li></html:ol>
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
LRU is by no means optimal and in the looping workload (where we loop access one more page than the page table size) we miss 100 percent of the time.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:title text="Case studies: Useful Tricks">Case studies: Useful Tricks</fr:title></fr:frontmatter><fr:mainmatter>

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>8</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:strong>What happens when you dereference a nullptr?</html:strong> First, we check the TLB for the VPN 0. We miss and then check the page table. The page will be marked invalid, and we will trap to the OS.
</fr:mainmatter></fr:tree>
 

<html:p>LRU is a <html:em>global policy</html:em>, meaning that it does not distinguish the memory use by process. Therefore, memory hog processes can hog memory. To deal with this, one approach is <html:em>segmented FIFO</html:em>, where they maintain a FIFO queue for each process. If the queue exceeds the <html:em>resident set size</html:em> then the first-in page is evicted. They maintain two lists: <html:em>clean page free list</html:em> and <html:em>dirty page list</html:em>. 
<html:ol><html:li>If a page is evicted but free it is put on the clean page free list.</html:li>
  <html:li>Otherwise, it is put on the dirty page list.</html:li></html:ol>
If the original process faults on a page still on the dirty page list it reclaims that page and avoids the I/O.
</html:p>
<html:p><html:em>on-demand zeroing</html:em>
<html:ul><html:li>When heap memory is allocated a lot of it goes unused.</html:li>
  <html:li>Do not need to zero allocated memory until it is used</html:li></html:ul>
<html:em>copy on write</html:em>
<html:ul><html:li>We do not need to copy pages across address spaces unless they are modified.</html:li>
  <html:li>i.e. <html:code>fork()</html:code>, shared libraries, etc.</html:li>
  <html:li>Both VPNs map to same PPN.</html:li>
  <html:li>PTE has additional bits to trap to OS on write.</html:li></html:ul>
<html:em>Page clustering</html:em>
<html:ul><html:li>Cluster small page I/O together and perform one write all at once.</html:li>
  <html:li>Collect large batch from global dirty list.</html:li></html:ul></html:p>
<html:p>A common convention for ease of implementation is also to include the kernel in each process address space. This can be made even more efficiently via <html:em>copy on write</html:em>, where each process will just refer to the same kernel code in physical memory.</html:p>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
        <fr:tree show-metadata="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>8</fr:month>
              <fr:day>16</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/5P43/</fr:uri>
            <fr:display-uri>5P43</fr:display-uri>
            <fr:route>/5P43/</fr:route>
            <fr:title text="Concurrency">Concurrency</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/16TG/</fr:uri>
                <fr:display-uri>16TG</fr:display-uri>
                <fr:route>/16TG/</fr:route>
                <fr:title text="Concurrency Intro">Concurrency Intro</fr:title>
              </fr:frontmatter>
              <fr:mainmatter><html:p>Each <html:em>thread</html:em> contains its own program counter (PC) and a private set of registers. They do <html:strong>NOT</html:strong> contain their own address space like a process.</html:p><html:p>Similar to the process control block (PCB), in order to perform a context switch each process needs a <html:em>thread control block</html:em>(TCB).</html:p><html:p>Additionally, the process needs one stack <html:strong>per-thread</html:strong>. This does ruin our neatly partitioned address space. However, it is generally OK because each individual stack is not too large.</html:p><html:p><html:strong>Why do we use threads?</html:strong></html:p><html:ol><html:li><html:em>Intra-process parallelism</html:em>: within a process, there are often highly parallelizable components. However, we do not want to have to divide the program into processes and perform the much more expensive context switch.</html:li>
  <html:li><html:em>Avoid blocking I/O</html:em>: even if you do not want to parallelize your program you can still use a thread to avoid blocking I/O by just having that thread blocked while you continue doing other work.</html:li></html:ol>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>8</fr:month><fr:day>16</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
Suppose we have the following sequence of instructions (pseudo-assembly)
<html:pre><![CDATA[  mov addr reg
  add 1 reg
  mov reg addr]]></html:pre>
If you have two threads running this and hope the end result is that you increment the corresponding variable by two, then you might be in for some disappointment. This is a <html:em>non-atomic</html:em> operation because conceivably 
<html:ol><html:li>thread 1 could store the value of the register</html:li> 
 <html:li>thread 2 could store the value of the register</html:li>
 <html:li>thread 1 increments</html:li>
 <html:li>thread 2 increments</html:li>
 <html:li>end result is only <html:strong>1</html:strong> increment</html:li></html:ol>
This is a <html:em>race condition</html:em> and code that is accessed by multiple threads is the <html:em>critical section</html:em>.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter>
            </fr:tree>
            <fr:tree show-metadata="false">
              <fr:frontmatter>
                <fr:authors />
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>8</fr:month>
                  <fr:day>16</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/W8SQ/</fr:uri>
                <fr:display-uri>W8SQ</fr:display-uri>
                <fr:route>/W8SQ/</fr:route>
                <fr:title text="Locks">Locks</fr:title>
              </fr:frontmatter>
              <fr:mainmatter />
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>2</fr:month>
          <fr:day>1</fr:day>
        </fr:date>
        <fr:uri>https://kellenkanarios.com/004B/</fr:uri>
        <fr:display-uri>004B</fr:display-uri>
        <fr:route>/004B/</fr:route>
        <fr:title text="Notebook: Information Theory">Notebook: Information Theory</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Definitions">Definitions</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:uri>https://kellenkanarios.com/0081/</fr:uri><fr:display-uri>0081</fr:display-uri><fr:route>/0081/</fr:route><fr:title text="Entropy">Entropy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We define the <html:em>entropy</html:em> of a random variable <fr:tex display="inline"><![CDATA[X \sim  p_{X}]]></fr:tex>, where <fr:tex display="inline"><![CDATA[p_{X} : \mathcal {X} \to  [0, 1]]]></fr:tex> as 
<fr:tex display="block"><![CDATA[H(X) = -\sum _{x \in  |\mathcal {X}|} p_{X}(x) \log  p_{X}(x)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Lecture 5">Lecture 5</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004C/</fr:uri><fr:display-uri>004C</fr:display-uri><fr:route>/004C/</fr:route><fr:title text="Convex set">Convex set</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[C]]></fr:tex> is said to be convex if for any <fr:tex display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex> then <fr:tex display="inline"><![CDATA[\lambda  x_1 + (1 - \lambda )x_2 \in  C]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004D/</fr:uri><fr:display-uri>004D</fr:display-uri><fr:route>/004D/</fr:route><fr:title text="Convex Function">Convex Function</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A function <fr:tex display="inline"><![CDATA[f : C \to  \mathbb {R}]]></fr:tex> is said to be convex if <fr:tex display="inline"><![CDATA[C]]></fr:tex> is convex, and for any <fr:tex display="inline"><![CDATA[x_1, x_2 \in  C]]></fr:tex>, <fr:tex display="inline"><![CDATA[\lambda  \in  [0,1]]]></fr:tex>, we have
<fr:tex display="block"><![CDATA[f(\lambda  x_1 + (1 - \lambda )x_2) \leq  \lambda  f(x_1) + (1 - \lambda )f(x_2)]]></fr:tex>
and strictly convex if the inequality is strict.
</html:p></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0034/</fr:uri><fr:display-uri>0034</fr:display-uri><fr:route>/0034/</fr:route><fr:title text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x}
\rangle ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
    This can be thought of as the tangent is always an underestimate of a convex function.
  </fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0035/</fr:uri><fr:display-uri>0035</fr:display-uri><fr:route>/0035/</fr:route><fr:title text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  This implies positive curvature or the common "bowl-shaped" interpretation.
  </fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002G/</fr:uri><fr:display-uri>002G</fr:display-uri><fr:route>/002G/</fr:route><fr:title text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex display="inline"><![CDATA[X]]></fr:tex> then <fr:tex display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
    Holds with equality if and only if 
    <html:ol><html:li><fr:tex display="inline"><![CDATA[f]]></fr:tex> is linear on <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[X]]></fr:tex> is a constant almost surely.</html:li></html:ol>
  </fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004E/</fr:uri><fr:display-uri>004E</fr:display-uri><fr:route>/004E/</fr:route><fr:title text="Gibb's inequality">Gibb's inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[D_{\mathrm {KL}}(P || Q) \geq  0]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Note that 
<fr:tex display="block"><![CDATA[
\begin {align*}
 D_{\mathrm {KL}}(P || Q) &= \mathbb {E}_P \left [\log \left (\frac {P(x)}{Q(x)}\right )\right ] \\
&= \mathbb {E}_P \left [-\log \left (\frac {Q(x)}{P(x)}\right )\right ] \\
\end {align*}
]]></fr:tex>
By <fr:link href="/002G/" title="Jensen's Inequality" uri="https://kellenkanarios.com/002G/" display-uri="002G" type="local">Jensen's Inequality</fr:link>,
<fr:tex display="block"><![CDATA[
  \begin {align*}
    D_{\mathrm {KL}}(P || Q) &\geq  -\log  \left (\mathbb {E}_P \left [\frac {Q(x)}{P(x)}\right ]\right ) = 0
  \end {align*}
]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Problem</fr:taxon></fr:frontmatter><fr:mainmatter>
  When is <fr:tex display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q) = 0]]></fr:tex>?
</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>
    Need <fr:tex display="inline"><![CDATA[Q(x) / P(x)]]></fr:tex> to be constant almost surely. This occurs only when <fr:tex display="inline"><![CDATA[Q = P]]></fr:tex>. 
    <fr:tex display="block"><![CDATA[
        Q(x) / P(x) = c \implies  Q(x) = P(x) c \iff  \sum  Q(x) = c \sum  P(x) \implies  c = 1
      ]]></fr:tex>
  </fr:mainmatter></fr:tree>

  <html:strong>Applications of <fr:link href="/004E/" title="Gibb's inequality" uri="https://kellenkanarios.com/004E/" display-uri="004E" type="local">Gibb's inequality</fr:link>:</html:strong>
  <html:ul><html:li><fr:tex display="inline"><![CDATA[I(X; Y) \geq  0]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[H(X | Y) \leq  H(X)]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[H(X^n) \leq  \sum _{i = 1}^n H(X_i)]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[H(X) \leq  \log  |\mathcal {X}|]]></fr:tex></html:li></html:ul>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004F/</fr:uri><fr:display-uri>004F</fr:display-uri><fr:route>/004F/</fr:route><fr:title text="Log-Sum Inequality">Log-Sum Inequality</fr:title></fr:frontmatter><fr:mainmatter><html:p>
If <fr:tex display="inline"><![CDATA[a_{i},b_{i}>0]]></fr:tex> for <fr:tex display="inline"><![CDATA[i\in \{1,\ldots ,n\}]]></fr:tex>; <fr:tex display="inline"><![CDATA[A=\sum _{i=1}^{n}a_{i},\quad  B=\sum _{i=1}^{n}b_{i}]]></fr:tex>
Then, we have: <fr:tex display="inline"><![CDATA[\sum _{i=1}^{n}a_{i}\log  a_{i}/b_{i}\geq  A\log  A/B]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Define <fr:tex display="inline"><![CDATA[p_i = \frac {a_i}{A}]]></fr:tex>, <fr:tex display="inline"><![CDATA[q_i = \frac {b_i}{B}]]></fr:tex>, then 
<fr:tex display="block"><![CDATA[
\begin {align*}
  D_{\mathrm {KL}}(p || q) &= \sum  \frac {a_i}{A} \log {\frac {B a_i}{A b_i}} \\
  &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \sum  \frac {a_i}{A} \log {\frac {A}{B}} \\
  &= \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \\
\end {align*}
]]></fr:tex>
By <fr:link href="/004E/" title="Gibb's inequality" uri="https://kellenkanarios.com/004E/" display-uri="004E" type="local">Gibb's inequality</fr:link>,
<fr:tex display="block"><![CDATA[
\begin {align*}
  \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} - \log {\frac {A}{B}} \geq  0
  &\implies 
  \sum  \frac {a_i}{A} \log {\frac {a_i}{b_i}} \geq  \log {\frac {A}{B}} \\
  &\iff 
  A \sum  a_i \log {\frac {a_i}{b_i}} \geq  A \log {\frac {A}{B}}
\end {align*}
]]></fr:tex>
as desired.
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
  <html:strong>Consequences of <fr:link href="/004F/" title="Log-Sum Inequality" uri="https://kellenkanarios.com/004F/" display-uri="004F" type="local">Log-Sum Inequality</fr:link>:</html:strong>
  <html:ul><html:li>Joint convexity of <fr:tex display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>,</html:li>
      <html:li>Individual convexity of <fr:tex display="inline"><![CDATA[D_{\mathrm {KL}}(P || Q)]]></fr:tex>.</html:li>
      <html:li>Concavity of entropy.</html:li></html:ul>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Lecture 7">Lecture 7</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004Y/</fr:uri><fr:display-uri>004Y</fr:display-uri><fr:route>/004Y/</fr:route><fr:title text="Maximum Aposteriori Estimator">Maximum Aposteriori Estimator</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The optimal estimator <fr:tex display="inline"><![CDATA[g^* : \mathcal {Y} \to  \mathcal {X}]]></fr:tex> is
<fr:tex display="block"><![CDATA[
\begin {align*}
  g^*(y) = \arg \max _{x \in  \mathcal {X}} P_{X | Y}(x | y)
\end {align*}
]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    Recall that
<fr:tex display="block"><![CDATA[
    \begin {align*}
      P_{e}(g) &= \sum _{x}\sum _y P_{XY}(x, y) \cdot  \mathbf {1}_{x \neq  g(y)} \\
      &= \sum _{y} P_Y(y) \sum _{x} P_{X|Y}(x|y) \mathbf {1}_{x \neq  g(y)} \\
      &= \sum _{y} P_Y(y) (1 - P_{X|Y}(g(y)|y)) \\
    \end {align*}
]]></fr:tex>
To minimize this, we take
<fr:tex display="block"><![CDATA[
  \begin {align*}
    g^*(y) = \arg \max _{x} P_{X|Y}(x | y)
  \end {align*}
]]></fr:tex>
as desired.
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Data Processing Inequality"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Data Processing Inequality</fr:title></fr:frontmatter><fr:mainmatter>
    High-level
    <html:ul><html:li><fr:tex display="inline"><![CDATA[Y]]></fr:tex> contains more information about <fr:tex display="inline"><![CDATA[X]]></fr:tex> than <fr:tex display="inline"><![CDATA[\hat {X}]]></fr:tex>.</html:li>
        <html:li>We cannot increase the amount of information about <fr:tex display="inline"><![CDATA[X]]></fr:tex> by processing <fr:tex display="inline"><![CDATA[Y]]></fr:tex>.</html:li></html:ul>
    <html:strong>Markov Chains:</html:strong>
    <html:ul><html:li><fr:tex display="inline"><![CDATA[(U, V, W)]]></fr:tex> form a Markov chain if
        <fr:tex display="block"><![CDATA[
\begin {align*}
  P(W = w \mid  U = u, V = v) = P(w = w \mid  V = v)
\end {align*}
          ]]></fr:tex>
Denoted <fr:tex display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>.
        </html:li>
          <html:li>Equivalently, we say <fr:tex display="inline"><![CDATA[(U \perp  W) | V]]></fr:tex> which means <fr:tex display="block"><![CDATA[
             P(W = w, U=u \mid  V = v) \implies  P(W = w \mid  V = v)P(U = u \mid  V = v)
          ]]></fr:tex></html:li>
          <html:li>Reversibility: <fr:tex display="inline"><![CDATA[U \to  V \to  W \iff  W \to  V \to  U]]></fr:tex>.</html:li>
          <html:li>Estimation: <fr:tex display="inline"><![CDATA[X \to  Y \to  \hat {X}]]></fr:tex></html:li></html:ul> 

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004Z/</fr:uri><fr:display-uri>004Z</fr:display-uri><fr:route>/004Z/</fr:route><fr:title text="Data Processing Inequality">Data Processing Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  Suppose that <fr:tex display="inline"><![CDATA[U \to  V \to  W]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[I(U; W) \leq  I(U; V)]]></fr:tex>.
  </html:p><html:p><html:strong>Intuition:</html:strong> by data processing, we can never create new information about <fr:tex display="inline"><![CDATA[U]]></fr:tex>.
</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Use chain rule to expand <fr:tex display="inline"><![CDATA[I(U; (V, W))]]></fr:tex> in two ways i.e. 
<fr:tex display="block"><![CDATA[
  \begin {align*}
    I(U; (V, W)) = I(U; V) + I(U; W | V) = I(U; W) + I(U; V | W)
  \end {align*}
]]></fr:tex>
Since <fr:tex display="inline"><![CDATA[U \to  V \to  W]]></fr:tex> is a Markov chain, <fr:tex display="inline"><![CDATA[I(U; W | V) = 0]]></fr:tex>. Therefore,
<fr:tex display="block"><![CDATA[
\begin {align*}
  I(U; V)  &= I(U; W) + I(U; V | W) \\
&\geq  I(U; W)
\end {align*}
]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Fano's Inequality"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Fano's Inequality</fr:title></fr:frontmatter><fr:mainmatter>
    <html:ul><html:li><fr:tex display="inline"><![CDATA[H(X | Y)]]></fr:tex> controls the error probability <fr:tex display="inline"><![CDATA[P_e]]></fr:tex>.</html:li></html:ul>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>9</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0050/</fr:uri><fr:display-uri>0050</fr:display-uri><fr:route>/0050/</fr:route><fr:title text="Fano's Inequality">Fano's Inequality</fr:title></fr:frontmatter><fr:mainmatter><html:p>
  Suppose that <fr:tex display="inline"><![CDATA[X \iff  Y \iff  \hat {X}]]></fr:tex> and let <fr:tex display="inline"><![CDATA[p_e = \mathbb {P}(X \neq  \hat {X})]]></fr:tex>. Then, we have 
  <fr:tex display="block"><![CDATA[
      \begin {align*}
        H(p_e) + p_e \log (|\mathcal {X}| - 1) \geq  H(X \mid  \hat {X}) \geq  H(X \mid  Y)
      \end {align*}
    ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Asymptotic Equipartion Propery">Asymptotic Equipartion Propery</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0051/</fr:uri><fr:display-uri>0051</fr:display-uri><fr:route>/0051/</fr:route><fr:title text="Weak Law of Large Numbers">Weak Law of Large Numbers</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Then,

<fr:tex display="block"><![CDATA[\frac {1}{n}\sum _{i=1}^{n}X_{i}\stackrel {{p}}{{\rightarrow }}\mu ]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    By <fr:link href="/002F/" title="Chebyshev's Inequality" uri="https://kellenkanarios.com/002F/" display-uri="002F" type="local">Chebyshev's Inequality</fr:link>,
    <fr:tex display="block"><![CDATA[
    \begin {align*}
      \mathbb {P}(|\hat {X} - \mu | > a) \leq  -\frac {\sigma ^2}{a^2}
    \end {align*}
    ]]></fr:tex>
    Since <fr:tex display="inline"><![CDATA[X_i]]></fr:tex>'s are independent, 
<fr:tex display="block"><![CDATA[\mathrm {Var}[\hat {X}] = \frac {1}{n^2} \sum _{i = 1}^{n} \mathrm {Var}[X_i]]]></fr:tex>
    Therefore,
<fr:tex display="block"><![CDATA[
    \begin {align*}
      \lim _{n \to  \infty } \mathbb {P}(|\hat {X} - \mu | > a) \leq  \lim _{n \to  \infty }-\frac {\sigma ^2}{n a^2} \to  0
    \end {align*}
]]></fr:tex>
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0052/</fr:uri><fr:display-uri>0052</fr:display-uri><fr:route>/0052/</fr:route><fr:taxon>Corollary</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex>: a sequence of i.i.d. r.v.s. with mean <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>, variance <fr:tex display="inline"><![CDATA[\sigma ^{2}]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> be any function, such that <fr:tex display="inline"><![CDATA[\mathrm {Var}(f(X))=\sigma _{f}^{2}<\infty ]]></fr:tex>. Then,
<fr:tex display="block"><![CDATA[\frac {1}{n} \sum _{i = 1}^{n} f(X_i) \stackrel {p}{\rightarrow } \mathbb {E}[f(X)]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0053/</fr:uri><fr:display-uri>0053</fr:display-uri><fr:route>/0053/</fr:route><fr:title text="Continuous Mapping Theorem">Continuous Mapping Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[X_{n}\stackrel {{p}}{{\rightarrow }}X]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f:\mathcal {X}\rightarrow \mathbb {R}]]></fr:tex> denote a continuous function. Then,
<fr:tex display="block"><![CDATA[f(X_n) \stackrel {p}{\rightarrow } f(X)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0054/</fr:uri><fr:display-uri>0054</fr:display-uri><fr:route>/0054/</fr:route><fr:title text="AEP Theorem">AEP Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\{X_{n}:n\geq 1\}]]></fr:tex> denote i.i.d. <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with distribution <fr:tex display="inline"><![CDATA[P_{X}]]></fr:tex>. Then,

<fr:tex display="block"><![CDATA[
\begin {align*}
 \lim _{n\to \infty }-\frac {1}{n}\log  p_{X^{n}}(X_{1},\ldots ,X_{n}) &= \lim _{n \to  \infty } -\frac {1}{n} \log  \prod _{i = 1}^{n} P_X(X_i) \\
 &= \mathbb {E}_{X \sim  p_X}[-\log  p_X(X)] \\ 
 &= H(X)
\end {align*}
]]></fr:tex>
Equivalently, for large <fr:tex display="inline"><![CDATA[n]]></fr:tex>
<fr:tex display="block"><![CDATA[
  \begin {align*}
    \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon 
  \end {align*}
]]></fr:tex>
with high probability.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0055/</fr:uri><fr:display-uri>0055</fr:display-uri><fr:route>/0055/</fr:route><fr:title text="\epsilon -typical set"><fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set</fr:title></fr:frontmatter><fr:mainmatter><html:p>
Fix an <fr:tex display="inline"><![CDATA[\epsilon >0]]></fr:tex>. Then, an <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>-typical set with respect to the pmf <fr:tex display="inline"><![CDATA[p_{X}]]></fr:tex>, denoted by <fr:tex display="inline"><![CDATA[A_{\epsilon }^{(n)}]]></fr:tex>, is defined as
<fr:tex display="block"><![CDATA[\left \{X^n \in  \mathcal {X}^n \mid  \left |-\frac {1}{n} \log  p_{X^n}(X^n) - H(X)\right | \leq  \epsilon  \right \}]]></fr:tex>
Alternatively,
<fr:tex display="block"><![CDATA[A_{\epsilon ^{(n)}} = \left \{X^n \in  \mathcal {X}^n \mid  2^{-n(H(X) + \epsilon )} \leq  p_{X^n}(X^n) \leq  2^{-n(H(X) - \epsilon )}\right \}]]></fr:tex></html:p>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  We have the following important properties
  <html:ol><html:li><fr:tex display="inline"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)})\geq 1-\epsilon {\text { for large enough }}n]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[|A_{c}^{(n)}|\leq 2^{n(H(X)+\epsilon )}]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[|A_{\epsilon }^{(n)}|\geq (1-\epsilon )2^{n(H(X)-\epsilon )}\;\text {for large enough }\;n\;,]]></fr:tex></html:li></html:ol>
    Together, this says that, depending on the entropy, the typical set can contain most of the probability despite being much smaller than the entire space.
  </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<html:p><html:strong>interpretation:</html:strong> <fr:tex display="inline"><![CDATA[A_{\epsilon }^{(n)}\,\text { is a subset of }\,{\mathcal {X}}^{n}]]></fr:tex>
<html:ul><html:li>Contains almost all the probability.</html:li>
    <html:li>Consists of <fr:tex display="inline"><![CDATA[\approx  2^{nH(X)}]]></fr:tex></html:li>
    <html:li>Almost equiprobable sequences.</html:li></html:ul></html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>10</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0056/</fr:uri><fr:display-uri>0056</fr:display-uri><fr:route>/0056/</fr:route><fr:title text="High probability sets">High probability sets</fr:title><fr:taxon>Corollary</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[B_{\epsilon }^{(n)}\subset \mathcal {X}^{n}]]></fr:tex> be the smallest set with probability at least <fr:tex display="inline"><![CDATA[1-\epsilon ]]></fr:tex>. Then, we must have

<fr:tex display="block"><![CDATA[\mathbb {P}(A_{\epsilon }^{(n)}\cap  B_{\epsilon }^{(n)})\geq 1-2\epsilon ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Fixed-rate lossless source coding">Fixed-rate lossless source coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0059/</fr:uri><fr:display-uri>0059</fr:display-uri><fr:route>/0059/</fr:route><fr:title text="Coding system">Coding system</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A coding system with parameters <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> consist of an encoder and a decoder, where an encoder is a function
<fr:tex display="block"><![CDATA[
  e: \mathcal {X}^n \to  \{1, 2, \ldots , \theta \}
]]></fr:tex>
and a decoder is a function 
<fr:tex display="block"><![CDATA[f: \{1, 2, \ldots , \theta \} \to  \mathcal {X}^n]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<html:p><html:strong>Performance:</html:strong>
    <html:ul><html:li>Rate = <fr:tex display="inline"><![CDATA[\frac {\log _2 \theta }{n}]]></fr:tex></html:li>
        <html:li>Probability of decoding error = <fr:tex display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n|]]></fr:tex></html:li></html:ul></html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005A/</fr:uri><fr:display-uri>005A</fr:display-uri><fr:route>/005A/</fr:route><fr:title text="Achievability">Achievability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A positive real number <fr:tex display="inline"><![CDATA[R]]></fr:tex> is said to be <html:em>achievable</html:em> if for all <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex> (perturbation parameter) there exists a block length <fr:tex display="inline"><![CDATA[N(\epsilon )]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\forall  n > N(\epsilon )]]></fr:tex> the following holds
<html:ul><html:li>There exists an <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> <fr:link href="/0059/" title="Coding system" uri="https://kellenkanarios.com/0059/" display-uri="0059" type="local">coding system</fr:link> such that <fr:tex display="inline"><![CDATA[\frac {\log  \theta }{n} < R + \epsilon ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {P}|\hat {X}^n \neq  X^n| < \epsilon ]]></fr:tex>.</html:li></html:ul></html:p><html:p>Alternatively, a positive real number <fr:tex display="inline"><![CDATA[R]]></fr:tex> is said to be <html:em>achievable</html:em> if there exists a sequence of <fr:link href="/0059/" title="Coding system" uri="https://kellenkanarios.com/0059/" display-uri="0059" type="local">coding systems</fr:link> <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log  \theta }{n} \to  R]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lim _{n \to  \infty } \mathbb {P}|\hat {X}^n \neq  X^n| \to  0]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005B/</fr:uri><fr:display-uri>005B</fr:display-uri><fr:route>/005B/</fr:route><fr:title text="Minimum rate of source coding">Minimum rate of source coding</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The <html:em>minimum rate of source coding</html:em> <fr:tex display="inline"><![CDATA[R_s]]></fr:tex> is the infimum over all <fr:tex display="inline"><![CDATA[R]]></fr:tex> such that <fr:tex display="inline"><![CDATA[R]]></fr:tex> is <fr:link href="/005A/" title="Achievability" uri="https://kellenkanarios.com/005A/" display-uri="005A" type="local">achievable</fr:link> i.e.  
<fr:tex display="block"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005C/</fr:uri><fr:display-uri>005C</fr:display-uri><fr:route>/005C/</fr:route><fr:title text="Entropy as MRSC">Entropy as <fr:link href="/005B/" title="Minimum rate of source coding" uri="https://kellenkanarios.com/005B/" display-uri="005B" type="local">MRSC</fr:link></fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[R_s = H(P_X) = H(X) = -\sum _{x \in  \mathcal {X}} P_X(x) \log  P_X(x)]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>11</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>
    First we will show that <fr:tex display="inline"><![CDATA[H(X)]]></fr:tex> is <fr:link href="/005A/" title="Achievability" uri="https://kellenkanarios.com/005A/" display-uri="005A" type="local">achievable</fr:link>. Then we will have <fr:tex display="inline"><![CDATA[R_s \leq  H(X)]]></fr:tex> by definition. Idea: take <fr:tex display="inline"><![CDATA[\theta  = 2^{n(H(X) + \epsilon )} + 1]]></fr:tex>. Give each element in typical set a unique index, everything else the same index. By properties of typical set, <fr:tex display="inline"><![CDATA[\mathbb {P}(\text {error}) < \epsilon ]]></fr:tex> for sufficiently large <fr:tex display="inline"><![CDATA[n]]></fr:tex>.
  </html:p>
  <html:p>
      For the other direction, suppose we have some <fr:tex display="inline"><![CDATA[R]]></fr:tex> <fr:link href="/005A/" title="Achievability" uri="https://kellenkanarios.com/005A/" display-uri="005A" type="local">achievable</fr:link>. By definition, for all <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, for all sufficiently large <fr:tex display="inline"><![CDATA[n]]></fr:tex> there exists a <fr:link href="/0059/" title="Coding system" uri="https://kellenkanarios.com/0059/" display-uri="0059" type="local">Coding system</fr:link> with parameters <fr:tex display="inline"><![CDATA[(n, \theta )]]></fr:tex> such that
<fr:tex display="block"><![CDATA[
        \begin {align*}
          \frac {\log  \theta }{n} < R + \epsilon , \quad  \mathbb {P}(\text {error}) < \epsilon 
        \end {align*}
      ]]></fr:tex>
      Use <fr:link href="/0050/" title="Fano's Inequality" uri="https://kellenkanarios.com/0050/" display-uri="0050" type="local">Fano's Inequality</fr:link> to show this is not possible.
    </html:p>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
  </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Variable Rate Source Coding">Variable Rate Source Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005K/</fr:uri><fr:display-uri>005K</fr:display-uri><fr:route>/005K/</fr:route><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A coding system (variable rate) with parameter <fr:tex display="inline"><![CDATA[n]]></fr:tex> and an encoder-decoder pair <fr:tex display="inline"><![CDATA[(e,f)]]></fr:tex>, where 
<fr:tex display="block"><![CDATA[e: \mathcal {X}^n \to  \{0, 1\}^*, \quad  \text {and} \quad  f: \{0, 1\}^* \to  \mathcal {X}^n]]></fr:tex>
We want the probability of error to be exactly zero; that is <fr:tex display="inline"><![CDATA[\mathbb {P}(X^n \neq  f(e(X^n))) = 0]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005L/</fr:uri><fr:display-uri>005L</fr:display-uri><fr:route>/005L/</fr:route><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\ell (x^n)]]></fr:tex> denote the number of bits in <fr:tex display="inline"><![CDATA[e(x^n)]]></fr:tex>, where <fr:tex display="inline"><![CDATA[e]]></fr:tex> is the encoding function. Then, the rate is <fr:tex display="block"><![CDATA[\frac {\mathbb {E}[\ell (X^n)]}{n}]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Although it is unclear here, the difference between variable and fixed rate source coding is that we allow our encoder and decoder to map to/from <fr:tex display="inline"><![CDATA[\{0,1\}^* ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[^*]]></fr:tex> is variable i.e. our encoded versions of our alphabet can have varying lengths.</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>24</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005U/</fr:uri><fr:display-uri>005U</fr:display-uri><fr:route>/005U/</fr:route><fr:title text="Singularity of a code">Singularity of a code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[e]]></fr:tex> is many-to-one then we say that <fr:tex display="inline"><![CDATA[e]]></fr:tex> is singular. Similarly, if <fr:tex display="inline"><![CDATA[e]]></fr:tex> is one-to-one then <fr:tex display="inline"><![CDATA[e]]></fr:tex> is non-singular.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005M/</fr:uri><fr:display-uri>005M</fr:display-uri><fr:route>/005M/</fr:route><fr:title text="Extensions and Unique Decodability">Extensions and Unique Decodability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Given a code with <fr:tex display="inline"><![CDATA[n = 1]]></fr:tex>, we define its extension <fr:tex display="inline"><![CDATA[e^*]]></fr:tex>; that maps <fr:tex display="inline"><![CDATA[\mathcal {X}^* \to  \{0,1\}^* ]]></fr:tex> by concatenation. That is 
<fr:tex display="block"><![CDATA[e^*(x_{1}, x_{2}, \ldots , x_m) = (e(x_{1}), e(x_{2}), \ldots , e(x_m))]]></fr:tex>
A code with encoder <fr:tex display="inline"><![CDATA[e]]></fr:tex> is said to be uniquely decodable if <fr:tex display="inline"><![CDATA[e^*]]></fr:tex> is <fr:link href="/005U/" title="Singularity of a code" uri="https://kellenkanarios.com/005U/" display-uri="005U" type="local">non-singular</fr:link>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005N/</fr:uri><fr:display-uri>005N</fr:display-uri><fr:route>/005N/</fr:route><fr:title text="instantaneous / prefix-free code">instantaneous / prefix-free code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A code is said to be prefix-free or instantaneous if no codeword is a prefix of another.</html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter><fr:link href="/005N/" title="instantaneous / prefix-free code" uri="https://kellenkanarios.com/005N/" display-uri="005N" type="local">Prefix free</fr:link> codes are <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link>. To show unique-decodability, you simply have to provide a way to decode and show it is unique. For <fr:link href="/005N/" title="instantaneous / prefix-free code" uri="https://kellenkanarios.com/005N/" display-uri="005N" type="local">prefix-free</fr:link>, greedily decoding suffices.</fr:mainmatter></fr:tree>

<html:figure><html:img width="300px" src="/bafkrmib5zz6npwtuhx2bv7mogpae3nas72xwhqerh3i5ixdk3h2kjqchse.png" />
<html:figcaption>Taxonomy of codes from <fr:link href="/coverELEMENTSINFORMATIONTHEORY/" title="ELEMENTS OF INFORMATION THEORY" uri="https://kellenkanarios.com/coverELEMENTSINFORMATIONTHEORY/" display-uri="coverELEMENTSINFORMATIONTHEORY" type="local">Reference <fr:contextual-number uri="https://kellenkanarios.com/coverELEMENTSINFORMATIONTHEORY/" display-uri="coverELEMENTSINFORMATIONTHEORY" /></fr:link>.</html:figcaption></html:figure>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Note that <fr:link href="/005U/" title="Singularity of a code" uri="https://kellenkanarios.com/005U/" display-uri="005U" type="local">non-singular</fr:link> does not imply <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link>. This is because for <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link> we require the extension to be <fr:link href="/005U/" title="Singularity of a code" uri="https://kellenkanarios.com/005U/" display-uri="005U" type="local">non-singular</fr:link>. For example, if we have that <fr:tex display="inline"><![CDATA[e(0) = 0, e(1) = 1, e(2) = 01]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[e^*(01) = e^*(2)]]></fr:tex>. From this, we can see that <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link> is a much stronger condition.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Kraft's inequality">Kraft's inequality</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005O/</fr:uri><fr:display-uri>005O</fr:display-uri><fr:route>/005O/</fr:route><fr:title text="Kraft's inequality">Kraft's inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[e: \mathcal {X} \to  \{0,1\}^* ]]></fr:tex> denote a <fr:link href="/005N/" title="instantaneous / prefix-free code" uri="https://kellenkanarios.com/005N/" display-uri="005N" type="local">prefix-free</fr:link> code with lengths <fr:tex display="inline"><![CDATA[\ell _i = \ell (x_i)]]></fr:tex> for <fr:tex display="inline"><![CDATA[x_i \in  \mathcal {X}]]></fr:tex>. Suppose <fr:tex display="inline"><![CDATA[|\mathcal {X}| = m]]></fr:tex>. Then the following must be true:
<fr:tex display="block"><![CDATA[\sum _{i=1}^{m} 2^{-\ell _i} \leq  1]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Other direction is also true. For any <fr:tex display="inline"><![CDATA[\ell _i]]></fr:tex> satisfying Kraft's inequality, one can construct a prefix-free code whose lengths of <fr:tex display="inline"><![CDATA[e(x_i) = \ell _i]]></fr:tex>.</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Surprisingly, any <fr:link href="/005M/" title="Extensions and Unique Decodability" uri="https://kellenkanarios.com/005M/" display-uri="005M" type="local">uniquely decodable</fr:link> code must also satisfy <fr:link href="/005O/" title="Kraft's inequality" uri="https://kellenkanarios.com/005O/" display-uri="005O" type="local">Kraft's inequality</fr:link>.</fr:mainmatter></fr:tree>

    </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Performance Limit of Variable Rate Source Codes">Performance Limit of Variable Rate Source Codes</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005P/</fr:uri><fr:display-uri>005P</fr:display-uri><fr:route>/005P/</fr:route><fr:title text="Variable rate code">Variable rate code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A variable rate code with parameter <fr:tex display="inline"><![CDATA[n]]></fr:tex> is a prefix-free code <fr:tex display="inline"><![CDATA[e : \mathcal {X}^n \to  \{0, 1\}^* ]]></fr:tex>, and a decoder <fr:tex display="inline"><![CDATA[f : \{0,1\}^* \to  \mathcal {X}^n ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005Q/</fr:uri><fr:display-uri>005Q</fr:display-uri><fr:route>/005Q/</fr:route><fr:title text="Variable rate achievability">Variable rate achievability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A nonnegative number <fr:tex display="inline"><![CDATA[R]]></fr:tex> is said to be achievable if for all <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>, there exists an <fr:tex display="inline"><![CDATA[n(\epsilon )]]></fr:tex> such that for all <fr:tex display="inline"><![CDATA[n \geq  n(\epsilon )]]></fr:tex>, the following holds
<html:ul><html:li>There exists a variable rate code with <fr:tex display="inline"><![CDATA[\mathbb {E}[\ell (X^n)]/n = R]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {P}(X^n \neq  f(e(X^n))) = 0]]></fr:tex> for all <fr:tex display="inline"><![CDATA[n]]></fr:tex>.</html:li></html:ul></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005R/</fr:uri><fr:display-uri>005R</fr:display-uri><fr:route>/005R/</fr:route><fr:title text="Variable minimum rate">Variable minimum rate</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The minimum rate of variable rate source coding is <fr:tex display="inline"><![CDATA[R_s \coloneqq  \inf  \{R \mid  R \text { is achievable}\}  ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005S/</fr:uri><fr:display-uri>005S</fr:display-uri><fr:route>/005S/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[R_s = H(X)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>23</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005T/</fr:uri><fr:display-uri>005T</fr:display-uri><fr:route>/005T/</fr:route><fr:title text="Shannon Fano Elias Code">Shannon Fano Elias Code</fr:title></fr:frontmatter><fr:mainmatter><html:p><html:strong>Idea</html:strong>: map symbol <fr:tex display="inline"><![CDATA[x]]></fr:tex> to interval in <fr:tex display="inline"><![CDATA[(0,1)]]></fr:tex> using the CDF of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.</html:p><html:ul><html:li>Assume <fr:tex display="inline"><![CDATA[x_{1} < x_{2} < \cdots  < x_m]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[X \sim  P_X]]></fr:tex> is <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued r.v. with <fr:tex display="inline"><![CDATA[\mathbf {p}_X]]></fr:tex></html:li>
  <html:li>CDF of <fr:tex display="inline"><![CDATA[X = F_X(x) \coloneqq   \sum _{x_i \leq  x} P(x_i)]]></fr:tex></html:li>
  <html:li>Midpoint function: <fr:tex display="inline"><![CDATA[G(x) = \sum _{x_i < x} P_X(x) + \frac {P_X(x)}{2} = F_X(x) - \frac {P_X(x)}{2}]]></fr:tex></html:li>
  <html:li>Codeword: <fr:tex display="inline"><![CDATA[e(x) = \left \lfloor  G(x) \right \rfloor _{\ell (x)}=]]></fr:tex> first <fr:tex display="inline"><![CDATA[\ell (x)]]></fr:tex> bits of <fr:tex display="inline"><![CDATA[G(x)]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\ell (x) = \left \lceil  \log (\frac {1}{P_X(x)}) \right \rceil  + 1]]></fr:tex></html:li></html:ul></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005Z/</fr:uri><fr:display-uri>005Z</fr:display-uri><fr:route>/005Z/</fr:route><fr:title text="Huffman Code">Huffman Code</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005W/</fr:uri><fr:display-uri>005W</fr:display-uri><fr:route>/005W/</fr:route><fr:title text="Huffman Code">Huffman Code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Given <fr:tex display="inline"><![CDATA[x_1, \ldots  x_m]]></fr:tex> proceed as follows:
<html:ol><html:li>Take two <fr:tex display="inline"><![CDATA[x_i, x_j]]></fr:tex> with smallest <fr:tex display="inline"><![CDATA[p(x_i), p(x_j)]]></fr:tex> append 0 and 1 to their respective codes.</html:li>
  <html:li>Combine them and treat them as a new value with <fr:tex display="inline"><![CDATA[p(x_i') = p(x_i) + p(x_j)]]></fr:tex></html:li>
  <html:li>Repeat</html:li></html:ol></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0060/</fr:uri><fr:display-uri>0060</fr:display-uri><fr:route>/0060/</fr:route><fr:title text="Optimality of Huffman Code">Optimality of Huffman Code</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X \sim  P_X]]></fr:tex> be an <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>-valued random variable. Define <fr:tex display="block"><![CDATA[L_H = \mathbb {E}_{X \sim  P_X}[\ell _H(x)]]]></fr:tex> and <fr:tex display="block"><![CDATA[L^*(P_X) = \min _{\ell _1, \ldots , \ell _m} \sum _{i = 1}^{m} P_X(x_i) \ell _i.]]></fr:tex> Then <fr:tex display="inline"><![CDATA[L_H = L^*(P_X)]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
SFE satisfies <fr:tex display="inline"><![CDATA[L_H < H(X) + \frac {2}{n}]]></fr:tex> i.e. it achieves the optimal rate as <fr:tex display="inline"><![CDATA[n \to  \infty ]]></fr:tex>. Huffman coding achieves optimality for all finite values <fr:tex display="inline"><![CDATA[n]]></fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Method of Types">Method of Types</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005X/</fr:uri><fr:display-uri>005X</fr:display-uri><fr:route>/005X/</fr:route><fr:title text="type or empirical distribution">type or empirical distribution</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The "type" <fr:tex display="inline"><![CDATA[ \widehat {P}_{x^{n}} ]]></fr:tex> associated with <fr:tex display="inline"><![CDATA[ x^{n}\in \mathcal {X}^{n} ]]></fr:tex> is the probability distribution on <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> with pmf <fr:tex display="inline"><![CDATA[ \widehat {\boldsymbol {p}}_{x^{n}} ]]></fr:tex>, defined as

<fr:tex display="block"><![CDATA[ \widehat {\boldsymbol {p}}_{x^{n}}(a)=\frac {N(a|x^{n})}{n},\quad \text {where}\quad  N(a|x^{n}):=\sum _{i=1}^{n}\mathbf {1}_{x_{i}=a}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/005Y/</fr:uri><fr:display-uri>005Y</fr:display-uri><fr:route>/005Y/</fr:route><fr:title text="Set of all types">Set of all types</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For any <fr:tex display="inline"><![CDATA[ n\geq 1 ]]></fr:tex>, let <fr:tex display="inline"><![CDATA[ \mathcal {P}_{n} ]]></fr:tex> denote the set of all possible types over the alphabet <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> with denominator <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>. That is,

<fr:tex display="block"><![CDATA[ \mathcal {P}_{n}=\{\widehat {P}_{x^{n}}:x^{n}\in \mathcal {X}^{n}\}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0061/</fr:uri><fr:display-uri>0061</fr:display-uri><fr:route>/0061/</fr:route><fr:title text="Type classes">Type classes</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For any type <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex>, we can associate the type class <fr:tex display="inline"><![CDATA[ T(P) ]]></fr:tex>, defined as

<fr:tex display="block"><![CDATA[ T(P)=\{x^{n}:\tilde {P}_{x^{n}}=P\}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
    Let <fr:tex display="inline"><![CDATA[\mathcal {X} = \{1,2,3\}.]]></fr:tex> For <fr:tex display="inline"><![CDATA[n = 2]]></fr:tex>, <fr:tex display="inline"><![CDATA[x^n = 12]]></fr:tex> the <fr:link href="/005X/" title="type or empirical distribution" uri="https://kellenkanarios.com/005X/" display-uri="005X" type="local">type</fr:link> is <fr:tex display="inline"><![CDATA[(\frac {1}{2},\frac {1}{2}, 0)]]></fr:tex> and the <fr:link href="/0061/" title="Type classes" uri="https://kellenkanarios.com/0061/" display-uri="0061" type="local">type class</fr:link> is <fr:tex display="inline"><![CDATA[\{12, 21\}  ]]></fr:tex>.
</fr:mainmatter></fr:tree>
 


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Properties"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Properties</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0062/</fr:uri><fr:display-uri>0062</fr:display-uri><fr:route>/0062/</fr:route><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

Suppose <fr:tex display="inline"><![CDATA[ |\mathcal {X}|=m ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ \mathcal {P}_{n} ]]></fr:tex> denotes the set of all distinct types that can be constructed using elements of <fr:tex display="inline"><![CDATA[ \mathcal {X}^{n} ]]></fr:tex>. Then, we have_

<fr:tex display="block"><![CDATA[ |\mathcal {P}_{n}|=\binom {n+m-1}{m-1}\leq (n+1)^{m}. ]]></fr:tex></html:p>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
<fr:tex display="inline"><![CDATA[\mathcal {X}^n]]></fr:tex> has exponentially many elements in <fr:tex display="inline"><![CDATA[n]]></fr:tex>. However, among the exponentially many elements they can only create polynomially many types in <fr:tex display="inline"><![CDATA[n]]></fr:tex> for fixed <fr:tex display="inline"><![CDATA[m]]></fr:tex>.
</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0063/</fr:uri><fr:display-uri>0063</fr:display-uri><fr:route>/0063/</fr:route><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex> denote a type with denominator <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>. Then, the type class associated with <fr:tex display="inline"><![CDATA[ P ]]></fr:tex>, defined as <fr:tex display="inline"><![CDATA[ T(P)=\{x^{n}:\hat {P}_{x^n}=P\} ]]></fr:tex> satisfies

<fr:tex display="block"><![CDATA[ |T(P)|=\prod _{i=1}^{n}\binom {n-N_{i-1}}{N_{i}},\quad \text {where}\quad  N_{0}=0,\text {and}\ N_{i}=n\times  P(a_{i}), ]]></fr:tex>

for all <fr:tex display="inline"><![CDATA[ a_{i}\in \mathcal {X}=\{a_{1},\ldots ,a_{m}\} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0065/</fr:uri><fr:display-uri>0065</fr:display-uri><fr:route>/0065/</fr:route><fr:taxon>Lemma</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>


Suppose <fr:tex display="inline"><![CDATA[ X_{1},X_{2},\ldots ,X_{n}\stackrel {{i.i.d.}}{{\sim }}Q ]]></fr:tex> for an arbitrary distribution <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex>. Then, we have

<fr:tex display="block"><![CDATA[ \mathbb {P}(X^{n}=x^{n}) \equiv  Q^{n}(x^{n}) = 2^{-n(H(\widehat {P}_{x^{n}})+D_{2n}(\widehat {P}_{x^{n}})=Q)}. ]]></fr:tex>

In other words, the probability that <fr:tex display="inline"><![CDATA[ X^{n} ]]></fr:tex> takes a value <fr:tex display="inline"><![CDATA[ x^{n} ]]></fr:tex> only depends on <fr:tex display="inline"><![CDATA[ x^{n} ]]></fr:tex> through its type <fr:tex display="inline"><![CDATA[ \widehat {P}_{x^{n}} ]]></fr:tex>. Furthermore, types that are far away from <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> in relative entropy are exponentially less probable than those that are close to <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex>.

An immediate consequence of this is that if <fr:tex display="inline"><![CDATA[ Q\in \mathcal {P}_{n} ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ x^{n}\in  T(Q) ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[ Q^{n}(x^{n})=2^{-nH(Q)} ]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0064/</fr:uri><fr:display-uri>0064</fr:display-uri><fr:route>/0064/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ T(P) ]]></fr:tex> denote its type class. Then, the following bounds hold:

<fr:tex display="block"><![CDATA[ (n+1)^{-m}2^{nH(P)}\leq |T(P)|\leq  2^{nH(P)}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0066/</fr:uri><fr:display-uri>0066</fr:display-uri><fr:route>/0066/</fr:route><fr:title text="The probability of a type class">The probability of a type class</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

Let <fr:tex display="inline"><![CDATA[ X^{n}=(X_{1},\ldots ,X_{n})\stackrel {{i.i.d.}}{{\sim }}Q ]]></fr:tex> for an arbitrary distribution <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> on <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex>. Then, we have the following:

<fr:tex display="block"><![CDATA[ (n+1)^{-m}2^{-nD_{KL}(P|Q)}\leq  Q^{n}(T(P))\leq 2^{-nD_{KL}(P|Q)}. ]]></fr:tex>

In other words, the probability that <fr:tex display="inline"><![CDATA[ X^{n}\stackrel {{i.i.d.}}{{\sim }}Q ]]></fr:tex> lies in the type class of <fr:tex display="inline"><![CDATA[ P\in \mathcal {P}_{n} ]]></fr:tex> is <fr:tex display="inline"><![CDATA[ \approx 2^{-nD_{KL}(P||Q)} ]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Large Deviation Theory">Large Deviation Theory</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0067/</fr:uri><fr:display-uri>0067</fr:display-uri><fr:route>/0067/</fr:route><fr:title text="Sanov's Theorem">Sanov's Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ X^{n}\sim  Q^{n} ]]></fr:tex> (i.e., the <fr:tex display="inline"><![CDATA[ X ]]></fr:tex>'s are drawn i.i.d. from <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex>), and <fr:tex display="inline"><![CDATA[ E\subset \Delta _{m} ]]></fr:tex> denote a subset of pmfs over the finite alphabet <fr:tex display="inline"><![CDATA[ X=\{a_{1},\ldots ,a_{m}\} ]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[ Q^{n}(E) ]]></fr:tex> denote the probability <fr:tex display="inline"><![CDATA[ \mathbb {P}_{X^{n}\sim  Q^{n}}(\widehat {P}_{X^{n}}\in  E) ]]></fr:tex>. Then, we have

<fr:tex display="block"><![CDATA[ Q^{n}(E)\leq 2^{-nD_{\mathbb {E}}(P^{n} \parallel  Q)}, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ P^{*}=\inf _{P^{n}\in  E}D_{\mathbb {E}}(P^{*}\mid  Q) ]]></fr:tex> is the closest element of <fr:tex display="inline"><![CDATA[ E ]]></fr:tex> to <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> in terms of relative entropy. Furthermore, if <fr:tex display="inline"><![CDATA[ E ]]></fr:tex> is the closure of its interior, we also have

<fr:tex display="block"><![CDATA[ \operatorname *{lim}_{n\to \infty }-{\frac {1}{n}}\log  Q^{n}(E)=D_{K L}(P^{*}\parallel  Q). ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Hypothesis testing">Hypothesis testing</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0069/</fr:uri><fr:display-uri>0069</fr:display-uri><fr:route>/0069/</fr:route><fr:title text="Hypothesis testing problem">Hypothesis testing problem</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A binary hypothesis testing problem involves three components: the data <fr:tex display="inline"><![CDATA[ X\sim  P ]]></fr:tex>, the null hypothesis class <fr:tex display="inline"><![CDATA[ \mathcal {P}_{0} ]]></fr:tex>, and the alternative distribution class <fr:tex display="inline"><![CDATA[ \mathcal {P}_{1} ]]></fr:tex>, and the goal is to use the data to decide between the null and alternative; that is,

<fr:tex display="block"><![CDATA[ \text {given}\ X\sim  P,\quad  \text {decide between}\quad  H_{0}:P\in \mathcal {P}_{0},\quad \text {versus}\quad  H_{1}:P\in \mathcal {P}_{1}. ]]></fr:tex>


When <fr:tex display="inline"><![CDATA[ {\cal  P}_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ {\cal  P}_{1} ]]></fr:tex> are singleton sets: that is <fr:tex display="inline"><![CDATA[ {\cal  P}_{0}=\{P_{0}\} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ {\cal  P}_{1}=\{P_{1}\} ]]></fr:tex> with known <fr:tex display="inline"><![CDATA[ P_{0},P_{1} ]]></fr:tex>, then the problem is called simple hypothesis testing, and this is what we will focus on mostly in this course:

<fr:tex display="block"><![CDATA[ \text {given}\ X\sim  P,\quad  \text {decide between} \quad  H_{0}:P=P_{0},\quad  \text {versus}\quad  H_{1}:P=P_{1}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006A/</fr:uri><fr:display-uri>006A</fr:display-uri><fr:route>/006A/</fr:route><fr:title text="Hypothesis test">Hypothesis test</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

A randomized hypothesis test is a channel which takes in the data <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> and outputs a <fr:tex display="inline"><![CDATA[ \{0,1\} ]]></fr:tex> valued random variable <fr:tex display="inline"><![CDATA[ Z ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[ Z=i ]]></fr:tex> represents that the test declares that <fr:tex display="inline"><![CDATA[ H_{i} ]]></fr:tex> is true, for <fr:tex display="inline"><![CDATA[ i\in \{0,1\} ]]></fr:tex>.

<fr:tex display="block"><![CDATA[ X\sim  P\longrightarrow \boxed {P_{Z|X}}\longrightarrow  Z ]]></fr:tex>
In some cases, it is sufficient to focus on non-randomized or deterministic tests, for which <fr:tex display="inline"><![CDATA[ P_{\mathbb {Z}|X=x} ]]></fr:tex> is a delta function. That is, for a given realization of <fr:tex display="inline"><![CDATA[ X ]]></fr:tex>, the output of the test is deterministic (it is equal to <fr:tex display="inline"><![CDATA[ H_{0} ]]></fr:tex> or <fr:tex display="inline"><![CDATA[ H_{1} ]]></fr:tex> with probability 1). Such deterministic tests can be equivalently represented by a function <fr:tex display="inline"><![CDATA[ \Psi  ]]></fr:tex>, or a subset <fr:tex display="inline"><![CDATA[ B ]]></fr:tex> of the domain <fr:tex display="inline"><![CDATA[ X ]]></fr:tex>:

<fr:tex display="block"><![CDATA[ \Psi (X)=\mathbf {1}_{B}(X)=\begin {cases}1,&\text {if}X\in  B\\ 0,&\text {if}X\not \in  B.\end {cases} ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006B/</fr:uri><fr:display-uri>006B</fr:display-uri><fr:route>/006B/</fr:route><fr:title text="Hypothesis error">Hypothesis error</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
In any binary hypothesis testing problem, a test <fr:tex display="inline"><![CDATA[ P_{Z|X|} ]]></fr:tex> can incur two types of errors:
<fr:tex display="block"><![CDATA[\begin {align*}
   \pi _{1|0}(P_{Z|X})&=\mathbb {P}_{H_{0}}\ (Z=1) \quad  \text {(type-I error of false alarm rate)} \\
 \pi _{01}(P_{Z|X})&=\mathbb {P}_{H_{1}}\ (Z=0) \quad   \text {(type-II error or missed detection rate)}
.\end {align*}]]></fr:tex></html:p></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Notions of optimality"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Notions of optimality</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006C/</fr:uri><fr:display-uri>006C</fr:display-uri><fr:route>/006C/</fr:route><fr:title text="Neyman-Pearson Framework">Neyman-Pearson Framework</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Given <fr:tex display="inline"><![CDATA[\alpha  \in  (0,1)]]></fr:tex>. The optimal hypothesis test in the <html:em>Neyman-Pearson</html:em> framework is one that satisfies
<fr:tex display="block"><![CDATA[\operatorname *{min}_{P_{Z\mid  X}}\;\mathbb {P}_{H_{1}}\left (Z=0\right ),\quad \mathrm {subject\,to}\quad \mathbb {P}_{H_{0}}\left (Z=1\right )\leq \alpha .]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006D/</fr:uri><fr:display-uri>006D</fr:display-uri><fr:route>/006D/</fr:route><fr:title text="Bayesian Framework">Bayesian Framework</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Assume we have prior distributions <fr:tex display="inline"><![CDATA[(\pi _{0}, \pi _{1})]]></fr:tex> over the two hypotheses and there exists costs <fr:tex display="inline"><![CDATA[C_{1|0}]]></fr:tex>, <fr:tex display="inline"><![CDATA[C_{0|1}]]></fr:tex> associated with <fr:link href="/006B/" title="Hypothesis error" uri="https://kellenkanarios.com/006B/" display-uri="006B" type="local">type I and type II error</fr:link> respectively. Then the Bayes optimal solution is the solution of 
<fr:tex display="block"><![CDATA[ \operatorname *{min}_{P_{Z|X}}\pi _{0}C_{1|0}\mathbb {P}_{H_{0}}(Z=1)+\pi _{1}C_{0|1}\mathbb {P}_{H_{1}}(Z=0). ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006E/</fr:uri><fr:display-uri>006E</fr:display-uri><fr:route>/006E/</fr:route><fr:title text="Minimax Optimal">Minimax Optimal</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Find a test that minimzes the maximum of the <fr:link href="/006B/" title="Hypothesis error" uri="https://kellenkanarios.com/006B/" display-uri="006B" type="local">two errors</fr:link> i.e. 
<fr:tex display="block"><![CDATA[ \operatorname *{min}_{P_{Z|X}}\operatorname *{max}\left \{\mathbb {P}_{H_{0}}(Z=1),\ \mathbb {P}_{H_{1}}(Z=0)\right \}=\operatorname *{min}_{P_{Z|X}}\operatorname *{max}\left \{\pi _{1|0}(P_{Z|X}),\ \pi _{0|1}(P_{Z|X})\right \}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Optimal NP Test"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Optimal NP Test</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>25</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0068/</fr:uri><fr:display-uri>0068</fr:display-uri><fr:route>/0068/</fr:route><fr:title text="Optimal NP Test">Optimal NP Test</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Consider a hypothesis testing problem with observations <fr:tex display="inline"><![CDATA[ X^{n}\stackrel {\text {i.i.d.}}{\sim }P_{X} ]]></fr:tex>, with the null <fr:tex display="inline"><![CDATA[ H_{0} : P_{X} =P_{0} ]]></fr:tex> and alternative <fr:tex display="inline"><![CDATA[ H_{1}:P_{X}=P_{1} ]]></fr:tex>. Then, the optimal NP test with level <fr:tex display="inline"><![CDATA[ \alpha \in  (0,1] ]]></fr:tex> has the following structure:

<fr:tex display="block"><![CDATA[ \Psi _{NP}^{*}(X^{n})=\begin {cases}1,&\text { if }L(X^{n})>\tau \\ \gamma ,&\text { if }L(X^{n})=\tau \\ 0,&\text { if }L(X^{n})<\tau .\end {cases} ]]></fr:tex>

In the above display, <fr:tex display="inline"><![CDATA[ L(X^{n}) ]]></fr:tex> denotes the likelihood ratio <fr:tex display="inline"><![CDATA[ p_{1}(X^{n})/p_{0}(X^{n}) ]]></fr:tex>, and <fr:tex display="inline"><![CDATA[ \gamma \in [0,1] ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ \tau \geq 0 ]]></fr:tex> are constants that ensure <fr:tex display="inline"><![CDATA[ \pi _{1|0}(\Psi ^*_{NP})=\mathbb {P}_{H_{0}}(\Psi ^*_{NP}(X^{n})=1)=\alpha  ]]></fr:tex>. Namely, 
<fr:tex display="block"><![CDATA[\tau  = \inf \{\tau  \mid  \alpha  \geq  \mathbb {P}(L(X^n) > \tau )\}]]></fr:tex> and <fr:tex display="block"><![CDATA[\gamma  = \frac {\alpha  - \mathbb {P}(L(X^n) > \tau )}{\mathbb {P}(L(X^n) = \tau )}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006F/</fr:uri><fr:display-uri>006F</fr:display-uri><fr:route>/006F/</fr:route><fr:title text="Optimal Bayesian Test">Optimal Bayesian Test</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ X^{n}\stackrel {{i.i.d.}}{{\sim }}P_{X} ]]></fr:tex>, and consider a binary hypothesis testing problem with <fr:tex display="inline"><![CDATA[ H_{0}:P_{X}=P_{0} ]]></fr:tex> versus <fr:tex display="inline"><![CDATA[ H_{1}:P_{X}=P_{1}. ]]></fr:tex> Let <fr:tex display="inline"><![CDATA[ (\pi _{0},\pi _{1}) ]]></fr:tex> denote the prior distribution of the two hypotheses being true. Then, the Bayes optimal hypothesis test with uniform loss is defined as

<fr:tex display="block"><![CDATA[ \Psi _{D}^{*}(X^{n})=\operatorname *{argmin}_{\Psi }\pi _{0}\pi _{10}(\Psi )+\pi _{1}\pi _{01}(\Psi )=\begin {cases}1&\text { if }L(X^{n})>\pi _{0}/\pi _{1}\\ 0&\text {otherwise.}\end {cases}, ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Error Exponents in Hypothesis Testing"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Error Exponents in Hypothesis Testing</fr:title></fr:frontmatter><fr:mainmatter>
In the previous section, we consider the optimal test in the non-asymptotic regime i.e. for finite <fr:tex display="inline"><![CDATA[n]]></fr:tex> what test minimizes the error according to some notion of error. In this section, we ask the question of what is the rate that this error converges to <fr:tex display="inline"><![CDATA[0]]></fr:tex>. More specifically, if <fr:tex display="inline"><![CDATA[\text {error}_n \leq  2^{-nV}]]></fr:tex> then what is the best (largest) <fr:tex display="inline"><![CDATA[V]]></fr:tex> we can hope to achieve?

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › NP Error Exponent"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › NP Error Exponent</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006G/</fr:uri><fr:display-uri>006G</fr:display-uri><fr:route>/006G/</fr:route><fr:title text="Optimal Error Exponent in NP setting">Optimal Error Exponent in NP setting</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say that an error exponent <fr:tex display="inline"><![CDATA[ V ]]></fr:tex> is achievable with type-1 error <fr:tex display="inline"><![CDATA[ \alpha >0 ]]></fr:tex>, if there exist a sequence of tests <fr:tex display="inline"><![CDATA[ (\Psi _{n}) ]]></fr:tex> with errors <fr:tex display="inline"><![CDATA[ (\alpha _{n},\beta _{n}) ]]></fr:tex>, satisfying

<fr:tex display="block"><![CDATA[ \alpha _{n}\leq \alpha ,\quad \text {and}\quad -\frac {1}{n}\log \beta _{n}\geq  V. ]]></fr:tex>

Let <fr:tex display="inline"><![CDATA[ V_{\alpha }:=\sup \{V:V\text { is achievable with type-1 error }\alpha \} ]]></fr:tex>. The optimal error exponent is defined as <fr:tex display="inline"><![CDATA[ V^{*}=\inf \{V_{\alpha }:\alpha >0\}=\lim _{\alpha \downarrow 0}V_{\alpha } ]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006H/</fr:uri><fr:display-uri>006H</fr:display-uri><fr:route>/006H/</fr:route><fr:title text="Stein's Lemma">Stein's Lemma</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

For any <fr:tex display="inline"><![CDATA[ \alpha >0 ]]></fr:tex>, we have <fr:tex display="inline"><![CDATA[ V_{\alpha }=D_{KL}(P_{0}\parallel  P_{1}) ]]></fr:tex>, which also implies that <fr:tex display="inline"><![CDATA[ V^{*}=D_{KL}(P_{0}\parallel  P_{1}) ]]></fr:tex>. In other words, the relative entropy between <fr:tex display="inline"><![CDATA[ P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ P_{1} ]]></fr:tex> is the optimal type-II error exponent associated with a binary hypothesis testing problem with <fr:tex display="inline"><![CDATA[ H_{0}:P_{X}=P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ H_{1}:P_{X}=P_{1} ]]></fr:tex>.

  </html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Bayesian Error Exponent"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Bayesian Error Exponent</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006I/</fr:uri><fr:display-uri>006I</fr:display-uri><fr:route>/006I/</fr:route><fr:title text="Optimal Bayesian Error Exponent">Optimal Bayesian Error Exponent</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>

Consider a binary Bayesian hypothesis testing problem with prior distribution <fr:tex display="inline"><![CDATA[ (\pi _{0},\pi _{1}) ]]></fr:tex>. Then, we say that an exponent <fr:tex display="inline"><![CDATA[ V>0 ]]></fr:tex> is achievable, if there exist a sequence of tests <fr:tex display="inline"><![CDATA[ \{\Psi _{n}:n\geq 1\} ]]></fr:tex>, with probability of errors <fr:tex display="inline"><![CDATA[ \{p_{n}(\Psi _{n})=\pi _{0}\psi _{0}(\Psi _{n})+\pi _{1}\psi _{01}(\Psi _{n}):n\geq 1\} ]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[ \liminf _{n\to \infty }\frac {1}{n}\log \left (\frac {1}{p_{n}}\right )=\liminf _{n\to \infty }\frac {1}{n}\log \left (\frac {1}{\pi _{0}\psi _{10}(\Psi _{n})+\pi _{1}\psi _{01}(\Psi _{n})}\right )\geq  V. ]]></fr:tex>

The optimal Bayesian error exponent for binary hypothesis testing with distributions <fr:tex display="inline"><![CDATA[ P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ P_{1} ]]></fr:tex> is defined as <fr:tex display="inline"><![CDATA[ V^{*}\equiv  V^{*}(P_{0},P_{1})=\sup \{V>0:V\text {is achievable}\} ]]></fr:tex>.

  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006J/</fr:uri><fr:display-uri>006J</fr:display-uri><fr:route>/006J/</fr:route><fr:title text="Optimal Bayesian Error Exponent">Optimal Bayesian Error Exponent</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For any <fr:tex display="inline"><![CDATA[ \lambda \in [0,1] ]]></fr:tex> let <fr:tex display="inline"><![CDATA[ P_{\lambda } ]]></fr:tex> denote the distribution over <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> such that <fr:tex display="inline"><![CDATA[ P_{\lambda }(x)\propto  P_{0}^{\lambda }(x)\times  P_{1}^{\lambda -1}(x) ]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[ \lambda ^{*}\in [0,1] ]]></fr:tex> denote the value at which <fr:tex display="inline"><![CDATA[ D_{KL}(P_{\lambda ^{*}}\parallel  P_{0})=D_{KL}(P_{\lambda ^{*}}\parallel  P_{1}) ]]></fr:tex>. Then, the optimal error exponent in the Bayesian hypothesis testing problem with distributions <fr:tex display="inline"><![CDATA[ P_{0} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ P_{1} ]]></fr:tex> satisfies:

<fr:tex display="block"><![CDATA[ V^{*}(P_{0},P_{1})=D_{KL}(P_{\lambda ^{*}}\parallel  P_{0})=D_{KL}(P_{\lambda ^{*}}\parallel  P_{1}). ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Fixed-Rate Universal Source Coding">Fixed-Rate Universal Source Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006K/</fr:uri><fr:display-uri>006K</fr:display-uri><fr:route>/006K/</fr:route><fr:title text="Fixed rate universal code">Fixed rate universal code</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  
A sequence of fixed-rate source codes <fr:tex display="inline"><![CDATA[ \{(e_{n},f_{n}):n \geq  1\} ]]></fr:tex> with parameters <fr:tex display="inline"><![CDATA[ \{(n,2^{nR_{n}}):n \geq  1\} ]]></fr:tex> is said to be universal with rate <fr:tex display="inline"><![CDATA[ R ]]></fr:tex> if the following are true:
<html:ol><html:li>
The limiting rate satisfies <fr:tex display="inline"><![CDATA[ \lim _{n\to \infty }R_{n}\leq  R ]]></fr:tex>.
    </html:li>
  <html:li>
For any distribution <fr:tex display="inline"><![CDATA[ P ]]></fr:tex> over the alphabet <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> with <fr:tex display="inline"><![CDATA[ H(P)<R ]]></fr:tex>, the probability of error, <fr:tex display="inline"><![CDATA[ \mathbb {P}_{X^{n}\sim  P^{n}} \left (f_{n}(e_{n}(X^{n})) \neq  X^{n}\right )=0]]></fr:tex>.</html:li></html:ol></html:p></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Construction of universal fixed rated code"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Construction of universal fixed rated code</fr:title></fr:frontmatter><fr:mainmatter>
    To construct, a universal fixed rate code, we need a code that satisfies (i) and (ii) from <fr:link href="/006K/" title="Fixed rate universal code" uri="https://kellenkanarios.com/006K/" display-uri="006K" type="local">Fixed rate universal code</fr:link>. 
    <html:ul><html:li>
Let <fr:tex display="inline"><![CDATA[ |\mathcal {X}|=m ]]></fr:tex>, and for any <fr:tex display="inline"><![CDATA[ n\geq 1 ]]></fr:tex> and a given <fr:tex display="inline"><![CDATA[ R>0 ]]></fr:tex>, define <fr:tex display="inline"><![CDATA[ R_n=R-m \frac {\log  n+1}{n}]]></fr:tex></html:li>
      <html:li>Consider the subset <fr:tex display="inline"><![CDATA[A_n \subset  \mathcal {X}^n]]></fr:tex>, defined as <fr:tex display="block"><![CDATA[A_n = \{x^n \in  \mathcal {X}^n \mid  H(\hat {P}_{x^n} \leq  R_n)\}  ]]></fr:tex></html:li>
      <html:li>Then just define the encoder in the usual way i.e. for encoder <fr:tex display="inline"><![CDATA[e_n]]></fr:tex> give every <fr:tex display="inline"><![CDATA[x^n \in  A_n]]></fr:tex> a unique code and everything else map to the same code.</html:li>
      <html:li>Then the decoder can easily identify everything in <fr:tex display="inline"><![CDATA[A_n]]></fr:tex> and it suffices to show that in the limit the probabilities concentrate around <fr:tex display="inline"><![CDATA[A_n]]></fr:tex>.</html:li></html:ul>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006L/</fr:uri><fr:display-uri>006L</fr:display-uri><fr:route>/006L/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The code constructed above is a universal fixed-rate code, such that <fr:tex display="inline"><![CDATA[ \lim _{n\to \infty }\mathbb {P}_{X^{n}\sim  P^{n}}(f_{n}(e_{n}(X^{n}))\neq  X^{n})=0 ]]></fr:tex> for all <fr:tex display="inline"><![CDATA[ P ]]></fr:tex> with <fr:tex display="inline"><![CDATA[ H(P)<R ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Variable-Rate Universal Source Coding">Variable-Rate Universal Source Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006M/</fr:uri><fr:display-uri>006M</fr:display-uri><fr:route>/006M/</fr:route><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose <fr:tex display="inline"><![CDATA[ X\sim  Q ]]></fr:tex>, but we encode it using an optimal code for <fr:tex display="inline"><![CDATA[ P ]]></fr:tex>. Then, the redundancy incurred is approximately equal to <fr:tex display="inline"><![CDATA[ D_{KL}(Q\parallel  P) ]]></fr:tex>.
  </html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
  We know that the optimal codeword for <fr:tex display="inline"><![CDATA[ P ]]></fr:tex> has lengths approximately equal to <fr:tex display="inline"><![CDATA[ \ell _{P}(x)\approx \log (1/p(x)) ]]></fr:tex>, where <fr:tex display="inline"><![CDATA[ p ]]></fr:tex> denotes the pmf of <fr:tex display="inline"><![CDATA[ P ]]></fr:tex>. Whereas the optimal codeword for <fr:tex display="inline"><![CDATA[ Q ]]></fr:tex> assigns lengths <fr:tex display="inline"><![CDATA[ \ell _{Q}(x)\approx \log (1/q(x)) ]]></fr:tex>. Then, the redundancy is

<fr:tex display="block"><![CDATA[
\begin {align*}
 \mathcal {R}(Q,P)&=\mathbb {E}_{X\sim  Q}[\ell _{P}(X)-\ell _{Q}(X)]\approx \mathbb {E}_{X\sim  Q}[-\log (p(X))+\log (q(X))] \\
&=\mathbb {E}_{X\sim  Q}\left [\log \left (\frac {q(X)}{p(X)}\right )\right ]=D_{\mathrm {KL}}(Q\parallel  P)
.\end {align*}
]]></fr:tex>

  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Redundancy-Capacity Theorem"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Redundancy-Capacity Theorem</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006N/</fr:uri><fr:display-uri>006N</fr:display-uri><fr:route>/006N/</fr:route><fr:title text="Minimax Redundancy">Minimax Redundancy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> denote an alphabet of size <fr:tex display="inline"><![CDATA[ m ]]></fr:tex>, and let <fr:tex display="inline"><![CDATA[ \mathcal {P}=\{P_{1},\ldots ,P_{k}\} ]]></fr:tex> denote a collection of <fr:tex display="inline"><![CDATA[ k ]]></fr:tex> distinct distributions on <fr:tex display="inline"><![CDATA[ \mathcal {X} ]]></fr:tex> (every <fr:tex display="inline"><![CDATA[ P_{i} ]]></fr:tex> can be identified with a pmf in <fr:tex display="inline"><![CDATA[ \Delta _{m} ]]></fr:tex>). Now, consider the following two-player game:
<html:ul><html:li>Player 1, representing adversary, chooses a distribution <fr:tex display="inline"><![CDATA[P]]></fr:tex> from the set <fr:tex display="inline"><![CDATA[\mathcal {P}]]></fr:tex></html:li>
  <html:li>Player 2, representing source coder, constructs a code according to the distribution <fr:tex display="inline"><![CDATA[Q \in  \Delta _m]]></fr:tex> without knowledge of <fr:tex display="inline"><![CDATA[P]]></fr:tex></html:li></html:ul>
The goal of Player 2is to identify a <fr:tex display="inline"><![CDATA[Q]]></fr:tex> that minimizes the worst-case <fr:link href="/006N/" title="Minimax Redundancy" uri="https://kellenkanarios.com/006N/" display-uri="006N" type="local">redundancy</fr:link>
<fr:tex display="block"><![CDATA[{\mathcal {R}}^{*}\equiv {\mathcal {R}}^{*}({\mathcal {P}}):=\operatorname *{min}_{Q\in \Delta _{m}}\operatorname *{max}_{P\in {\mathcal {P}}}{\mathcal {R}}(P,Q)=\operatorname *{min}_{Q\in \Delta _{m}}\operatorname *{max}_{P\in {\mathcal {P}}}D_{\mathrm {KL}}(P\parallel  Q).]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
It will turn out the optimal choice of <fr:tex display="inline"><![CDATA[Q]]></fr:tex> is the centroid associated with the <fr:tex display="inline"><![CDATA[k]]></fr:tex> elements of <fr:tex display="inline"><![CDATA[\mathcal {P}]]></fr:tex>.
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006O/</fr:uri><fr:display-uri>006O</fr:display-uri><fr:route>/006O/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[\mathcal {R}^*(\mathcal {P}) = C(\mathcal {P}) \coloneqq  \sup _{\pi  \in  \Delta _k} I(W; X)]]></fr:tex>, where <fr:tex display="inline"><![CDATA[I(W; X)]]></fr:tex> is the mutual information between <fr:tex display="inline"><![CDATA[W \sim  \mathbf {\pi } ]]></fr:tex> and the output <fr:tex display="inline"><![CDATA[X]]></fr:tex>, with <fr:tex display="inline"><![CDATA[X | (W = i) \sim  P_i]]></fr:tex>. The optimal <fr:tex display="inline"><![CDATA[Q^*]]></fr:tex> is <fr:tex display="inline"><![CDATA[Q_{\pi }^* = \sum _{i = 1}^{k} \pi _i^* P_i]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>3</fr:month><fr:day>30</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006P/</fr:uri><fr:display-uri>006P</fr:display-uri><fr:route>/006P/</fr:route><fr:title text="Lempel-Ziv Algorithm">Lempel-Ziv Algorithm</fr:title></fr:frontmatter><fr:mainmatter><html:p>
    The algorithm proceed as follows:
    <html:ol><html:li>Initalize the dictionary to an empty set</html:li>
      <html:li>Make one pass through the stream of data</html:li>
      <html:li>Add every new "phrase" to the dictionary</html:li>
      <html:li>Encode only the elements of the dictionary</html:li></html:ol></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Channel Coding">Channel Coding</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006S/</fr:uri><fr:display-uri>006S</fr:display-uri><fr:route>/006S/</fr:route><fr:title text="Channel coding problem">Channel coding problem</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A code with parameter <fr:tex display="inline"><![CDATA[(M, n)]]></fr:tex> i.e. (number of messages, number of channel users) consists of an encoder decoder pair
<html:ul><html:li><fr:tex display="inline"><![CDATA[e : [M] \to  \mathcal {X}^n]]></fr:tex></html:li>
    <html:li><fr:tex display="inline"><![CDATA[f: \mathcal {Y}^n \to  [M]]]></fr:tex></html:li>
    <html:li>
The rate is <fr:tex display="inline"><![CDATA[\log _{2}\frac {M}{n} = ]]></fr:tex> (log of the number of distinct pairs)/(number of channel users)
        </html:li>
        <html:li><fr:tex display="inline"><![CDATA[P_{e, \text {max}} = \max _{1 \leq  i \leq  m}\mathbb {P}(f(Y^n) \neq  i \mid  W = i)]]></fr:tex> - worst case over all transmitted messages prob of error.
            </html:li>
            <html:li><fr:tex display="inline"><![CDATA[P_{e} = \frac {1}{M}\sum _{i = 1}^{M} \mathbb {P}(f(Y^n) \neq  i \mid  W = i)]]></fr:tex> - average prob of error.
</html:li></html:ul></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006T/</fr:uri><fr:display-uri>006T</fr:display-uri><fr:route>/006T/</fr:route><fr:title text="Discrete memoryless channel">Discrete memoryless channel</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    We have the following components
    <html:ul><html:li><fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> - input alphabet <fr:tex display="inline"><![CDATA[|\mathcal {X}| < \infty ]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> - output alphabet <fr:tex display="inline"><![CDATA[|\mathcal {Y}| < \infty ]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[P_{Y|X}]]></fr:tex> - transition prob matrix</html:li></html:ul></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006U/</fr:uri><fr:display-uri>006U</fr:display-uri><fr:route>/006U/</fr:route><fr:title text="Achievable rates">Achievable rates</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A rate <fr:tex display="inline"><![CDATA[R \geq  0]]></fr:tex> is achievable if
<html:ol><html:li><fr:tex display="inline"><![CDATA[\lim _{n\to \infty } P_{e, \text {max}} = 0]]></fr:tex></html:li>
  <html:li><fr:tex display="inline"><![CDATA[\lim _{n \to  \infty } \frac {\log _{2}M_n}{n} = R]]></fr:tex></html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006V/</fr:uri><fr:display-uri>006V</fr:display-uri><fr:route>/006V/</fr:route><fr:title text="Channel capacity">Channel capacity</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The channel capacity is the maximum <fr:link href="/006U/" title="Achievable rates" uri="https://kellenkanarios.com/006U/" display-uri="006U" type="local">achievable rate</fr:link> i.e. 
<fr:tex display="block"><![CDATA[C = \sup  \{R \geq  0 \mid  R \text { is achievable}\}  ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
    We make the following simplifying assumptions (for now)
    <html:ul><html:li>
We assume no feedback. This means that if we have <fr:tex display="inline"><![CDATA[W \to  X_{1} \to  Y_{1} \to  X_{2} \to  \cdots ]]></fr:tex> then <fr:tex display="inline"><![CDATA[X_i]]></fr:tex> does not use the knowledge of previous channel outputs i.e. <fr:tex display="inline"><![CDATA[Y^{i - 1} \leftrightarrow  (W, X^{i - 1}) \leftrightarrow  X_i]]></fr:tex>.
            </html:li>
            <html:li>
Random encoding: <fr:tex display="inline"><![CDATA[X^n(i)]]></fr:tex> is drawn i.i.d from some specified distribution <fr:tex display="inline"><![CDATA[P_X]]></fr:tex>.
                </html:li></html:ul>
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006W/</fr:uri><fr:display-uri>006W</fr:display-uri><fr:route>/006W/</fr:route><fr:title text="Information channel capacity">Information channel capacity</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The information channel capacity  of a <fr:link href="/006T/" title="Discrete memoryless channel" uri="https://kellenkanarios.com/006T/" display-uri="006T" type="local">DMC</fr:link> <fr:tex display="inline"><![CDATA[(\mathcal {X}, \mathcal {Y}, P_{Y|X})]]></fr:tex> is defined as
<fr:tex display="block"><![CDATA[C(P_{Y|X}) = \max _{P_X}I(X; Y)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006X/</fr:uri><fr:display-uri>006X</fr:display-uri><fr:route>/006X/</fr:route><fr:title text="Shannon's coding theorem">Shannon's coding theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Non rigorous: says that <fr:link href="/006V/" title="Channel capacity" uri="https://kellenkanarios.com/006V/" display-uri="006V" type="local">channel capacity</fr:link> and <fr:link href="/006W/" title="Information channel capacity" uri="https://kellenkanarios.com/006W/" display-uri="006W" type="local">information channel capacity</fr:link> are equal.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>1</fr:day></fr:date><fr:uri>https://kellenkanarios.com/006Y/</fr:uri><fr:display-uri>006Y</fr:display-uri><fr:route>/006Y/</fr:route><fr:title text="Symmetric Channels">Symmetric Channels</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A channel is symmetric if
<html:ol><html:li>each row is a permutation of the first row</html:li> 
  <html:li>
  each column is a permutation of the first column
    </html:li></html:ol>
 It is weakly symmetric if it satisfies <fr:tex display="inline"><![CDATA[1]]></fr:tex> but the columns only sum to the same value.
</html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
The capacity of a <fr:link href="/006Y/" title="Symmetric Channels" uri="https://kellenkanarios.com/006Y/" display-uri="006Y" type="local">symmetric or weakly symmetric</fr:link> channel is <fr:tex display="inline"><![CDATA[\log (|\mathcal {Y}|) - H(r)]]></fr:tex>, where <fr:tex display="inline"><![CDATA[r]]></fr:tex> is the first row of <fr:tex display="inline"><![CDATA[P_{Y|X}]]></fr:tex>.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Channel Coding">Channel Coding</fr:title></fr:frontmatter><fr:mainmatter>
    <html:p>We have three components to the channel coding problem:</html:p>
    <html:ol><html:li>Channel encoder</html:li>
      <html:li>Noisy channel</html:li>
      <html:li>Channel decoder</html:li></html:ol>
    <html:p>We first pass <fr:tex display="inline"><![CDATA[W]]></fr:tex> to the channel encoder get some <fr:tex display="inline"><![CDATA[X^n]]></fr:tex> which goes into noisy channel and becomes <fr:tex display="inline"><![CDATA[Y^n]]></fr:tex>. Then the goal is for the channel decoder to recover <fr:tex display="inline"><![CDATA[W]]></fr:tex> from <fr:tex display="inline"><![CDATA[Y^n]]></fr:tex>. This means that the goal of the encoder is to reduce redundancy while also ensuring that there is no overlap when passed through the noisy channel.</html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0070/</fr:uri><fr:display-uri>0070</fr:display-uri><fr:route>/0070/</fr:route><fr:title text="General definition of channel">General definition of channel</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A channel (with memory) is a sequence of conditional distributions:_

<fr:tex display="block"><![CDATA[ P_{Y_{1}|X_{1}},P_{Y_{2}|Y_{1},X^{2}},P_{Y_{3}|Y^{2},X^{3}},\ldots ,P_{Y_{n}|Y^{n-1},X^{n}}, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ P_{Y_{n}|Y^{n-1},X^{n}} ]]></fr:tex> is a collection of distributions on <fr:tex display="inline"><![CDATA[ \mathcal {Y} ]]></fr:tex> one for every <fr:tex display="inline"><![CDATA[ (y^{n-1},x^{n})\in \mathcal {Y}^{n-1}\times \mathcal {X}^{n} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>12</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0071/</fr:uri><fr:display-uri>0071</fr:display-uri><fr:route>/0071/</fr:route><fr:title text="Encoder">Encoder</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
An encoder (with feedback) with parameter <fr:tex display="inline"><![CDATA[ (n,\Theta ) ]]></fr:tex> for a channel is a vector of mappings <fr:tex display="inline"><![CDATA[ e_{i} ]]></fr:tex> for <fr:tex display="inline"><![CDATA[ i=1,2,\ldots ,n ]]></fr:tex>, where

<fr:tex display="block"><![CDATA[ e_{i}:\{1,2,\ldots ,\Theta \}\times \mathcal {Y}^{i-1}\to \mathcal {X}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
We can decompose the joint distribution <fr:tex display="inline"><![CDATA[P_{X^n, Y^n}]]></fr:tex> in terms of the what depends on the channel and the what depends on the encoder. Namely,
<fr:tex display="block"><![CDATA[P_{X^n, Y^n} = \prod _{i=1}^{n} P_{X_i | X^{i - 1}, Y^{i - 1}} \prod _{i=1}^{n}  P_{Y_i | X^{i}, Y^{i - 1}}]]></fr:tex>
Note that the first term depends only on the encoder and the second term depends only on the channel.
</fr:mainmatter></fr:tree>

<html:p><html:ul><html:strong>Assumptions:</html:strong>
  <html:li>The encoder is a deterministic function of <fr:tex display="inline"><![CDATA[\mathbf {W}]]></fr:tex></html:li>
  <html:li>The channel does not have access to the message <fr:tex display="inline"><![CDATA[\mathbf {W}]]></fr:tex>.</html:li></html:ul></html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Differential Entropy">Differential Entropy</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007C/</fr:uri><fr:display-uri>007C</fr:display-uri><fr:route>/007C/</fr:route><fr:title text="Differential Entropy">Differential Entropy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The differential entropy <fr:tex display="inline"><![CDATA[ h(X) ]]></fr:tex> of a continuous random variable <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> with density <fr:tex display="inline"><![CDATA[ f(x) ]]></fr:tex> is defined as

<fr:tex display="block"><![CDATA[ h(X)=-\int _{S}f(x)\log  f(x)\,dx, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ S ]]></fr:tex> is the support set of the random variable.
</html:p></fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › AEP for Continuous Random Variables"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › AEP for Continuous Random Variables</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007E/</fr:uri><fr:display-uri>007E</fr:display-uri><fr:route>/007E/</fr:route><fr:title text="Typical Set for Continuous Random Variables">Typical Set for Continuous Random Variables</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For <fr:tex display="inline"><![CDATA[ \epsilon >0 ]]></fr:tex> and any <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>, we define the typical set <fr:tex display="inline"><![CDATA[ A_{\epsilon }^{(n)} ]]></fr:tex> with respect to <fr:tex display="inline"><![CDATA[ f(x) ]]></fr:tex> as follows:

<fr:tex display="block"><![CDATA[ A_{\epsilon }^{(n)}=\left \{(x_{1},x_{2},\ldots ,x_{n})\in  S^{n}:\left |-\frac {1}{n}\log  f(x_{1},x_{2},\ldots ,x_{n})-h(X)\right |\leq \epsilon \right \}, ]]></fr:tex>

where <fr:tex display="inline"><![CDATA[ f(x_{1},x_{2},\ldots ,x_{n})=\prod _{i=1}^{n}f(x_{i}) ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007D/</fr:uri><fr:display-uri>007D</fr:display-uri><fr:route>/007D/</fr:route><fr:title text="Volume of set">Volume of set</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
 The volume Vol(<fr:tex display="inline"><![CDATA[ A ]]></fr:tex>) of a set <fr:tex display="inline"><![CDATA[ A\subset \mathcal {R}^{n} ]]></fr:tex> is defined as
<fr:tex display="block"><![CDATA[ \text {Vol}(A)=\int _{A}dx_{1}\,dx_{2}\,\cdots \,dx_{n}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007F/</fr:uri><fr:display-uri>007F</fr:display-uri><fr:route>/007F/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The typical set <fr:tex display="inline"><![CDATA[ A_{\epsilon }^{(n)} ]]></fr:tex> has the following properties:

<html:ol><html:li><fr:tex display="inline"><![CDATA[ \Pr \left (A_{\epsilon }^{(n)}\right )>1-\epsilon  ]]></fr:tex> for <fr:tex display="inline"><![CDATA[ n ]]></fr:tex> sufficiently large.
    </html:li>
  <html:li><fr:tex display="inline"><![CDATA[ \mathrm {Vol}\left (A_{\epsilon }^{(n)}\right )\leq 2^{n(h(X)+\epsilon )} ]]></fr:tex> for all <fr:tex display="inline"><![CDATA[ n ]]></fr:tex>.
    </html:li>
  <html:li><fr:tex display="inline"><![CDATA[ \mathrm {Vol}\left (A_{\epsilon }^{(n)}\right )\geq (1-\epsilon )2^{n(h(X)-\epsilon )} ]]></fr:tex> for <fr:tex display="inline"><![CDATA[ n ]]></fr:tex> sufficiently large.
    </html:li></html:ol></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Notebook: Information Theory › Discrete Approximation"><fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">Notebook: Information Theory</fr:link> › Discrete Approximation</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007G/</fr:uri><fr:display-uri>007G</fr:display-uri><fr:route>/007G/</fr:route><fr:title text="Discrete Approximation of Differential Entropy">Discrete Approximation of Differential Entropy</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    For,
    <fr:tex display="block"><![CDATA[ p_{i}=\int _{i\,\Delta }^{(i+1)\,\Delta }f(x)\,d x=f(x_{i})\Delta \,. ]]></fr:tex>
    We define the discrete approximation of the differential entropy as
    <fr:tex display="block"><![CDATA[\begin {align*}
H(X^{\Delta })&\coloneqq  -\sum _{-\infty }^{\infty }p_{i}\log  p_{i} \\
&=-\sum _{-\infty }^{\infty }f(x_{i})\Delta \log (f(x_{i})\Delta ) \\ 
&=-\sum \Delta  f(x_{i})\log  f(x_{i})-\sum  f(x_{i})\Delta \log \Delta  \\ 
&=-\sum \Delta  f(x_{i})\log  f(x_{i})-\log \Delta ,
    .\end {align*}]]></fr:tex></html:p></fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
Taking <fr:tex display="inline"><![CDATA[\Delta  = 2^{-n}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[X^{\Delta }]]></fr:tex> is an "<fr:tex display="inline"><![CDATA[n]]></fr:tex>-bit" approximation of <fr:tex display="inline"><![CDATA[X]]></fr:tex>.
</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>22</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007H/</fr:uri><fr:display-uri>007H</fr:display-uri><fr:route>/007H/</fr:route><fr:title text="Information dimension">Information dimension</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> be any real valued random variable, and let <fr:tex display="inline"><![CDATA[ X^{(1/n)} ]]></fr:tex> denote the discretization of <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> with parameter <fr:tex display="inline"><![CDATA[ \Delta =1/n ]]></fr:tex>. Then, the information dimension associated with <fr:tex display="inline"><![CDATA[ X ]]></fr:tex> is defined as

<fr:tex display="block"><![CDATA[ d=\lim _{n\to \infty }\frac {H(X^{(1/n)})}{\log  n}, ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Gaussian Channel">Gaussian Channel</fr:title></fr:frontmatter><fr:mainmatter>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2025</fr:year>
          <fr:month>1</fr:month>
          <fr:day>26</fr:day>
        </fr:date>
        <fr:uri>https://kellenkanarios.com/0033/</fr:uri>
        <fr:display-uri>0033</fr:display-uri>
        <fr:route>/0033/</fr:route>
        <fr:title text="Notebook: Optimization Theory">Notebook: Optimization Theory</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Convex Optimization Background">Convex Optimization Background</fr:title></fr:frontmatter><fr:mainmatter>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0034/</fr:uri><fr:display-uri>0034</fr:display-uri><fr:route>/0034/</fr:route><fr:title text="First-order condition">First-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f]]></fr:tex> is first-order continuously differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex iff
<fr:tex display="block"><![CDATA[f(\boldsymbol {y}) \geq  f(\boldsymbol {x}) + \langle  \nabla  f(\boldsymbol {x}), \boldsymbol {y} - \boldsymbol {x}
\rangle ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0035/</fr:uri><fr:display-uri>0035</fr:display-uri><fr:route>/0035/</fr:route><fr:title text="Second-order condition">Second-order condition</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is twice-differentiable, then <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex if and only if <fr:tex display="inline"><![CDATA[\nabla ^2 f(\boldsymbol {x}) \succeq  0]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER0/</fr:uri><fr:display-uri>DER0</fr:display-uri><fr:route>/DER0/</fr:route><fr:title text="Operations that preserve convexity">Operations that preserve convexity</fr:title></fr:frontmatter><fr:mainmatter><html:p>The following operations preserve <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">convexity</fr:link></html:p><html:ul><html:li><html:strong>Nonnegative weighted sums:</html:strong> if <fr:tex display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex and <fr:tex display="inline"><![CDATA[\alpha _1, \ldots , \alpha _n > 0]]></fr:tex> then we have <fr:tex display="inline"><![CDATA[f(\boldsymbol {x}) = \sum _{i = 1}^{n} \alpha _i f_i(\boldsymbol {x})]]></fr:tex> is convex</html:li>
    <html:li><html:strong>Pointwise maximum:</html:strong> if <fr:tex display="inline"><![CDATA[f_1, \ldots , f_n]]></fr:tex> are convex then <fr:tex display="inline"><![CDATA[f(\boldsymbol {x}) = \max _i \{f_i(\boldsymbol {x})\}]]></fr:tex> is convex </html:li></html:ul></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0036/</fr:uri><fr:display-uri>0036</fr:display-uri><fr:route>/0036/</fr:route><fr:title text="Strong convexity">Strong convexity</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A function <fr:tex display="inline"><![CDATA[f]]></fr:tex> is <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex if and only if 
<fr:tex display="block"><![CDATA[g(\boldsymbol {x}) = f(\boldsymbol {x}) - \frac {\mu }{2} ||\boldsymbol {x}||_2^2]]></fr:tex>
is convex, <fr:tex display="inline"><![CDATA[\forall  \boldsymbol {x} \in  \mathrm {dom} f]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0037/</fr:uri><fr:display-uri>0037</fr:display-uri><fr:route>/0037/</fr:route><fr:title text="Smooth Problem">Smooth Problem</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A problem is <html:em>smooth</html:em> if both the objective function and the constraints are differentiable.</html:p></fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0038/</fr:uri><fr:display-uri>0038</fr:display-uri><fr:route>/0038/</fr:route><fr:title text="Subgradient">Subgradient</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> be convex. A <html:em>subgradient</html:em> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> at <fr:tex display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex> is any <fr:tex display="inline"><![CDATA[\boldsymbol {u}]]></fr:tex> satisfying
<fr:tex display="block"><![CDATA[f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle ]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0039/</fr:uri><fr:display-uri>0039</fr:display-uri><fr:route>/0039/</fr:route><fr:title text="Subdifferential">Subdifferential</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The <html:em>subdifferential</html:em> is the set of all <fr:link href="/0038/" title="Subgradient" uri="https://kellenkanarios.com/0038/" display-uri="0038" type="local">subgradient's</fr:link> of <fr:tex display="inline"><![CDATA[f]]></fr:tex> at <fr:tex display="inline"><![CDATA[\boldsymbol {x}_0]]></fr:tex>.
<fr:tex display="block"><![CDATA[\partial  f(\boldsymbol {x}_0) \coloneqq  \{\boldsymbol {u} | f(\boldsymbol {x}) \geq  f(\boldsymbol {x}_0) + \langle  \boldsymbol {u}, \boldsymbol {x} - \boldsymbol {x}_0 \rangle  \}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Useful Miscellanous Math Background">Useful Miscellanous Math Background</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
  In this section, we cover many random math facts / tools that come up / are useful in later optimization problems.
  </html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER1/</fr:uri><fr:display-uri>DER1</fr:display-uri><fr:route>/DER1/</fr:route><fr:title text="Basic Matrix Analysis">Basic Matrix Analysis</fr:title></fr:frontmatter><fr:mainmatter><html:ul><html:li><html:strong>Matrix inner product:</html:strong>
<fr:tex display="block"><![CDATA[\langle \mathbf {x},\mathbf {z}\rangle \ =\ \sum _{i=1}^{n}x_{i}z_{i}\quad \Longrightarrow \quad \langle \mathbf {X},\mathbf {Z}\rangle \ :=\ \sum _{i=1}^{m}\sum _{j=1}^{n}X_{i j}Z_{i j}]]></fr:tex></html:li>
    <html:li><html:strong>Matrix trace:</html:strong> <fr:tex display="inline"><![CDATA[{{M}}\in \mathbb {R}^{n\times  n};\ {{\mathrm {tr}}}({{M}}):=\sum _{i=1}^{n}M_{i i}]]></fr:tex>
    <fr:tex display="block"><![CDATA[
      \begin {align*}
      &\langle {\boldsymbol  X},{\boldsymbol  Z}\rangle \ =\ \mathrm {tr}\left ({\boldsymbol  X}^{\top }{\boldsymbol  Z}\right )\ =\ \mathrm {tr}\left ({\boldsymbol  X}{\boldsymbol  Z}^{\top }\right ) \\
    &\operatorname {tr}(\mathbf {A}\mathbf {B})=\operatorname {tr}(\mathbf {B}\mathbf {A})\\
      &\operatorname {tr}(\mathbf {A}_{1}\mathbf {A}_{2}\cdots \mathbf {A}_{n})=\operatorname {tr}(\mathbf {A}_{\pi (1)}\mathbf {A}_{\pi (2)}\cdots \mathbf {A}_{\pi (n)})
      \end {align*}
    ]]></fr:tex>
    Where <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex> is a cyclic permutation on <fr:tex display="inline"><![CDATA[\{1,2,\cdots ,n\}]]></fr:tex></html:li></html:ul><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003A/</fr:uri><fr:display-uri>003A</fr:display-uri><fr:route>/003A/</fr:route><fr:title text="Positive (semi)definiteness">Positive (semi)definiteness</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A <html:em>symmetric</html:em> matrix <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{n\times  n}]]></fr:tex> is <html:em>positive definite</html:em> if <fr:tex display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}>0]]></fr:tex> for all nonzero <fr:tex display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. It is <html:em>positive semidefinite (p.s.d.)</html:em> if <fr:tex display="inline"><![CDATA[\mathbf {x}^{\top }\mathbf {A}\mathbf {x}\geq 0]]></fr:tex> for all <fr:tex display="inline"><![CDATA[\mathbf {x}\in \mathbb {R}^{n}]]></fr:tex>. 
  </html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003B/</fr:uri><fr:display-uri>003B</fr:display-uri><fr:route>/003B/</fr:route><fr:title text="Singular Value Decomposition">Singular Value Decomposition</fr:title><fr:taxon>Fact</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with <fr:tex display="inline"><![CDATA[\operatorname {rank}(\mathbf {A})=r]]></fr:tex>. There exist <fr:tex display="inline"><![CDATA[\sigma _{1}\geq \sigma _{2}\geq \cdots \geq \sigma _{r}>0]]></fr:tex>, and matrices <fr:tex display="block"><![CDATA[\mathbf {U}\in \mathbb {R}^{m\times  r},\ \mathbf {V}\in \mathbb {R}^{n\times  r},]]></fr:tex> with <html:em>orthonormal</html:em> columns <fr:tex display="inline"><![CDATA[(\mathbf {U}^{\top }\mathbf {U}=\mathbf {I},\ \mathbf {V}^{\top }\mathbf {V}=\mathbf {I})]]></fr:tex> such that <fr:tex display="block"><![CDATA[\mathbf {A}\ =\ \mathbf {U}\mathbf {\Sigma }\mathbf {V}^{\top }\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }\,,\quad \mathbf {\Sigma }\ =\ \operatorname {diag}\left (\sigma _{1},\cdots ,\sigma _{r}\right ).]]></fr:tex></html:p><html:p>Relationship between eigen decomposition and SVD
  <html:ul><html:li>The columns of <fr:tex display="inline"><![CDATA[\boldsymbol {V}]]></fr:tex> are eigenvectors of <fr:tex display="inline"><![CDATA[\boldsymbol {A}^T\boldsymbol {A}]]></fr:tex></html:li>
      <html:li>The columns of <fr:tex display="inline"><![CDATA[\boldsymbol {U}]]></fr:tex> are eigenvectors of <fr:tex display="inline"><![CDATA[\boldsymbol {A}\boldsymbol {A}^T]]></fr:tex></html:li>
      <html:li><fr:tex display="inline"><![CDATA[{{\sigma _{i}({\mathbf {A}})}}={\sqrt {\lambda _{i}({{{\mathbf {A}}{\mathbf {A}}^{\mathsf {T}}}})}}={\sqrt {\lambda _{i}({\mathbf {A}}^{\mathsf {T}}{\mathbf {A}})}}]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003C/</fr:uri><fr:display-uri>003C</fr:display-uri><fr:route>/003C/</fr:route><fr:title text="Best rank-r approximation">Best rank-<fr:tex display="inline"><![CDATA[r]]></fr:tex> approximation</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
 Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex> with SVD, <fr:tex display="inline"><![CDATA[\mathbf {A}=\sum _{i=1}^{\min \{m,n\}}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }]]></fr:tex>. Then an optimal solution to the best rank-<fr:tex display="inline"><![CDATA[r]]></fr:tex> approximation problem <fr:tex display="block"><![CDATA[\min _{\mathbf {X}}||\mathbf {X}-\mathbf {A}||_{2}\,,\quad \text {s.t.}\quad \text {rank}(\mathbf {X})\ \leq \ r]]></fr:tex> is the truncated SVD of the following form <fr:tex display="block"><![CDATA[\boxed {\widehat {\mathbf {A}}_{r}\ =\ \sum _{i=1}^{r}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\top }}\,,\ \ \text {if}\ \ \sigma _{r}>\sigma _{r+1}\,,\,\text {it is unique.}]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Suppose <fr:tex display="inline"><![CDATA[m \geq  n]]></fr:tex>, then we observe that
<fr:tex display="block"><![CDATA[\left |\left |{\widehat {\mathbf {A}}}_{r}-{\mathbf {A}}\right |\right |_{2}\;=\;\left |\left |\sum _{i=r+1}^{n}\sigma _{i}\mathbf {u}_{i}\mathbf {v}_{i}^{\mathsf {T}}\right |\right |_{2} \leq  \sigma _{r+1}]]></fr:tex>

Second, to prove our result, we want to show that <fr:tex display="block"><![CDATA[\left |\left |\mathbf {B}_{r}-\mathbf {A}\right |\right |_{2}\ \geq \ \sigma _{r+1},\quad \forall \mathbf {B}_{r}\ \text {with}\ \mathrm {rank}(\mathbf {B}_{r})=r.]]></fr:tex> We suppose <fr:tex display="inline"><![CDATA[\ \mathbf {B}_{r}=\widetilde {\mathbf {U}}\widetilde {\mathbf {V}}^{\top },\quad \widetilde {\mathbf {U}}\in \mathbb {R}^{m\times  r},\ \widetilde {\mathbf {V}}\in \mathbb {R}^{n\times  r}.]]></fr:tex>
Note
<fr:tex display="block"><![CDATA[
\begin {align*}
||\mathbf {B}_r - A||_2^2 &= \sup _{||\boldsymbol {z}||_2 \leq  1} ||(\mathbf {B}_r - \mathbf {A})\mathbf {z}||_2^2 \\
&\geq  ||(\mathbf {B}_r - \mathbf {A})\mathbf {w}||_2^2
\end {align*}
]]></fr:tex>
Since <fr:tex display="inline"><![CDATA[\widetilde {V}]]></fr:tex> has <fr:tex display="inline"><![CDATA[r]]></fr:tex> columns, then there must be a nontrivial linear combination of the first <fr:tex display="inline"><![CDATA[r{+}1]]></fr:tex> columns of <fr:tex display="inline"><![CDATA[V]]></fr:tex>, i.e., <fr:tex display="block"><![CDATA[\mathbf {w}=\gamma _{1}\mathbf {v}_{1}+\cdots +\gamma _{r+1}\mathbf {v}_{r+1}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\widetilde {V}^{\top }\mathbf {w}=\mathbf {0}\,.]]></fr:tex> Wlog, we can scale <fr:tex display="inline"><![CDATA[\left |\left |\mathbf {w}\right |\right |_{2}=1]]></fr:tex> and <fr:tex display="inline"><![CDATA[\,\sum _{i=1}^{r+1}\gamma _{i}^{2}=1]]></fr:tex>
Then 
<fr:tex display="block"><![CDATA[||\mathbf {A}-\mathbf {B}_{k}||_{2}^{2}\geq ||(\mathbf {A}-\mathbf {B}_{k})\,\mathbf {w}||_{2}^{2}=||\mathbf {A}\mathbf {w}||_{2}^{2}=\gamma _{1}^{2}\sigma _{1}^{2}+\cdots +\gamma _{r+1}^{2}\sigma _{r+1}^{2}\geq \sigma _{r+1}^{2}.]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003G/</fr:uri><fr:display-uri>003G</fr:display-uri><fr:route>/003G/</fr:route><fr:title text="Matrix Operator Norm">Matrix Operator Norm</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. If <fr:tex display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{a}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\left |\left |\cdot \right |\right |_{b}]]></fr:tex> are norms on <fr:tex display="inline"><![CDATA[\mathbb {R}^{n}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbb {R}^{m}]]></fr:tex>, we have <fr:tex display="block"><![CDATA[\left |\left |\mathbf {A}\right |\right |_{a\to  b}\ :=\ \sup _{\left |\left |\mathbf {x}\right |\right |_{a}\leq  1}\left |\left |\mathbf {A}\mathbf {x}\right |\right |_{b}.]]></fr:tex>
It satisfies the <html:em>three criteria</html:em> for norm, and is <html:em>submultiplicative</html:em> <fr:tex display="block"><![CDATA[||\boldsymbol {A}\boldsymbol {B}||_{a\to  b}\ \leq \ ||\boldsymbol {A}||_{a\to  b}\cdot  ||\boldsymbol {B}||_{a\to  b};]]></fr:tex>. 
<fr:tex display="block"><![CDATA[||{\cal  A}||_{2\to 2}\;=\;\sigma _{1}({\cal  A})\;\;(\mathrm {{spectral\ norm}},\;\mathrm {{write\ as}}\;||{\cal  A}||\;\;);\;]]></fr:tex>
<fr:tex display="block"><![CDATA[\begin {array}{l}{{||{\boldsymbol {A}}||_{1\to  b}\ =\ \operatorname *{max}_{j=1,\cdots ,n}||{\boldsymbol {A e}}_{j}||_{b}}}\\ {{||{\boldsymbol {A}}||_{a\to \infty }\ =\ \operatorname *{max}_{i=1,\cdots ,m}||{\boldsymbol {e}}_{i}^{*}{\boldsymbol {A}}||_{b}^{*}\,,\ \ ||{\boldsymbol {v}}||_{b}^{*}\ :=\ \operatorname *{sup}_{||{\boldsymbol {u}}||_{b}\leq 1}\langle {\boldsymbol {u}},{\boldsymbol {v}}\rangle \,,}}\end {array}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003H/</fr:uri><fr:display-uri>003H</fr:display-uri><fr:route>/003H/</fr:route><fr:title text="Unitary Invariant Matrix Norm">Unitary Invariant Matrix Norm</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}.]]></fr:tex> We say the matrix norm is unitary invariant if <fr:tex display="block"><![CDATA[\left ||\mathbf {A}\right ||_{\sharp }\ =\ \left ||\mathbf {PAQ}\right ||_{\sharp },\quad \forall \ \mathbf {P}\in  O(m),\ \mathbf {Q}\in  O(n).]]></fr:tex></html:p><html:p>Eg.
  <html:ul><html:li><html:strong>Spectral norm</html:strong> <fr:tex display="block"><![CDATA[||A||_{2 \to  2}=\sigma _{1}(A)=||\sigma (A)||_{\infty }]]></fr:tex></html:li>
    <html:li><html:strong>Frobenius norm</html:strong> <fr:tex display="block"><![CDATA[\left ||\mathbf {A}\right ||_{F}\ =\ \sqrt {\sum _{i=1}^{\min \{m,n\}}\sigma _{i}^{2}(\mathbf {A})}\ =\ \left ||\mathbf {\sigma }(\mathbf {A})\right ||_{2}]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003I/</fr:uri><fr:display-uri>003I</fr:display-uri><fr:route>/003I/</fr:route><fr:title text="Schatten p-norm">Schatten <fr:tex display="inline"><![CDATA[p]]></fr:tex>-norm</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[\mathbf {A}\in \mathbb {R}^{m\times  n}]]></fr:tex>. For any <fr:tex display="inline"><![CDATA[p \in  [1,+\infty ]]]></fr:tex>, the function <fr:tex display="block"><![CDATA[\left ||\mathbf {A}|\right |_{\mathrm {S}_{p}}\,:=\,\left ||\mathbf {\sigma }(\mathbf {A})|\right |_{p}]]></fr:tex> is a norm on <fr:tex display="inline"><![CDATA[\,\mathbb {R}^{m\times  n}]]></fr:tex>. 
</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER2/</fr:uri><fr:display-uri>DER2</fr:display-uri><fr:route>/DER2/</fr:route><fr:title text="Taylor Expansion and Lipschitz Functions">Taylor Expansion and Lipschitz Functions</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003J/</fr:uri><fr:display-uri>003J</fr:display-uri><fr:route>/003J/</fr:route><fr:title text="Lipschitz Continous">Lipschitz Continous</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose that 
<html:ul><html:li><fr:tex display="inline"><![CDATA[f:\mathcal {X}\mapsto \mathcal {Y}]]></fr:tex> with <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {Y}]]></fr:tex> being open sets;</html:li> 
  <html:li><fr:tex display="inline"><![CDATA[||\cdot ||_{\mathcal {X}}]]></fr:tex> and <fr:tex display="inline"><![CDATA[||\cdot ||_{\mathcal {Y}}]]></fr:tex> are norms on <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathcal {Y}]]></fr:tex>, respectively.</html:li></html:ul>
<fr:tex display="inline"><![CDATA[f(\cdot )]]></fr:tex> is Lipschitz continuous over <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> if <fr:tex display="inline"><![CDATA[\exists  L<\infty \,,]]></fr:tex> such that <fr:tex display="block"><![CDATA[||f(\boldsymbol {y})-f(\boldsymbol {x})||_{\mathcal {Y}}\ \leq \ L(\boldsymbol {x})\,||\boldsymbol {y}-\boldsymbol {x}||_{\mathcal {X}}\,,\quad \forall \boldsymbol {x},\ \boldsymbol {y}\in \mathcal {X}.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003K/</fr:uri><fr:display-uri>003K</fr:display-uri><fr:route>/003K/</fr:route><fr:title text="Smooth Function">Smooth Function</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
     A differentiable function <fr:tex display="inline"><![CDATA[f(\mathbf {x})]]></fr:tex> is called smooth iff it has a Lipschitz continuous gradient, i.e., iff <fr:tex display="inline"><![CDATA[L< \infty ]]></fr:tex> such that <fr:tex display="block"><![CDATA[||\nabla  f(\mathbf {x})-\nabla  f(\mathbf {z}) ||_{2}\ \leq  L ||\mathbf {x}-\mathbf {z} ||_{2},\quad  \forall  \mathbf {x},\ \mathbf {z}\in \mathbb {R}^{n}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003L/</fr:uri><fr:display-uri>003L</fr:display-uri><fr:route>/003L/</fr:route><fr:title text="Mean Value Theorem I">Mean Value Theorem I</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
 Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be continuously differentiable. For any fixed <fr:tex display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex display="block"><![CDATA[\,f(\mathbf {y})\,=\,f(\mathbf {x})\,+\,\langle \nabla  f(\mathbf {z}(t_{L})),\mathbf {y}-\mathbf {x}\rangle \,]]></fr:tex> for some <fr:tex display="inline"><![CDATA[\mathbf {z}(t_{L})=(1-t_{L})\cdot \mathbf {x}+t_{L}\cdot \mathbf {y}]]></fr:tex> with <fr:tex display="inline"><![CDATA[t_{L}\in (0,1)\,]]></fr:tex>. 
  </html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        <html:ul><html:li> If <fr:tex display="inline"><![CDATA[f:\mathbb {R}^n\mapsto \mathbb {R}]]></fr:tex> is continuously differentiable, <fr:tex display="block"><![CDATA[\begin {aligned}      |f(\pmb {x})-f(\pmb {y})| &\leq  & \sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2 \, ||\pmb {x}-\pmb {y}||_2   \end {aligned}]]></fr:tex> so that the Lipschitz constant of <fr:tex display="inline"><![CDATA[f]]></fr:tex> is <fr:tex display="inline"><![CDATA[\sup _{\pmb {z} \in  \mathbb {R}^n} ||\nabla  f(\pmb {z})||_2]]></fr:tex>.</html:li>
          <html:li>If <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is twice continuously differentiable, <fr:tex display="block"><![CDATA[||\nabla  f(\boldsymbol {x})-\nabla  f(\boldsymbol {y})||_{2}\ \leq \ \sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}\,||\boldsymbol {x}-\boldsymbol {y}||_{2}]]></fr:tex> so that the Lipschitz constant of <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> is <fr:tex display="inline"><![CDATA[\sup _{\boldsymbol {z}\in \mathbb {R}^{n}}||\nabla ^{2}f(\boldsymbol {z})||_{2}]]></fr:tex></html:li></html:ul>
      </fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003M/</fr:uri><fr:display-uri>003M</fr:display-uri><fr:route>/003M/</fr:route><fr:title text="Mean Value Theorem II">Mean Value Theorem II</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be twice continuously differentiable. For any fixed <fr:tex display="inline"><![CDATA[\mathbf {x}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbf {y}]]></fr:tex>, we have <fr:tex display="block"><![CDATA[\nabla  f(\mathbf {y})\;=\;\nabla  f(\mathbf {x})\,+\,\int _{0}^{1}\nabla ^{2}f(\mathbf {z}(t))\cdot (\mathbf {y}-\mathbf {x})dt]]></fr:tex> for some <fr:tex display="inline"><![CDATA[\mathbf {z}(t)=(1-t)\mathbf {x}+t\mathbf {y}]]></fr:tex> with <fr:tex display="inline"><![CDATA[t\in (0,1)\,,]]></fr:tex> and that <fr:tex display="block"><![CDATA[\boxed {f(\mathbf {y})\;=\;f(\mathbf {x})+(\nabla  f(\mathbf {x}),\mathbf {y}-\mathbf {x})+\frac {1}{2}(\mathbf {y}-\mathbf {x})^{\top }\nabla ^{2}f(\mathbf {z}(t_{Q}))(\mathbf {y}-\mathbf {x})}]]></fr:tex> for some <fr:tex display="inline"><![CDATA[t_{Q}\in (0,1)\,.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003N/</fr:uri><fr:display-uri>003N</fr:display-uri><fr:route>/003N/</fr:route><fr:title text="First-order approximation">First-order approximation</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be continuously differentiable, and <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:tex display="inline"><![CDATA[\gamma _{L}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{L}(\mathbf {x}_{0})}{2}\,||\mathbf {x}-\mathbf {x}_{0}||_{2}^{2}\,,]]></fr:tex> where we define <fr:tex display="block"><![CDATA[\widehat {f_{L}}(\mathbf {x};\mathbf {x}_{0})\ :=\ f(\mathbf {x}_{0})\ +\ \langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle \,.]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003O/</fr:uri><fr:display-uri>003O</fr:display-uri><fr:route>/003O/</fr:route><fr:title text="Second-order approximation">Second-order approximation</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\to \mathbb {R}]]></fr:tex> be twice continuously differentiable, and suppose <fr:tex display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x})]]></fr:tex> is <fr:tex display="inline"><![CDATA[\gamma _{Q}(\mathbf {x}_{0})]]></fr:tex>-Lipschitz continuous at <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>, then <fr:tex display="block"><![CDATA[\left |f(\mathbf {x})-\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0})\right |\ \leq \ \frac {\gamma _{Q}(\mathbf {x}_{0})}{6}\left ||\mathbf {x}-\mathbf {x}_{0}\right ||_{2}^{3},]]></fr:tex> where we define <fr:tex display="block"><![CDATA[\widehat {f}_{Q}(\mathbf {x};\mathbf {x}_{0}):=f(\mathbf {x}_{0})+\langle \nabla  f(\mathbf {x}_{0}),\mathbf {x}-\mathbf {x}_{0}\rangle ]]></fr:tex> <fr:tex display="block"><![CDATA[+\frac {1}{2}(\mathbf {x}-\mathbf {x}_{0})^{\top }\nabla ^{2}f(\mathbf {x}_{0})(\mathbf {x}-\mathbf {x}_{0}).]]></fr:tex></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER3/</fr:uri><fr:display-uri>DER3</fr:display-uri><fr:route>/DER3/</fr:route><fr:title text="Optimality Conditions">Optimality Conditions</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003P/</fr:uri><fr:display-uri>003P</fr:display-uri><fr:route>/003P/</fr:route><fr:title text="Stationary point">Stationary point</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    A point <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a stationary point of <fr:tex display="inline"><![CDATA[f(\cdot )]]></fr:tex>, if <fr:tex display="block"><![CDATA[\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.]]></fr:tex> Here, <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is also known as a critical point.
  </html:p></fr:mainmatter></fr:tree><html:ul><html:li><html:strong>First order necessary condition</html:strong>:
    If <fr:tex display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex display="inline"><![CDATA[\ f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f]]></fr:tex> is continuously differentiable in an open neighborhood of <fr:tex display="inline"><![CDATA[\ \mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex display="block"><![CDATA[\boxed {\nabla  f(\mathbf {x_{\star }})\ =\ \mathbf {0}.}]]></fr:tex>
    <html:li><html:strong>Second order necessary condition:</html:strong>
    If <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a local minimizer of <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex>, and <fr:tex display="inline"><![CDATA[f]]></fr:tex> is twice continuously differentiable in an open neighborhood around <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex>, then we must have <fr:tex display="block"><![CDATA[(i)\ \nabla  f(\mathbf {x_{\star }})=\mathbf {0};]]></fr:tex> <fr:tex display="block"><![CDATA[(ii)\ \nabla ^{2}f(\mathbf {x_{\star }})\succeq \mathbf {0}.]]></fr:tex>
    <html:ul><html:li>If <fr:tex display="inline"><![CDATA[\nabla ^{2}f(\mathbf {x_{\star }})\succ \mathbf {0}]]></fr:tex> then the above is a sufficient condition.</html:li></html:ul></html:li></html:li></html:ul>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be a convex function, then 
  <html:ul><html:li>A local minimizer of <fr:tex display="inline"><![CDATA[f]]></fr:tex> is also its global minimizer. If <fr:tex display="inline"><![CDATA[f]]></fr:tex> is strictly convex, the global minimizer is unique</html:li>
    <html:li>A point is a global minimizer of <fr:tex display="inline"><![CDATA[f]]></fr:tex> iff <fr:tex display="block"><![CDATA[\mathbf {0}\ \in \ \partial  f(\mathbf {x_{\star }}).]]></fr:tex></html:li></html:ul>
  If <fr:tex display="inline"><![CDATA[f\in \mathcal {C}^{1}]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x_{\star }})=\mathbf {0}]]></fr:tex> implies that <fr:tex display="inline"><![CDATA[\mathbf {x_{\star }}]]></fr:tex> is a global minimizer.
  </fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER4/</fr:uri><fr:display-uri>DER4</fr:display-uri><fr:route>/DER4/</fr:route><fr:title text="Constrained Optimality">Constrained Optimality</fr:title></fr:frontmatter><fr:mainmatter><html:p>
    Consider a smooth contained problem with <fr:tex display="block"><![CDATA[\min _{\mathbf {x}}f(\mathbf {x}),\quad  \text {s.t.} \quad  r_{i}(\mathbf {x})\ =\ 0,\ 1\leq  i\leq  p,]]></fr:tex> <fr:tex display="block"><![CDATA[h_{j}(\mathbf {x})\ \leq \ 0,\ 1\leq  j\leq  q.]]></fr:tex> Consider its Lagrangian function <fr:tex display="block"><![CDATA[\mathscr {L}(\mathbf {x},\mathbf {u},\mathbf {v})\ =\ f(\mathbf {x})+\sum _{i=1}^{p}u_{i}\cdot  r_{i}(\mathbf {x})+\sum _{j=1}^{q}v_{j}\cdot  h_{j}(\mathbf {x}).]]></fr:tex>
    <html:strong>KKT-conditions:</html:strong>
    <html:ul><html:li>Stationary <fr:tex display="block"><![CDATA[\nabla _{\mathbf {x}}{\mathcal {L}}(\mathbf {x_*},\mathbf {u_*},\mathbf {v_*})\;=\;\mathbf {0}]]></fr:tex></html:li>
    <html:li>Primal Feasibility: <fr:tex display="block"><![CDATA[\begin {array}{l}{{r_{i}(x_{\star })\ =\ 0,\ 1\leq  i\leq  p,}}\\ {{h_{j}(x_{\star })\ \leq \ 0,\ 1\leq  j\leq  q.}}\end {array}]]></fr:tex></html:li>
    <html:li>Dual Feasibility: <fr:tex display="block"><![CDATA[v_{\star }\geq  0.]]></fr:tex></html:li>
    <html:li>Complimentary slackness: <fr:tex display="block"><![CDATA[h_{j}(x_{\star })\cdot  v_{\star  j}\ =\ 0,\quad \forall \ 1\leq  j\leq  q.]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER5/</fr:uri><fr:display-uri>DER5</fr:display-uri><fr:route>/DER5/</fr:route><fr:title text="Rate of Convergence">Rate of Convergence</fr:title></fr:frontmatter><fr:mainmatter><html:p>
  Want to find
<fr:tex display="block"><![CDATA[\operatorname *{min}_{\mathbf {x}}\ f(\mathbf {x}),\quad \text {s.t.}\quad \mathbf {x}\ \in \ \mathcal {C}.]]></fr:tex> Solve the problem via iterative methods of optimization, which produce a sequence of points <fr:tex display="block"><![CDATA[\mathbf {x}_{1},\ \mathbf {x}_{2},\ \cdots ,\mathbf {x}_{k},\cdots ]]></fr:tex> starting from an initialization <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex>. 
  </html:p><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003R/</fr:uri><fr:display-uri>003R</fr:display-uri><fr:route>/003R/</fr:route><fr:title text="First-order convergence">First-order convergence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
     First-order function value convergence 
     <fr:tex display="block"><![CDATA[||\nabla  f(\mathbf {x}_k)||_2 \; \leq  \; \varepsilon .]]></fr:tex>
       <html:ul><html:li> For convex functions, this also means convergence to the global minimizer</html:li>
        <html:li>For nonconvex functions, this only means   convergence to a <fr:link href="/003P/" title="Stationary point" uri="https://kellenkanarios.com/003P/" display-uri="003P" type="local">Stationary point</fr:link> (e.g., a local minimizer or a saddle point).</html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003Q/</fr:uri><fr:display-uri>003Q</fr:display-uri><fr:route>/003Q/</fr:route><fr:title text="Q-convergence"><fr:tex display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say the <fr:tex display="inline"><![CDATA[Q]]></fr:tex>-convergence is of order <fr:tex display="inline"><![CDATA[(p \geq 1)]]></fr:tex> and with factor <fr:tex display="inline"><![CDATA[(\gamma  > 0)]]></fr:tex>, if <fr:tex display="inline"><![CDATA[\exists  k_{0}]]></fr:tex>, such that <fr:tex display="inline"><![CDATA[\forall  k\geq  k_{0}]]></fr:tex>: <fr:tex display="block"><![CDATA[\boxed {\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k}}-\mathbf {x_{*}}||_{2}\ \leq \ \gamma \cdot \left (\min _{\mathbf {x_{*}}\in \mathcal {X}}||\mathbf {x_{k-1}}-\mathbf {x_{*}}||_{2}\right )^{p}.}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/003S/</fr:uri><fr:display-uri>003S</fr:display-uri><fr:route>/003S/</fr:route><fr:title text="R-convergence"><fr:tex display="inline"><![CDATA[R]]></fr:tex>-convergence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say the <fr:tex display="inline"><![CDATA[R]]></fr:tex>-convergence is of order <fr:tex display="inline"><![CDATA[p\;(\geq 1)]]></fr:tex>, <fr:tex display="block"><![CDATA[\min _{\mathbf {x}_{*}\in \mathcal {X}}||\mathbf {x}_{k}-\mathbf {x}_{*}||_{2}\;\leq \;\rho _{k},]]></fr:tex> if the sequence <fr:tex display="inline"><![CDATA[\{\rho _{k}\}_{k\geq 1}]]></fr:tex> is <fr:link href="/003Q/" title="Q-convergence" uri="https://kellenkanarios.com/003Q/" display-uri="003Q" type="local"><fr:tex display="inline"><![CDATA[Q]]></fr:tex>-convergence</fr:link> of the order <fr:tex display="inline"><![CDATA[p]]></fr:tex>. 
  </html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>1</fr:month><fr:day>26</fr:day></fr:date><fr:title text="Iterative Methods">Iterative Methods</fr:title></fr:frontmatter><fr:mainmatter>
  <html:strong>Assume:</html:strong>
  <html:ul><html:li><fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex> is a <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">Convex Function</fr:link> and a <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">Smooth Function</fr:link>.</html:li>
      <html:li>The gradient <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>.</html:li></html:ul>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER6/</fr:uri><fr:display-uri>DER6</fr:display-uri><fr:route>/DER6/</fr:route><fr:title text="Convergence of Gradient Descent">Convergence of Gradient Descent</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004L/</fr:uri><fr:display-uri>004L</fr:display-uri><fr:route>/004L/</fr:route><fr:title text="Sufficient Value">Sufficient Value</fr:title><fr:taxon>Lemma</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
With step size <fr:tex display="inline"><![CDATA[\tau _{k}=1/L\,,]]></fr:tex> the gradient descent iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by

<fr:tex display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathbf {x}_{k}\ -\ \tau _{k}\cdot \nabla  f(\mathbf {x}_{k})]]></fr:tex>

satisfy the following:

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k+1})\ \leq \ f(\mathbf {x}_{k})\ -\ \frac {1}{2L}\,||\nabla  f(\mathbf {x}_{k})||_{2}^{2}]]></fr:tex> <fr:tex display="block"><![CDATA[<\ f(\mathbf {x}_{k})\quad (||\nabla  f(\mathbf {x}_{k})||_{2}\neq 0)]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Because <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> is Lipschitz, by 1st-order Taylor approximation

<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})+\langle \nabla  f(\mathbf {x}),\mathbf {x}^{\prime }-\mathbf {x}\rangle +\frac {L}{2}\left ||\mathbf {x}^{\prime }-\mathbf {x}\right ||_{2}^{2},\quad \forall \ \mathbf {x}^{\prime },\mathbf {x}]]></fr:tex>
Now take <fr:tex display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \tau  \nabla  f( \mathbf {x})]]></fr:tex>. Then
<fr:tex display="block"><![CDATA[
  \begin {align*}
    f(\mathbf {x}^{\prime }) &\leq  f(\mathbf {x})+ \tau  ||\nabla  f( \mathbf {x} )||_2^2 + \frac {\tau ^2 L}{2} ||\nabla  f( \mathbf {x})||_2^2 \\
    &= f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2
  \end {align*}
]]></fr:tex>
  Take <fr:tex display="inline"><![CDATA[\tau  = \frac {1}{L}]]></fr:tex>, such that
<fr:tex display="block"><![CDATA[
    \begin {align*}
f( \mathbf {x}) - \tau (1 - \frac {\tau  L}{2})||\nabla  f( \mathbf {x})||_2^2 &= f( \mathbf {x}) - \frac {1}{2L}||\nabla  f( \mathbf {x})||_2^2
    \end {align*}
  ]]></fr:tex>
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004M/</fr:uri><fr:display-uri>004M</fr:display-uri><fr:route>/004M/</fr:route><fr:title text="Sublinear convergence of GD">Sublinear convergence of GD</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. If we run GD for <fr:tex display="inline"><![CDATA[k]]></fr:tex> iterations with a fixed step size <fr:tex display="inline"><![CDATA[\tau =1/L]]></fr:tex>, it will yield a sequence <fr:tex display="inline"><![CDATA[\left \{\mathbf {x}_{k}\right \}_{k\geq 1}]]></fr:tex> such that

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}\ =\ O(\frac {1}{k}),]]></fr:tex>

Moreover, as <fr:tex display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.

  </html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Given <fr:tex display="inline"><![CDATA[f]]></fr:tex> is convex and smooth, and <fr:tex display="inline"><![CDATA[\mathbf {x}_*]]></fr:tex> is an optimal solution, then
<fr:tex display="block"><![CDATA[f(\mathbf {x}_{\star })\geq  f(\mathbf {x})+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}_{\star }-\mathbf {x})]]></fr:tex>
Flipping the inequality yields
<fr:tex display="block"><![CDATA[f(\mathbf {x})\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })]]></fr:tex>
By <fr:link href="/004L/" title="Sufficient Value" uri="https://kellenkanarios.com/004L/" display-uri="004L" type="local">previous lemma</fr:link>, taking <fr:tex display="inline"><![CDATA[\mathbf {x}' = \mathbf {x} - \frac {1}{L} \nabla  f( \mathbf {x})]]></fr:tex> yields
<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x})-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
such that
<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })\leq  f(\mathbf {x}_{\star })+\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{2L}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}]]></fr:tex>
Equivalently,
<fr:tex display="block"><![CDATA[f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })\leq {\frac {L}{2}}\left [{\frac {2}{L}}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-{\frac {1}{L^{2}}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ]]]></fr:tex>
Completing the square,
<fr:tex display="block"><![CDATA[
\begin {align*}
 f(\mathbf {x}^{\prime })-f(\mathbf {x}_{\star })&\leq \frac {L}{2}\left [\frac {2}{L}\nabla  f(\mathbf {x})^{\top }(\mathbf {x}-\mathbf {x}_{\star })-\frac {1}{L^{2}}\left ||\nabla  f(\mathbf {x})\right ||_{2}^{2}\right ] \\ 
 &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}-\frac {1}{L}\nabla  f(\mathbf {x})-\mathbf {x}_{\star }\right ||_{2}^{2}\right ] \\ 
 &=\frac {L}{2}\left [\left ||\mathbf {x}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}^{\prime }-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]
\end {align*}
]]></fr:tex>
Let <fr:tex display="inline"><![CDATA[\mathbf {x}_{k}=\mathbf {x}_{k-1}-\frac {1}{L}\nabla  f(\mathbf {x}_{k-1})]]></fr:tex>, then we have

<fr:tex display="block"><![CDATA[
\begin {align*}
 \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right ) &\leq  \frac {L}{2}\sum _{i=1}^{k}\left [\left ||\mathbf {x}_{i-1}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{i}-\mathbf {x}_{\star }\right ||_{2}^{2}\right ]
 \\ &=\frac {L}{2}\left [\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}-\left ||\mathbf {x}_{k}-\mathbf {x}_{0}\right ||_{2}^{2}\right ] \\ 
 &\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2} 
\end {align*}
]]></fr:tex>
Therefore, given <fr:tex display="inline"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\leq  f(\mathbf {x}_{i})-f(\mathbf {x}_{*}) \text { for } \forall  i\leq  k\,,]]></fr:tex>

<fr:tex display="block"><![CDATA[k\left (f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\right )\leq \sum _{i=1}^{k}\left (f(\mathbf {x}_{i})-f(\mathbf {x}_{\star })\right )\leq \frac {L}{2}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2}^{2}]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004N/</fr:uri><fr:display-uri>004N</fr:display-uri><fr:route>/004N/</fr:route><fr:title text="Suboptimality of Gradient Descent">Suboptimality of Gradient Descent</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose the iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{i}\}_{i\geq 0}]]></fr:tex> is generated from a <html:em>black-box model</html:em>:

<fr:tex display="block"><![CDATA[\mathbf {x}_{k+1}\ =\ \mathcal {F}_{k}\left (\left \{\mathbf {x}_{i}\right \}_{i=0}^{k},\ \left \{f(\mathbf {x}_{i})\right \}_{i=0}^{k},\ \left \{\nabla  f(\mathbf {x}_{i})\right \}_{i=0}^{k}\right )]]></fr:tex></html:p><html:p>
For every positive <fr:tex display="inline"><![CDATA[L]]></fr:tex> and <fr:tex display="inline"><![CDATA[R]]></fr:tex>, there exists a <fr:link href="/004D/" title="Convex Function" uri="https://kellenkanarios.com/004D/" display-uri="004D" type="local">convex</fr:link> differentiable <fr:tex display="inline"><![CDATA[f]]></fr:tex> with <fr:tex display="inline"><![CDATA[\nabla  f]]></fr:tex> <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>, and an initial point <fr:tex display="inline"><![CDATA[\mathbf {x}_{0}]]></fr:tex> satisfying <fr:tex display="inline"><![CDATA[||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}\leq  R]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \geq \ c\frac {LR}{k^{2}}\ =\ \Omega (\frac {1}{k^{2}}),]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\ c>0]]></fr:tex> is some numerical constant.

  </html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER7/</fr:uri><fr:display-uri>DER7</fr:display-uri><fr:route>/DER7/</fr:route><fr:title text="Accelerated Gradient Descent">Accelerated Gradient Descent</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004O/</fr:uri><fr:display-uri>004O</fr:display-uri><fr:route>/004O/</fr:route><fr:title text="Nesterov's Method">Nesterov's Method</fr:title></fr:frontmatter><fr:mainmatter><html:p>
Generate two sequences <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}{\mathrm {~and~}}\{\mathbf {p}_{k}\}_{k\geq 1}]]></fr:tex>
<fr:tex display="block"><![CDATA[
\begin {align*}
{\mathbf {\mathit {p}}}_{k+1}\ &=\ {\mathbf {\mathit {x}}}_{k}\ +\ \beta _{k}\cdot ({\mathbf {\mathit {x}}}_{k}-{\mathbf {\mathit {x}}}_{k-1}), \\
x_{k+1} &= p_{k+1}-\alpha \nabla  f(p_{k+1})
\end {align*}
]]></fr:tex>
<html:ul><html:li><html:strong>Not</html:strong> a descent method.</html:li>
<html:li>With properly chosen <fr:tex display="inline"><![CDATA[\alpha ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\beta ]]></fr:tex> can achieve <fr:link href="/004N/" title="Suboptimality of Gradient Descent" uri="https://kellenkanarios.com/004N/" display-uri="004N" type="local">optimal</fr:link> convergence rate <fr:tex display="inline"><![CDATA[O(1/k^2)]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004P/</fr:uri><fr:display-uri>004P</fr:display-uri><fr:route>/004P/</fr:route><fr:title text="Convergence of accelerated GD">Convergence of accelerated GD</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Suppose <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> is convex and smooth with its gradient <fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz. The iterates <fr:tex display="inline"><![CDATA[\{\mathbf {x}_{k}\}_{k\geq 1}]]></fr:tex> generated by the accelerated GD method satisfy

<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k})-f(\mathbf {x}_{\star })\ \leq \ \frac {L}{2(k+1)^{2}}\ ||\mathbf {x}_{0}-\mathbf {x}_{\star }||_{2}^{2}\ =\ O(\frac {1}{k^{2}}).]]></fr:tex>

Moreover, as <fr:tex display="inline"><![CDATA[k\to +\infty ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\mathbf {x}_{k}\to \mathbf {x}_{\star }]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER8/</fr:uri><fr:display-uri>DER8</fr:display-uri><fr:route>/DER8/</fr:route><fr:title text="Line Search">Line Search</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004Q/</fr:uri><fr:display-uri>004Q</fr:display-uri><fr:route>/004Q/</fr:route><fr:title text="Exact Linesearch">Exact Linesearch</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
    For 
<fr:tex display="block"><![CDATA[x_{k+1}\ =\ x_{k}\ -\ \tau _{k}\cdot \nabla  f(x_{k})]]></fr:tex>
Choose step size by solving
<fr:tex display="block"><![CDATA[\tau _{k}\;=\;\arg \operatorname *{min}_{t\geq 0}\;f({\mathbf {x}}_{k}-t\cdot \nabla  f({\mathbf {x}}_{k}))]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Way to computationally expensive to use in practice.</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004R/</fr:uri><fr:display-uri>004R</fr:display-uri><fr:route>/004R/</fr:route><fr:title text="Armijo Condition">Armijo Condition</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  For some <fr:tex display="inline"><![CDATA[c_1 \in  (0,1)]]></fr:tex>,
<fr:tex display="block"><![CDATA[f( \mathbf {x}_k + \tau _k \cdot  \mathbf {d}_k) < f( \mathbf {x}_k) + c_1 \cdot  \tau _k \cdot  \mathbf {d}_{k}^{\top } \nabla  f(\mathbf {x}_k)]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004S/</fr:uri><fr:display-uri>004S</fr:display-uri><fr:route>/004S/</fr:route><fr:title text="Wolfe condition">Wolfe condition</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  For some <fr:tex display="inline"><![CDATA[0 < c_1 < c_2 < 1]]></fr:tex>,
<fr:tex display="block"><![CDATA[f(\mathbf {x}_{k}+\tau _{k}\cdot \mathbf {d}_{k})\ <\ f(\mathbf {x}_{k})+c_{1}\cdot \tau _{k}\cdot \mathbf {d}_{k}^{\intercal }\nabla  f(\mathbf {x}_{k})]]></fr:tex>
<fr:tex display="block"><![CDATA[d_{k}^{\top }\nabla  f({\mathbf {x}}_{k}+\tau _{k}{\mathbf {d}}_{k})\ \geq \ c_{2}{\mathbf {d}}_{k}^{\top }\nabla  f({\mathbf {x}}_{k})]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        Wolfe condition requires evaluating gradient of function each update to <fr:tex display="inline"><![CDATA[\tau _k]]></fr:tex>. However,  <fr:link href="/004R/" title="Armijo Condition" uri="https://kellenkanarios.com/004R/" display-uri="004R" type="local">Armijo Condition</fr:link> only requires evaluating gradient once. Therefore, it is primarily used in practice.
      </fr:mainmatter></fr:tree>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        Backtracking is not used in optimizing DNNs because even function evaluation is very expensive.
      </fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004T/</fr:uri><fr:display-uri>004T</fr:display-uri><fr:route>/004T/</fr:route><fr:title text="Convergence of GD with backtracking">Convergence of GD with backtracking</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let the function <fr:tex display="inline"><![CDATA[f(\pmb {x})]]></fr:tex> be <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex and <fr:tex display="inline"><![CDATA[L]]></fr:tex>-smooth. With backtracking

linesearch, the GD method converges with

<fr:tex display="block"><![CDATA[f(\pmb {x}_k)-f(\pmb {x}_\star )\ \le \ \left (1-\min \left \{2c_1\mu ,\dfrac {2\alpha  c_1\mu }{L}\right \}\right )^k(f(\pmb {x}_0)-f(\pmb {x}_\star ))]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\pmb {x}_\star ]]></fr:tex> is the unique minimizer.
</html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DER9/</fr:uri><fr:display-uri>DER9</fr:display-uri><fr:route>/DER9/</fr:route><fr:title text="How function properties affect convergence">How function properties affect convergence</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004U/</fr:uri><fr:display-uri>004U</fr:display-uri><fr:route>/004U/</fr:route><fr:title text="Linear convergence for strong convexity">Linear convergence for strong convexity</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[f:\mathbb {R}^{n}\mapsto \mathbb {R}]]></fr:tex> be smooth and <fr:link href="/0036/" title="Strong convexity" uri="https://kellenkanarios.com/0036/" display-uri="0036" type="local"><fr:tex display="inline"><![CDATA[\mu ]]></fr:tex>-strongly convex</fr:link>, and suppose its gradient <fr:tex display="inline"><![CDATA[\nabla  f(\mathbf {x})]]></fr:tex> is <fr:link href="/003J/" title="Lipschitz Continous" uri="https://kellenkanarios.com/003J/" display-uri="003J" type="local"><fr:tex display="inline"><![CDATA[L]]></fr:tex>-Lipschitz</fr:link>. Choose a fixed step size <fr:tex display="inline"><![CDATA[\tau _{k}\equiv \tau =\frac {2}{\mu +L}]]></fr:tex>, then

<fr:tex display="block"><![CDATA[\left ||\mathbf {x}_{k}-\mathbf {x}_{\star }\right ||_{2}\ \leq \ \left (\frac {\kappa -1}{\kappa +1}\right )^{k}\left ||\mathbf {x}_{0}-\mathbf {x}_{\star }\right ||_{2},]]></fr:tex>

where <fr:tex display="inline"><![CDATA[\kappa =\frac {L}{\mu }]]></fr:tex> is the condition number, and <fr:tex display="inline"><![CDATA[\mathbf {x}_{\star }]]></fr:tex> is the minimizer.
</html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        <fr:link href="/0036/" title="Strong convexity" uri="https://kellenkanarios.com/0036/" display-uri="0036" type="local">Strong convexity</fr:link> is a sufficient but not necessary condition for linear convergene of gradient descent.
      </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DERA/</fr:uri><fr:display-uri>DERA</fr:display-uri><fr:route>/DERA/</fr:route><fr:title text="Newton and Quasi-Newton Method">Newton and Quasi-Newton Method</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004V/</fr:uri><fr:display-uri>004V</fr:display-uri><fr:route>/004V/</fr:route><fr:title text="Newton's Method">Newton's Method</fr:title></fr:frontmatter><fr:mainmatter><html:p>Consider <fr:link href="/003O/" title="Second-order approximation" uri="https://kellenkanarios.com/003O/" display-uri="003O" type="local">second-order taylor approximation</fr:link> of <fr:tex display="inline"><![CDATA[f]]></fr:tex>
<fr:tex display="block"><![CDATA[ f(\mathbf {x}_{k}+\mathbf {d})\ \approx \ \underbrace {f(\mathbf {x}_{k})+\mathbf {d}^{\top }\nabla  f(\mathbf {x}_{k})+{\frac {1}{2}}\mathbf {d}^{\top }\nabla ^{2}f(\mathbf {x}_{k})\mathbf {d}}_{Q_k( \mathbf {d})}]]></fr:tex>
Then setting <fr:tex display="inline"><![CDATA[\nabla  Q_k( \mathbf {d})]]></fr:tex> and solving for <fr:tex display="inline"><![CDATA[\mathbf {d}]]></fr:tex>, we get
<fr:tex display="block"><![CDATA[
  \nabla  f( \mathbf {x}_k) + \frac {1}{2}\nabla ^2 f( \mathbf {x}_k) \mathbf {d} = 0
]]></fr:tex>
Thus, take <html:em>Newton's direction</html:em>
<fr:tex display="block"><![CDATA[\mathbf {d}_{k}^{N}=-\left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}\nabla  f(\mathbf {x}_{k}).]]></fr:tex></html:p>
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  Some notes
    <html:ul><html:li><html:strong>Fast convergence:</html:strong> Newton's method usually has local quadratic convergence.</html:li>
      <html:li><html:strong>Expensive:</html:strong> requires storing and inverting <fr:tex display="inline"><![CDATA[\nabla ^2 f( \mathbf {x})]]></fr:tex>.</html:li>
      <html:li><html:strong>Unstable:</html:strong> <fr:tex display="inline"><![CDATA[\nabla ^2 f \succ  0]]></fr:tex> might not hold for general nonlinear problems.</html:li></html:ul>
  </fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>2</fr:month><fr:day>3</fr:day></fr:date><fr:uri>https://kellenkanarios.com/004W/</fr:uri><fr:display-uri>004W</fr:display-uri><fr:route>/004W/</fr:route><fr:title text="Quasi-Newton's Method">Quasi-Newton's Method</fr:title></fr:frontmatter><fr:mainmatter><html:p>Get around computing and inverting hessian by using a surrogate i.e. 
<fr:tex display="block"><![CDATA[\mathbf {d}_{k}^{QN}=-\underbrace {\mathbf {H}_k}_{\text {surrogate for } \left (\nabla ^{2}f(\mathbf {x}_{k})\right )^{-1}} \nabla  f(\mathbf {x}_{k}).]]></fr:tex>
Want
<fr:tex display="block"><![CDATA[{\mathbf {H}}_{k+1}^{-1}\cdot \underbrace {({\mathbf {x}}_{k+1}-{\mathbf {x}}_{k})}_{{\mathbf {s}}_{k}}\;=\;\underbrace {\nabla  f({\mathbf {x}}_{k+1})-\nabla  f({\mathbf {x}}_{k})}_{{\mathbf {y}}_{k}}]]></fr:tex>
BFGS rank-2 update:
<fr:tex display="block"><![CDATA[{\mathbf {H}}_{k+1}\ =\ {\mathbf {H}}_{k}+{\frac {\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}+{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}{\mathbf {y}}_{k}\right ){\mathbf {s}}_{k}{\mathbf {s}}_{k}^{\top }}{\left ({\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}\right )^{2}}}-{\frac {{\mathbf {H}}_{k}{\mathbf {y}}_{k}{\mathbf {s}}_{k}^{\top }+{\mathbf {s}}_{k}{\mathbf {y}}_{k}^{\top }{\mathbf {H}}_{k}}{{\mathbf {s}}_{k}^{\top }{\mathbf {y}}_{k}}}]]></fr:tex></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>6</fr:day></fr:date><fr:uri>https://kellenkanarios.com/DERB/</fr:uri><fr:display-uri>DERB</fr:display-uri><fr:route>/DERB/</fr:route><fr:title text="Optimization on the Riemmanian Manifold">Optimization on the Riemmanian Manifold</fr:title></fr:frontmatter><fr:mainmatter><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0073/</fr:uri><fr:display-uri>0073</fr:display-uri><fr:route>/0073/</fr:route><fr:title text="Smooth Manifold">Smooth Manifold</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
We say <fr:tex display="inline"><![CDATA[ \mathcal {M}\subseteq \mathbb {R}^{n} ]]></fr:tex> is an embedded smooth submanifold of codimension <fr:tex display="inline"><![CDATA[ k ]]></fr:tex> if there exists a <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth function</fr:link> <fr:tex display="inline"><![CDATA[ g:\mathbb {R}^{n}\mapsto \mathbb {R}^{k} ]]></fr:tex>, such that

<fr:tex display="block"><![CDATA[ \mathcal {M}\equiv \left \{\boldsymbol {x}\in \mathbb {R}^{n}\mid  g(\boldsymbol {x})=\boldsymbol {0}\right \}, ]]></fr:tex>

<fr:tex display="block"><![CDATA[ \mathrm {D}g(\boldsymbol {x}):\mathbb {R}^{n}\mapsto \mathbb {R}^{k}\text { has rank }k,\ \forall \boldsymbol {x}\in \mathcal {M}. ]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0072/</fr:uri><fr:display-uri>0072</fr:display-uri><fr:route>/0072/</fr:route><fr:title text="Riemannian Manifold">Riemannian Manifold</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A Riemannian manifold <fr:tex display="inline"><![CDATA[ (\mathcal {M},\langle \cdot ,\cdot \rangle ) ]]></fr:tex> is a <fr:link href="/0073/" title="Smooth Manifold" uri="https://kellenkanarios.com/0073/" display-uri="0073" type="local">smooth manifold</fr:link>
<fr:tex display="inline"><![CDATA[ \mathcal {M} ]]></fr:tex> equipped with positive-definite inner product <fr:tex display="inline"><![CDATA[ \langle \cdot ,\cdot \rangle  ]]></fr:tex> on the tangent space <fr:tex display="inline"><![CDATA[ \mathrm {T}_{\pmb {x}}\mathcal {M} ]]></fr:tex> at each point <fr:tex display="inline"><![CDATA[ \pmb {x}\in \mathcal {M} ]]></fr:tex>. 
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0075/</fr:uri><fr:display-uri>0075</fr:display-uri><fr:route>/0075/</fr:route><fr:title text="Tangent Space">Tangent Space</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The tangent space <fr:tex display="inline"><![CDATA[ \mathrm {T}_{\pmb {x}}\mathcal {M} ]]></fr:tex> at a point <fr:tex display="inline"><![CDATA[ \pmb {x}\in \mathcal {M} ]]></fr:tex> is defined as
<fr:tex display="block"><![CDATA[T_x \mathcal {M} = \ker  Dg(\mathbf {x})]]></fr:tex>
which is a linear subspace of <fr:tex display="inline"><![CDATA[ \mathbb {R}^{n} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0074/</fr:uri><fr:display-uri>0074</fr:display-uri><fr:route>/0074/</fr:route><fr:title text="Tangent Bundle">Tangent Bundle</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
The tangent bundle of <fr:tex display="inline"><![CDATA[ {\cal  M} ]]></fr:tex> is the disjoint union of all <fr:link href="/0075/" title="Tangent Space" uri="https://kellenkanarios.com/0075/" display-uri="0075" type="local">tangent spaces</fr:link>:
<fr:tex display="block"><![CDATA[ {\rm  T}{\cal  M}\ =\ \{(\mathbf {x},\mathbf {v})\ \mid \ \mathbf {x}\in {\cal  M},\ {\rm  and}\ \mathbf {v}\in {\rm  T}_{\mathbf {x}}{\cal  M}\} ]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0076/</fr:uri><fr:display-uri>0076</fr:display-uri><fr:route>/0076/</fr:route><fr:title text="Retraction">Retraction</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A retraction is a <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth map</fr:link> <fr:tex display="inline"><![CDATA[ R:\mathrm {T}\mathcal {M}\mapsto \mathcal {M} ]]></fr:tex> such that if <fr:tex display="inline"><![CDATA[ h(t)=R(\mathbf {x},t\mathbf {v})=R_{\mathbf {x}}(t\mathbf {v}) ]]></fr:tex>, then <fr:tex display="inline"><![CDATA[ h(0)=\mathbf {x} ]]></fr:tex> and <fr:tex display="inline"><![CDATA[ h^{\prime }(0)=\mathbf {v} ]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0079/</fr:uri><fr:display-uri>0079</fr:display-uri><fr:route>/0079/</fr:route><fr:title text="Riemannian Metric">Riemannian Metric</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A choice of inner product <fr:tex display="inline"><![CDATA[\langle  \cdot , \cdot  \rangle _x]]></fr:tex> for each tangent space <fr:tex display="inline"><![CDATA[\mathrm {T}_x \mathcal {M}]]></fr:tex> defines a Riemannian metric on <fr:tex display="inline"><![CDATA[\mathcal {M}]]></fr:tex>.</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0078/</fr:uri><fr:display-uri>0078</fr:display-uri><fr:route>/0078/</fr:route><fr:title text="Riemmanian Metric">Riemmanian Metric</fr:title><fr:taxon>Claim</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[ \langle \cdot ,\cdot \rangle _{\textbf {x}} ]]></fr:tex> defines a <fr:link href="/0078/" title="Riemmanian Metric" uri="https://kellenkanarios.com/0078/" display-uri="0078" type="local">Riemmanian Metric</fr:link> on <fr:tex display="inline"><![CDATA[ \mathcal {M} ]]></fr:tex> if for any two smooth vector fields <fr:tex display="inline"><![CDATA[\mathbf {V}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathbf {W}]]></fr:tex>, the function <fr:tex display="inline"><![CDATA[ \textbf {x}\mapsto \left \langle \mathbf {V}(\textbf {x}),\mathbf {W}(\textbf {x})\right \rangle _{\textbf {x}} ]]></fr:tex> is smooth.
</html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0077/</fr:uri><fr:display-uri>0077</fr:display-uri><fr:route>/0077/</fr:route><fr:title text="Riemannian Gradient">Riemannian Gradient</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ f:\mathcal {M}\mapsto \mathbb {R} ]]></fr:tex> be <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth</fr:link> on the <fr:link href="/0072/" title="Riemannian Manifold" uri="https://kellenkanarios.com/0072/" display-uri="0072" type="local">Riemannian manifold</fr:link> <fr:tex display="inline"><![CDATA[ \mathcal {M} ]]></fr:tex>. The Riemannian gradient <fr:tex display="inline"><![CDATA[ \,\operatorname {grad}f(\boldsymbol {x})\, ]]></fr:tex> of <fr:tex display="inline"><![CDATA[ f ]]></fr:tex> at <fr:tex display="inline"><![CDATA[ \boldsymbol {x}\in \mathcal {M} ]]></fr:tex> is the unique tangent vector at <fr:tex display="inline"><![CDATA[ \boldsymbol {x} ]]></fr:tex> such that

<fr:tex display="block"><![CDATA[ \mathrm {D}f(\boldsymbol {x})[\boldsymbol {v}]\ =\ \langle \operatorname {grad}f(\boldsymbol {x}),\boldsymbol {v}\rangle _{\boldsymbol {x}}\,,\quad \forall \,\boldsymbol {v}\in \mathrm {T}_{\boldsymbol {x}}\mathcal {M}. ]]></fr:tex>
By extending the definition of <fr:tex display="inline"><![CDATA[ f ]]></fr:tex> to the ambient Euclidean space <fr:tex display="inline"><![CDATA[ \mathbb {R}^{n} ]]></fr:tex>, we can show that

<fr:tex display="block"><![CDATA[\mathrm {grad} f(\mathbf {x}) = \mathcal {P}_{T_x \mathcal {M}}(\nabla  f(\mathbf {x}))]]></fr:tex>
where <fr:tex display="inline"><![CDATA[  {\mathcal {P}}_{\mathrm {T}_{\mathbf {x}}\mathcal {M}}]]></fr:tex> is the orthogonal projector from <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex> to <fr:tex display="inline"><![CDATA[T_x \mathcal {M}]]></fr:tex></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007A/</fr:uri><fr:display-uri>007A</fr:display-uri><fr:route>/007A/</fr:route><fr:title text="Riemannian Hessian">Riemannian Hessian</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[ f:{\cal  M}\mapsto \mathbb {R} ]]></fr:tex> be <fr:link href="/003K/" title="Smooth Function" uri="https://kellenkanarios.com/003K/" display-uri="003K" type="local">smooth</fr:link> on the <fr:link href="/0072/" title="Riemannian Manifold" uri="https://kellenkanarios.com/0072/" display-uri="0072" type="local">Riemannian Manifold</fr:link> <fr:tex display="inline"><![CDATA[ {\cal  M} ]]></fr:tex>. The Riemannian Hessian <fr:tex display="inline"><![CDATA[ {\rm  Hess}\,f(\mathbf {x}):{\rm  T}_{\mathbf {x}}{\cal  M}\mapsto {\rm  T}_{\mathbf {x}}{\cal  M} ]]></fr:tex> of <fr:tex display="inline"><![CDATA[ f ]]></fr:tex> at <fr:tex display="inline"><![CDATA[ \mathbf {x}\in {\cal  M} ]]></fr:tex> is a mapping from <fr:tex display="inline"><![CDATA[ {\rm  T}_{\mathbf {x}}{\cal  M} ]]></fr:tex> to <fr:tex display="inline"><![CDATA[ {\rm  T}_{\mathbf {x}}{\cal  M} ]]></fr:tex> with

<fr:tex display="block"><![CDATA[ {\rm  Hess}\,f(\mathbf {x})[\mathbf {v}]\ :=\ \widetilde {\nabla }_{\mathbf {v}}\,{\rm  grad}\,f(\mathbf {x}). ]]></fr:tex>
<html:ul><html:li>Here, <fr:tex display="inline"><![CDATA[\tilde {\nabla }]]></fr:tex> is the Riemannian connection.</html:li>
  <html:li>
On a Riemannian submanifold embedded in <fr:tex display="inline"><![CDATA[\mathbb {R}^n]]></fr:tex>
<fr:tex display="block"><![CDATA[\tilde {\nabla }_{\mathbf {u}} V = \mathcal {P}_{T_{\mathbf {x}} \mathcal {M}}(\mathrm {D}V(\mathbf {x})[\mathbf {u}])]]></fr:tex>
and
<fr:tex display="block"><![CDATA[\mathrm {Hess}\,f(\mathbf {x})[\mathbf {v}]\ =\ {\mathcal {P}}_{\mathrm {T}_{\mathbf {x}}{\mathcal {M}}}\,(\mathrm {D}\,\mathrm {grad}\,f(\mathbf {x})[\mathbf {v}])]]></fr:tex></html:li></html:ul></html:p></fr:mainmatter></fr:tree><fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>4</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/007B/</fr:uri><fr:display-uri>007B</fr:display-uri><fr:route>/007B/</fr:route><fr:title text="Riemannian Gradient Descent">Riemannian Gradient Descent</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For <fr:tex display="inline"><![CDATA[f : \mathcal {M} \mapsto  \mathbb {R}]]></fr:tex>,
<fr:tex display="block"><![CDATA[ x_{k+1}\ =\ R_{{\mathbf {x}}_{k}}(-\tau _{k}\operatorname {grad}f({\mathbf {x}}_{k})) ]]></fr:tex></html:p><html:p>
  Can do backtracking line search i.e.

<html:strong>while</html:strong> <fr:tex display="block"><![CDATA[f(R_{x_{k}}(-\tau \,{\rm  grad}\,f(\mathbf {x}_{k}))) > f(\mathbf {x}_{k}) - c_{1}\tau \, | |{\rm  grad}\,f(\mathbf {x}_{k})| |_{2}^{2} ]]></fr:tex> <html:strong>do</html:strong> <fr:tex display="block"><![CDATA[ \tau \ \leftarrow \ \alpha \cdot \tau  ]]></fr:tex></html:p></fr:mainmatter></fr:tree></fr:mainmatter></fr:tree></fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>11</fr:month>
          <fr:day>24</fr:day>
        </fr:date>
        <fr:uri>https://kellenkanarios.com/0012/</fr:uri>
        <fr:display-uri>0012</fr:display-uri>
        <fr:route>/0012/</fr:route>
        <fr:title text="Notebook: Reinforcement learning: An introduction">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:title>
      </fr:frontmatter>
      <fr:mainmatter><html:p>This won't really be notes, my lab has begun taking a few undergrads who are not familiar with RL. I will be onboarding them by going through <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link>. Specifically, I will be following the <fr:link href="/richardsutton/" title="Richard Sutton" uri="https://kellenkanarios.com/richardsutton/" display-uri="richardsutton" type="local">Richard Sutton</fr:link> flavor of RL through his <fr:link href="https://drive.google.com/drive/folders/0B3w765rOKuKANmxNbXdwaE1YU1k?resourcekey=0-JZz-noRuJgogNsg1ljgV8w" type="external">CMPUT 609</fr:link> course. You know what the say: the best way to learn is to teach! Here, I will try to solve all the problems as we go and prepare some questions for the undergrads for when we meet. Additionally, I will document my foray into more advanced exploration of topics introduced in the textbook.</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Multi-armed Bandits">Multi-armed Bandits</fr:title></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.1]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.1" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  In the case of two actions, (assuming that <fr:tex display="inline"><![CDATA[Q_*(a_1) > Q_*(a_2)]]></fr:tex>) the probability of the greedy action being selected is <fr:tex display="inline"><![CDATA[1 - \epsilon ]]></fr:tex> or 0.5.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.2]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.2" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  In the long run <fr:tex display="inline"><![CDATA[\epsilon  = 0.01]]></fr:tex>, would achieve the highest reward. The expected reward can be written as
<fr:tex display="block"><![CDATA[
    \begin {align*}
      R^* = \max _{a} q^*(a) + \frac {\epsilon }{n}\sum _{i \neq  a}^{n} q^*(i)
    \end {align*}
  ]]></fr:tex>
  The exception is that if <fr:tex display="inline"><![CDATA[\epsilon  = 0]]></fr:tex>, then there are no guarantees. For example, if your initialization is zeros. Then you could have an empirical average of a suboptimal arm that is always positive and you would never deviate. Thus, to ensure you converge to the true optimal arm you need <fr:tex display="inline"><![CDATA[\epsilon  > 0]]></fr:tex>.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.4]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.4" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.4]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Following the steps in 2.6,
  <fr:tex display="block"><![CDATA[
      \begin {align*}
        Q_{n + 1} &= Q_n + \alpha _n [R_n - Q_n] \\
        &= Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}] + \alpha _n \Big [R_n - (Q_{n - 1} + \alpha _{n - 1}[R_{n - 1} - Q_{n - 1}])\Big ] \\
        &\vdots  \\
        & = \left (\prod _{i = 1}^{n} (1 - \alpha _{i})\right ) Q_1 + \sum _{i = 1}^{n} \alpha _n \left (\prod _{i = 1}^{n} (1 - \alpha _{n - i})\right )R_i
      \end {align*}
    ]]></fr:tex>

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.6]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.6" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Since all of the arms in the testbed have distributions with support less than 5, in the beginning the unpulled arm's optimistic estimates will be higher than the empirical estimates of the previously pulled arms. Therefore, in the early stages all of the arms will be pulled in a round robin fashion, and assuming deterministic rewards the optimal arm will keep being pulled until it falls below the other optimistic values.

</fr:mainmatter></fr:tree>
  



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.8]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.8" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Since there are 10 arms (presumably with the same initialization), the UCB bonus will enforce that the first 10 pulls are round robin (uniform) pulling of each of the 10 arms. Then on the 11th step each will have the same UCB bonus term but the one with the highest empirical reward will be pulled, leading to a spike. It then drops in subsequent steps because the UCB bonus of that arm will decrease and other (possibly less optimal) arms are pulled in subsequent steps.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.9]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.9" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  We can just expand the denominator as
<fr:tex display="block"><![CDATA[
    \begin {align*}
      \Pr \{A_t = a\} &= \frac {e^{H_t(a)}}{e^{H_t(a)} + e^{H_t(b)}} \\
      &= \frac {1}{1 + e^{\frac {H_t(b)}{H_t(a)}}} \\
      &= \frac {1}{1 + e^{-\frac {H_t(a)}{H_t(b)}}} \\
    \end {align*}
  ]]></fr:tex>

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 2.10]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="2.10" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 2.10]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  In case 1, the best you can hope to achieve is <fr:tex display="inline"><![CDATA[\max _{a} \mathbb {E} [R(a)]]]></fr:tex>. In this case, we have
<fr:tex display="block"><![CDATA[
    \begin {align*}
      \mathbb {E}[R(1)] &= 0.5 \cdot  10 + 0.5 \cdot  90 = 50, \\
      \mathbb {E}[R(2)] &= 0.5 \cdot  20 + 0.5 \cdot  80 = 50
    \end {align*}
  ]]></fr:tex>
  Therefore, the best we can hope to achieve is <fr:tex display="inline"><![CDATA[50]]></fr:tex>. If we are given what case we are in, then we can achieve
<fr:tex display="block"><![CDATA[
    \begin {align*}
      R^* &= 0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 1] +
      0.5 \cdot  \max _{a}\mathbb {E}[R(a) \mid  x = 2] \\
      &= 0.5 \cdot  20 + 0.5 \cdot  90 \\
      &= 55
    \end {align*}
  ]]></fr:tex>

</fr:mainmatter></fr:tree>
  

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Markov Decision Processes">Markov Decision Processes</fr:title></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.3]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.3" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  I think you draw the line at where you can already execute the necessary behavior to get from one state to another. This is eerily familiar to the line of work known as hierarchical reinforcement learning, where you gradually learn higher level of abstraction by executing subpolicies.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.5]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.5" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.5]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  We need to add the notion of a terminal state. This can be done by just adding some <fr:tex display="inline"><![CDATA[t]]></fr:tex> to the state space <fr:tex display="inline"><![CDATA[S]]></fr:tex>. Then
  <fr:tex display="block"><![CDATA[
      \begin {cases}
        p(t, 0 \mid  s, a) = 1, &\text { if } s = t\\
        \sum _{s^{\prime }\in \mathcal {S}}\sum _{r\in \mathcal {R}}p(s^{\prime },r|s,a)=1,\mathrm {~for~all~}s\in \mathcal {S},a\in \mathcal {A}(s), &\text { if } s \neq  t
      \end {cases}
]]></fr:tex>
I think the idea is just that when you hit a terminal state you no longer can reach other states.
  
</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.6]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.6" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex display="inline"><![CDATA[T]]></fr:tex> denote the length of the episode. Then the return <fr:tex display="inline"><![CDATA[G_t]]></fr:tex> would be 
<fr:tex display="block"><![CDATA[
  \begin {align*}
G_t &= R_{t+1} + \gamma  R_{t + 2} + \cdots  + \gamma ^{T - {t + 1}} R_T = - \gamma ^{T - {t + 1}}
  \end {align*}
]]></fr:tex>

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.7]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.7" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.7]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  You have not effectively communicated the task. The agent has no incentive to solve the maze as fast as possible. This means that no matter the duration it took to solve the task the agent would receive the same reward. To fix this, you can give -1 reward at each time step, or use a discount factor to capture the time.

</fr:mainmatter></fr:tree>
  



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.8]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.8" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.8]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Due to the recursive relationship, we will start from the back
<fr:tex display="block"><![CDATA[
    \begin {align*}
      G_5 &= 0 \\
      G_4 &= R_{5} + \gamma  G_5 = 2 \\
      G_3 &= R_{4} + \gamma  G_4 = 4 \\
      G_2 &= R_{3} + \gamma  G_3 = 8 \\
      G_1 &= R_{2} + \gamma  G_2 = 6 \\
      G_0 &= R_{1} + \gamma  G_1 = 2
    \end {align*}
  ]]></fr:tex>

</fr:mainmatter></fr:tree>
  



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.9]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.9" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.9]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
From the definition,
<fr:tex display="block"><![CDATA[
\begin {align*}
  G_0 &= R_{1} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\
&= 2 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\
&= 2 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 2} \\
&= 2 + \frac {7 \gamma }{1 - \gamma } \\
&= 65
\end {align*}
]]></fr:tex>
and 
<fr:tex display="block"><![CDATA[
\begin {align*}
  G_1 &= R_{2} + \gamma  R_{2} + \gamma ^2 R_{3} + \cdots  \\
&= 7 + \sum _{i = 1}^{\infty } \gamma ^{i} R_{i} \\
&= 7 + \gamma  \sum _{i = 0}^{\infty } \gamma ^{i} R_{i + 3} \\
&= 7 + \frac {7 \gamma }{1 - \gamma } \\
&= 70
\end {align*}
]]></fr:tex>
  
</fr:mainmatter></fr:tree>
  



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.11]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.11" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.11]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  By just expanding,
<fr:tex display="block"><![CDATA[
    \begin {align*}
      \mathbb {E}[R_{t + 1} \mid  S_{t} = s] = \sum _{a} \pi (a \mid  s) \sum _{s'} \sum _{r} p(s', r \mid  s, a) \cdot  r
    \end {align*}
  ]]></fr:tex>

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.12]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.12" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  <fr:tex display="block"><![CDATA[
      \begin {align*}
        v_{\pi }(s) &= \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)
      \end {align*}
    ]]></fr:tex>

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.12]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.12" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.12]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
<fr:tex display="block"><![CDATA[
\begin {align*}
  q_{\pi }(s, a) = \sum _{s', r} p(s', r \mid  s, a) \big (r + \gamma  v_{\pi }(s')\big )
\end {align*}
  ]]></fr:tex>

</fr:mainmatter></fr:tree>
  



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.15]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.15" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.15]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Recall that 
<fr:tex display="block"><![CDATA[
    \begin {align*}
      v_{\pi }(s) = \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1} \mid  S_t = s]
    \end {align*}
  ]]></fr:tex>
  Adding a constant <fr:tex display="inline"><![CDATA[c]]></fr:tex>, we get
<fr:tex display="block"><![CDATA[
    \begin {align*}
      v_{\pi }'(s) &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } \gamma ^{k} R_{t + k + 1} + c \mid  S_t = s] \\
      &= \mathbb {E}_{\pi } [\sum _{k = 0}^{\infty } R_{t + k + 1}\mid  S_t = s] +
\sum _{k = 0}^{\infty } \gamma ^{k} c \\
      &= v_{\pi }(s) + \frac {c}{1 - \gamma }
    \end {align*}
  ]]></fr:tex>
  Therefore, <fr:tex display="inline"><![CDATA[v_c = \frac {c}{1 - \gamma }]]></fr:tex>.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.16]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.16" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.16]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  In the episodic case, this would not be the same. In the maze running example, <fr:tex display="inline"><![CDATA[v_c]]></fr:tex> would be larger for longer episodes. This would then incentivize the agent to actually take LONGER, where as we want the agent to solve the maze as fast as possible.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 3.18]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.18" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 3.18]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  This is similar to Exercise 3.12. Namely, 
<fr:tex display="block"><![CDATA[v_{\pi }(s) = \mathbb {E}_{\pi }[q_{\pi }(s, a)] = \sum _{a} \pi (a \mid  s) q_{\pi }(s, a)]]></fr:tex>

</fr:mainmatter></fr:tree>
  

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Dynamic Programming">Dynamic Programming</fr:title></fr:frontmatter><fr:mainmatter>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter><html:strong>Value Iteration as Linear Algebra:</html:strong> During my brief stint at <fr:link href="https://www.ipam.ucla.edu/" type="external">IPAM</fr:link>, I spent a lot of time focused on <fr:link href="/kanariosParallelAMG2023/" title="Parallel Algebraic Multigrid for Higher Order PDEs" uri="https://kellenkanarios.com/kanariosParallelAMG2023/" display-uri="kanariosParallelAMG2023" type="local">solving large systems for discretized PDEs</fr:link>. From this, I learned about iterative methods, such as Gauss-Jacobi and Gauss-Seidel. Interestingly, these methods can be used to interpret some of RL's most fundamental algorithms. If we define the following matrices,
<fr:tex display="block"><![CDATA[
  \begin {align*}
        R &= \begin {bmatrix}
        \mathbb {E}[r(s = 1)]\\
        \vdots  \\
        \mathbb {E}[r(s = n)]
        \end {bmatrix}, \quad  P = \begin {bmatrix}
        P_{\pi }(s'=1 | s=1) & \cdots  & P_{\pi }(s'=n | s=1) \\
        \vdots  & \ddots  & \vdots  \\
        P_{\pi }(s'=1 | s=n) & \cdots  & P_{\pi }(s'=n | s=n)
        \end {bmatrix}, \\  
        V_k &= \begin {bmatrix}
        V_k(s = 1)\\
        \vdots  \\
        V_k(s = n)
        \end {bmatrix}
  \end {align*}
      ]]></fr:tex>
      Then we can write the value function <fr:tex display="inline"><![CDATA[V_{\pi }]]></fr:tex> as the solution to the linear system
      <fr:tex display="block"><![CDATA[
          V_{\pi } = R + PV_{\pi } \iff  V_{\pi } = (1 - P)^{-1} R
        ]]></fr:tex>
    This is just inverting a matrix! Updating one state with the canonical update
<fr:tex display="block"><![CDATA[
    \begin {align*}
      v_{k + 1}(s) = \sum _{a}\pi (a|s)\sum _{s^{\prime },r}p(s^{\prime },r\,|\,s,a)\Big [r+\gamma  v_{k}(s^{\prime })\Big ]
    \end {align*}
]]></fr:tex>
Is actually just one iteration of Gauss-Seidel!
    </fr:mainmatter></fr:tree>

    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>(Number of updates as pseudo discount factor). </fr:mainmatter></fr:tree>

  
  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 4.1]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="4.1" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 4.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
    We have that
<fr:tex display="block"><![CDATA[
      \begin {align*}
        q_{\pi }(11, \mathrm {down}) &= -1,
      \end {align*}
    ]]></fr:tex>
    where there is no recursion because the episode ends.
    Next,
<fr:tex display="block"><![CDATA[
      \begin {align*}
        q_{\pi }(7, \mathrm {down}) &= -1 + v(11) \\
        &= -1 - 14 \\ 
        &= -15
      \end {align*}
    ]]></fr:tex>
  
</fr:mainmatter></fr:tree>
  

  
  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 4.3]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="4.3" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 4.3]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  
</fr:mainmatter></fr:tree>
  


</fr:mainmatter></fr:tree>

  
  

  <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Review Question">Review Question</fr:title></fr:frontmatter><fr:mainmatter>
  
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Problem</fr:taxon></fr:frontmatter><fr:mainmatter>Review the methods discussed in the first part of the book. What are their strengths and weaknesses? When should they be used?</fr:mainmatter></fr:tree>

  <html:span style="white-space: nowrap">
    
 
   
   <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
      
  <html:table>
        
  <html:tr>
          
  <html:td />

          
  <html:td><html:strong>Strength</html:strong></html:td>

          
  <html:td><html:strong>Weakness</html:strong></html:td>

          
  <html:td><html:strong>Use case</html:strong></html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><html:strong>Bandits</html:strong></html:td>

          
  <html:td>Simplest case. Can isolate exploration problem.</html:td>

          
  <html:td>No credit assignment. Action only effect next timestep.</html:td>

          
  <html:td>Clinical trials. Things without temporally extended outcomes.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><html:strong>Dynamic Programming</html:strong></html:td>

          
  <html:td>Exact solution.</html:td>

          
  <html:td>Complexity blows up with state and action space. Model-based.</html:td>

          
  <html:td>Tabular MDPs.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><html:strong>Monte Carlo</html:strong></html:td>

          
  <html:td>Unbiased estimator. Model-free.</html:td>

          
  <html:td>Extremely high variance. Must wait till end of episode.</html:td>

          
  <html:td>When interacting with environment is inexpensive, episode length is short.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><html:strong>TD methods</html:strong></html:td>

          
  <html:td>Model-free. Online.</html:td>

          
  <html:td>Biased estimator.</html:td>

          
  <html:td>Environment interaction is cheap but also episode length is long or continuing.</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><html:strong>N step</html:strong></html:td>

          
  <html:td>Balance bias-variance tradeoff.</html:td>

          
  <html:td>Must choose <fr:tex display="inline"><![CDATA[n]]></fr:tex>.</html:td>

          
  <html:td>Lower variance continuing environments?</html:td>

        </html:tr>

        
  <html:tr>
          
  <html:td><html:strong>Dyna</html:strong></html:td>

          
  <html:td>Sample efficiency.</html:td>

          
  <html:td>Model-based.</html:td>

          
  <html:td>When interacting with environment is costly i.e. driving.</html:td>

        </html:tr>

      </html:table>

    </fr:mainmatter></fr:tree>
 

  </html:span>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Planning and Learning with Tabular Methods">Planning and Learning with Tabular Methods</fr:title></fr:frontmatter><fr:mainmatter>

  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 8.1]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="8.1" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 8.1]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  If you pick <fr:tex display="inline"><![CDATA[n]]></fr:tex> large enough, then the "first pass" would be just as good. This means that you will be able to update the <fr:tex display="inline"><![CDATA[Q]]></fr:tex>-values of every <fr:tex display="inline"><![CDATA[(s,a)]]></fr:tex> pair you encountered. However, with Dyna you are updating your <fr:tex display="inline"><![CDATA[Q]]></fr:tex>-value based on updated <fr:tex display="inline"><![CDATA[Q]]></fr:tex>-values, meaning that you are no longer limited to the <fr:tex display="inline"><![CDATA[n]]></fr:tex>-step trajectory encountered. Thus, I do not think that <fr:tex display="inline"><![CDATA[n]]></fr:tex>-step methods can match Dyna with a perfect world model.

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 8.5]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="8.5" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 8.5]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  You could modify the algorithm by maintaining an empirical distribution for states and rewards in your model instead of the exact deterministic transition. To handle changing environments, you could then weight the updates to the empirical distribution to value the more recent entries higher i.e. 
  <fr:tex display="block"><![CDATA[\hat {R}_{t + 1}(S,A) = \lambda  \hat {R}_{t}(S, A) + (1 - \lambda )R_{t + 1}(S, A)]]></fr:tex>

</fr:mainmatter></fr:tree>
  


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 8.6]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="8.6" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 8.6]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  This would strengthen the case for sample updates because the samples would most likely concentrate around the higher probability states. Since these states are much more likely to occur, the computed <fr:tex display="inline"><![CDATA[Q]]></fr:tex>-values will likely end up very similar without the extra computation required by the expected update.

</fr:mainmatter></fr:tree>
  



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 8.7]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="8.7" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 8.7]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  


</fr:mainmatter></fr:tree>
  

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="On-policy Prediction with Approximation">On-policy Prediction with Approximation</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>
In my opinion, the most important part of this chapter is now that when we update say a <fr:tex display="inline"><![CDATA[Q]]></fr:tex> function for a specific state action pair <fr:tex display="inline"><![CDATA[(s,a)]]></fr:tex>, then this update can affect the value of the <fr:tex display="inline"><![CDATA[Q(s', a')]]></fr:tex> due to the reuse of the internal parameters.
  </html:p>


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 9.1]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="9.1" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 9.1]</fr:link></html:span></fr:title><fr:taxon>exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  <html:p>Show that tabular methods are a special case of linear function approximation. What would the feature vectors be?</html:p>

</fr:mainmatter></fr:tree>
  



 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
<html:p>As a linear function approximation method, we have two quantities <fr:tex display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\boldsymbol {x}(s)]]></fr:tex>. We make the update
<fr:tex display="block"><![CDATA[w_{t + 1} = w_{t} + \alpha (r_t + \gamma  w_{t}^{\top } x_{t+1} - w_t^{\top } x_t) x_t]]></fr:tex>
In the tabular setting, we just assume that we have the capacity to represent every possible state. This means that <fr:tex display="inline"><![CDATA[x(s) \in  \mathbb {R}^{|S|}]]></fr:tex>. Therefore, if we define the features as <fr:tex display="inline"><![CDATA[x : s_i \mapsto  \boldsymbol {e}_i]]></fr:tex> then we can recover policy evaluation by taking,
<fr:tex display="block"><![CDATA[r_i = \mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)], \quad  w_i = v_{\pi }(s_i)]]></fr:tex></html:p>
Substituting, we get 
<fr:tex display="block"><![CDATA[
w_{t + 1} = w_{t} + \alpha (\mathbb {E}_{a \sim  \pi , s \sim  p}[r(s_i)] + v(s_{t + 1}) - v(s_{t})) \cdot  \boldsymbol {e}_i
]]></fr:tex>
Since <fr:tex display="inline"><![CDATA[\boldsymbol {w}]]></fr:tex> is our vector of values, updating the <fr:tex display="inline"><![CDATA[i]]></fr:tex>th entry is exactly performing exactly one update to <fr:tex display="inline"><![CDATA[v_{\pi }(s_i)]]></fr:tex> in the tabular setting.
</fr:mainmatter></fr:tree>
 



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 9.2]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="9.2" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 9.2]</fr:link></html:span></fr:title><fr:taxon>exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  <html:p>Why does (9.17) define <fr:tex display="inline"><![CDATA[(n + 1)^k]]></fr:tex> distinct features for dimension k? </html:p>

</fr:mainmatter></fr:tree>
  


 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>For each <fr:tex display="inline"><![CDATA[s_j]]></fr:tex>, there are <fr:tex display="inline"><![CDATA[n + 1]]></fr:tex> options for <fr:tex display="inline"><![CDATA[c_{i, j}]]></fr:tex>. Since there are <fr:tex display="inline"><![CDATA[k]]></fr:tex>, <fr:tex display="inline"><![CDATA[s_{j}]]></fr:tex>'s, there are <fr:tex display="inline"><![CDATA[(n + 1)^k]]></fr:tex> total possible features for <fr:tex display="inline"><![CDATA[x_i]]></fr:tex>.</html:p>
</fr:mainmatter></fr:tree>
 




  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 9.3]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="9.3" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 9.3]</fr:link></html:span></fr:title><fr:taxon>exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
<html:p>What <fr:tex display="inline"><![CDATA[n]]></fr:tex> and <fr:tex display="inline"><![CDATA[c_{i,j}]]></fr:tex> produce the feature vectors <fr:tex display="block"><![CDATA[\mathbf {x}(s)=(1,s_{1},s_{2},s_{1}s_{2},s_{1}^{2},s_{2}^{2},s_{1}^{2}s_{2}^{2},s_{1}s_{2}^{2},s_{1}^{2}s_{2}^{2})^{\top }?]]></fr:tex></html:p>

</fr:mainmatter></fr:tree>
  


 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p><fr:tex display="inline"><![CDATA[n = 2]]></fr:tex> and <fr:tex display="inline"><![CDATA[c_{ij}]]></fr:tex> as 
<fr:tex display="block"><![CDATA[\boldsymbol {c_0} = [0, 0], \quad 
  \boldsymbol {c_1} = [1, 0] \\
  \boldsymbol {c_2} = [0, 1], \quad 
  \boldsymbol {c_3} = [1, 1] \\
  \boldsymbol {c_4} = [2, 0], \quad 
  \boldsymbol {c_5} = [0, 2] \\
  \boldsymbol {c_6} = [2, 2], \quad 
  \boldsymbol {c_7} = [1, 2], \quad 
  \boldsymbol {c_8} = [2, 2]
  ]]></fr:tex></html:p>
</fr:mainmatter></fr:tree>
 



    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>In section 9.5.2, what do they mean when they say you can select <fr:tex display="inline"><![CDATA[n]]></fr:tex> so all the fourier features can be used?
    <html:ol><html:li>Pick <fr:tex display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex display="inline"><![CDATA[(n + 1)^k < mk^2]]></fr:tex>.</html:li>
        <html:li>Pick <fr:tex display="inline"><![CDATA[n]]></fr:tex> so that <fr:tex display="inline"><![CDATA[(n + 1)^k]]></fr:tex> is reasonable.</html:li></html:ol></html:li>
    <html:p>
    In the tabular case, I think (a) is correct. My initial understanding of state representation is as a representation learning i.e. compression type objective. If we assume that <fr:tex display="inline"><![CDATA[s_i \in  [m]]]></fr:tex>, then we do not gain anything in the tabular setting if our value function vector is the same size as the underlying transition kernel. When in the continuous state space regime i.e. <fr:tex display="inline"><![CDATA[s_i \in  [0,1]]]></fr:tex>, there is no amount of features that would overfit the transition kernel. Therefore, it is just about trying to learn as much as possible about the underlying relations of the state dimensions.
    </html:p>
    <html:p>
    In the <fr:tex display="inline"><![CDATA[2]]></fr:tex>-dimensional case, the feature vector <fr:tex display="inline"><![CDATA[c_i = [1,1]]]></fr:tex> would provide information on how <fr:tex display="inline"><![CDATA[s_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[s_2]]></fr:tex> relate not just their specific values. You want the learning algorithm to understand the relationships, so that it can make better use of the internal parameters when learning something like a <fr:tex display="inline"><![CDATA[Q]]></fr:tex> function. This is basically just SVD but instead of classification you are learning a <fr:tex display="inline"><![CDATA[Q]]></fr:tex> function. The compression  
    </html:p></html:ol>
  </fr:mainmatter></fr:tree>



    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ol><html:li>In Figure 9.5, why do fourier features outperform polynomial features?
    <html:ol><html:li>The fourier features got lucky on the seeds (lol).</html:li>
        <html:li>The choice of <fr:tex display="inline"><![CDATA[\boldsymbol {c}]]></fr:tex> is not specified. A good choice can provide improvement specific to the problem?</html:li>
        <html:li>Polynomial features range is very large. Can suffer from blowup or vanishing of features.</html:li></html:ol></html:li>
    One of the advantages of fourier features mentioned previously is the ability to select which features to serve as your basis. However, for this setup I assume they just use all of the fourier features. This likely means it is more of an issue with the polynomial features and (c). If you have a large polynomial then even relative similar states <fr:tex display="inline"><![CDATA[s_1 = 1.1]]></fr:tex>, <fr:tex display="inline"><![CDATA[s_2 = 0.9]]></fr:tex>, <fr:tex display="inline"><![CDATA[\ldots ]]></fr:tex> can blow up or vanish making them likely more unstable when using gradient-based methods.
  </html:ol>
  </fr:mainmatter></fr:tree>



  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:title text="Notebook: Reinforcement learning: An introduction ›  [suttonReinforcementLearningIntroduction2018, 9.4]"><fr:link href="/0012/" title="Notebook: Reinforcement learning: An introduction" uri="https://kellenkanarios.com/0012/" display-uri="0012" type="local">Notebook: <fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">Reinforcement learning: An introduction</fr:link></fr:link> ›  <html:span class="link-reference" tid="9.4" refid="suttonReinforcementLearningIntroduction2018"><fr:link href="/suttonReinforcementLearningIntroduction2018/" title="Reinforcement learning: An introduction" uri="https://kellenkanarios.com/suttonReinforcementLearningIntroduction2018/" display-uri="suttonReinforcementLearningIntroduction2018" type="local">[suttonReinforcementLearningIntroduction2018, 9.4]</fr:link></html:span></fr:title><fr:taxon>exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  <html:p>
    You could do anisotropic (big word for asymmetric) tile partitioning. If we consider the two state dimensions as (x,y) coordinates and suppose that we want to only generalize across the <fr:tex display="inline"><![CDATA[y]]></fr:tex>-direction i.e. we want states with the same <fr:tex display="inline"><![CDATA[x]]></fr:tex> coordinate to have similar values then we would tile with long thin tiles. Therefore, states with the same <fr:tex display="inline"><![CDATA[x]]></fr:tex> coordinate would lie in the same vertical tile and if the tiles are very thin any change in <fr:tex display="inline"><![CDATA[x]]></fr:tex>-coordinate would lie in disjoint tiles.
  </html:p>

</fr:mainmatter></fr:tree>
  



    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>24</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>I think that RBF as a continuous generalization coarse-coding is a nice intuition I want to remember here. Essentially, you just weight a state by how close it is to the center of the receptive field. This weighting is done via a Gaussian kernel, which I believe is arbitrary and can be any distance measure of choice.</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
      <fr:frontmatter>
        <fr:authors>
          <fr:author>
            <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
          </fr:author>
        </fr:authors>
        <fr:date>
          <fr:year>2024</fr:year>
          <fr:month>10</fr:month>
          <fr:day>30</fr:day>
        </fr:date>
        <fr:uri>https://kellenkanarios.com/0007/</fr:uri>
        <fr:display-uri>0007</fr:display-uri>
        <fr:route>/0007/</fr:route>
        <fr:title text="Notebook: Probability and measure">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:title>
      </fr:frontmatter>
      <fr:mainmatter><html:p>For these notes, I will attempt to refresh my knowledge of measure-theoretic probability along with learning stochastic processes for the first time. I will be following <fr:link href="https://link.springer.com/book/10.1007/978-0-387-87859-1" type="external">Probability and Stochastics</fr:link> by Cinlar. Unfortunately, there are no solutions to Exercises, but it is by far the best written book I have found.</html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Borel's Normal Number Theorem">Borel's Normal Number Theorem</fr:title></fr:frontmatter><fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000S/</fr:uri><fr:display-uri>000S</fr:display-uri><fr:route>/000S/</fr:route><fr:title text="Additivity of Intervals">Additivity of Intervals</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  We have the following properties
  <html:ol><html:li> If <fr:tex display="inline"><![CDATA[\bigcup _{k}I_{k}\subset  I]]></fr:tex>, and the <fr:tex display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex display="inline"><![CDATA[\sum _{k}|I_{k}|\leq |I|]]></fr:tex>.
</html:li>
<html:li> If <fr:tex display="inline"><![CDATA[I\subset \bigcup _{k}I_{k}]]></fr:tex> (the <fr:tex display="inline"><![CDATA[I_{k}]]></fr:tex> need not be disjoint), then <fr:tex display="inline"><![CDATA[|I|\leq \sum _{k}|I_{k}|]]></fr:tex>.
</html:li>
<html:li> If <fr:tex display="inline"><![CDATA[I=\bigcup _{k}I_{k}]]></fr:tex>, and the <fr:tex display="inline"><![CDATA[I_{k}]]></fr:tex> are disjoint, then <fr:tex display="inline"><![CDATA[|I|=\sum _{k}|I_{k}|]]></fr:tex>.
</html:li></html:ol></html:p></fr:mainmatter></fr:tree>
  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  The important takeaway from <fr:link href="/000S/" title="Additivity of Intervals" uri="https://kellenkanarios.com/000S/" display-uri="000S" type="local">Additivity of Intervals</fr:link> is that extending (2) from finite to countable unions requires Heine-Borel theorem, illustrating that this extension is non-trivial. This will be important to remember as we continue to extend the Lebesgue measure to <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras. 
  </fr:mainmatter></fr:tree>

  This section aims to motivate why we need to approach probability from a measure theoretic point of view.
  As an example, we will do the first Exercise for this section.
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>14</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000L/</fr:uri><fr:display-uri>000L</fr:display-uri><fr:route>/000L/</fr:route><fr:title text="Dyadic Intervals">Dyadic Intervals</fr:title><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Represent coin toss as dyadic expansion consider the set</html:p><fr:tex display="block"><![CDATA[\left [\omega :\ d_{i}(\omega )=u_{i},\,i=1,\ldots ,n \right ]=\Big (\sum _{i=1}^{n} \frac {u_{i}}{2^{i}},\ \sum _{i=1}^{n}\frac {u_{i}}{2^{i}} + \frac {1}{2^{n}}\Big ).]]></fr:tex><html:p>More stuff</html:p></fr:mainmatter></fr:tree>
  
  
  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>17</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000N/</fr:uri><fr:display-uri>000N</fr:display-uri><fr:route>/000N/</fr:route><fr:title text="Problem 1.1 Billingsley">Problem 1.1 Billingsley</fr:title><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter><html:ol><html:li>
    A discrete probability space cannot contain an infinite sequence of independent events <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> each with probability <fr:tex display="inline"><![CDATA[1/2]]></fr:tex>. To see this, denote the event space as <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex>. Note that 
    <fr:tex display="block"><![CDATA[P(A_1 \cap  A_2) + P(A_1 \cap  A_2^c) + P(A_1^c \cap  A_2) + P(A_1^c \cap  A_2^c) = 1]]></fr:tex>
    Therefore, every <fr:tex display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex> must be in one of those four events and have probability at most <fr:tex display="inline"><![CDATA[1/4]]></fr:tex>. Similarly, we can construct <fr:tex display="inline"><![CDATA[n]]></fr:tex> disjoint sets in the same manner and bound <fr:tex display="inline"><![CDATA[\mathbb {P}(\{x\})]]></fr:tex> by <fr:tex display="inline"><![CDATA[1/n]]></fr:tex>. Taking <fr:tex display="inline"><![CDATA[n \to  \infty ]]></fr:tex>, we have that <fr:tex display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Since <fr:tex display="inline"><![CDATA[\mathcal {X}]]></fr:tex> is a discrete probability space, we must have that 
    <fr:tex display="block"><![CDATA[\sum _{x \in  \mathcal {X}} \mathbb {P}(\{x\}) = 1]]></fr:tex>
    However, we have just shown that for each <fr:tex display="inline"><![CDATA[x \in  \mathcal {X}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\mathbb {P}(\{x\}) = 0]]></fr:tex>. Thus, we have reached a contradiction. 
  </html:li></html:ol></fr:mainmatter></fr:tree>
  
  I think my main takeaway from this is that infinite sequences break discrete probability because each discrete event will have probability zero. This is not actually a problem because in an infinite sequence the occurence of any such sequence "feasibly" has zero probability. However, we still want to reason about probabilistic things like the convergence of the average of the sequence. Since discrete probability is broken, we cannot even use it for these things. This is why we need to use measure theory to allow for zero probability sequences, but still provide information about these more "general" events. Who knows if this intuition is right though?
</fr:mainmatter></fr:tree>
<html:p><fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:ul><html:li> After a bit more digging, the main culprit here is the countable subadditivity condition of measure.</html:li>
      <html:li>In a discrete probability space, the entire space is at most countable. Therefore, if each individual event has zero probability then the countable union i.e. the whole space will have zero probability.</html:li>
      <html:li>In measure theoretic probability, we are able to accumulate non-zero probability mass from an <html:strong>uncountable</html:strong> union of zero measure events.</html:li>
      <html:li>I guess the canonical example of this is that each point on a line has length 0, but the line itself (an uncountable union of points) has non-zero length.</html:li>
      <html:li>In the dyadic intervals example, each event of an arbitrary discrete probability space can be identified with a point on the line of probability zero.</html:li></html:ul>
  </fr:mainmatter></fr:tree></html:p>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Probability Measures">Probability Measures</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000O/</fr:uri><fr:display-uri>000O</fr:display-uri><fr:route>/000O/</fr:route><fr:title text="\sigma -field"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A class of subsets <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field if the following holds
  <html:ol><html:li><fr:tex display="inline"><![CDATA[\Omega  \in  \mathscr {F}]]></fr:tex></html:li>
    <html:li>If <fr:tex display="inline"><![CDATA[A \in  \mathscr {F}]]></fr:tex> then <fr:tex display="inline"><![CDATA[A^c \in  \mathscr {F}]]></fr:tex></html:li>
    <html:li>If <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots  \in  \mathscr {F}]]></fr:tex> then <fr:tex display="inline"><![CDATA[\bigcup _{i = 1}^{\infty } A_i \in  \mathscr {F}]]></fr:tex></html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<html:p>It seems, in this section, we aim to answer why certain decisions were made regarding what can be analyzed. For example, 
</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Question</fr:taxon></fr:frontmatter><fr:mainmatter>Why do we only allow consider countable unions in the definition of a <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>?</fr:mainmatter></fr:tree>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Answer</fr:taxon></fr:frontmatter><fr:mainmatter>Because this is what god intended.</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000P/</fr:uri><fr:display-uri>000P</fr:display-uri><fr:route>/000P/</fr:route><fr:title text="Probability Measure">Probability Measure</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A set function is a real-valued function defined on some class of subsets of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>. A set function <fr:tex display="inline"><![CDATA[P]]></fr:tex> on a field <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a probability measure if it satisfies these conditions:

<html:ol><html:li><fr:tex display="inline"><![CDATA[0\leq  P(A)\leq 1]]></fr:tex> for <fr:tex display="inline"><![CDATA[A\in \mathscr {F}]]></fr:tex>;</html:li>
  <html:li><fr:tex display="inline"><![CDATA[P(\varnothing )=0]]></fr:tex>, <fr:tex display="inline"><![CDATA[P(\Omega )=1]]></fr:tex>;</html:li>
  <html:li>if <fr:tex display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> is a disjoint sequence of <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> sets and if <fr:tex display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}\in \mathscr {F}]]></fr:tex>, then <fr:tex display="block"><![CDATA[P\Big (\bigcup _{k=1}^{\infty }A_{k}\Big )=\sum _{k=1}^{\infty }P(A_{k}).]]></fr:tex></html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000Q/</fr:uri><fr:display-uri>000Q</fr:display-uri><fr:route>/000Q/</fr:route><fr:title text="Probability Space">Probability Space</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
If <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field in <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> and <fr:tex display="inline"><![CDATA[P]]></fr:tex> is a probability measure on <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, the triple <fr:tex display="inline"><![CDATA[(\Omega ,\mathscr {F},P)]]></fr:tex> is called a probability measure space, or simply a probability space. A support of <fr:tex display="inline"><![CDATA[P]]></fr:tex> is any <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set <fr:tex display="inline"><![CDATA[A]]></fr:tex> for which <fr:tex display="inline"><![CDATA[P(A)=1]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>20</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000R/</fr:uri><fr:display-uri>000R</fr:display-uri><fr:route>/000R/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
Let <fr:tex display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex>.

<html:ol><html:li><html:em>Continuity from below</html:em>: If <fr:tex display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathscr {A}_{n}\uparrow  A]]></fr:tex>, then <fr:tex display="inline"><![CDATA[P(A_{n})\uparrow  P(A)]]></fr:tex>.</html:li>

<html:li><html:em>Continuity from above</html:em>: If <fr:tex display="inline"><![CDATA[A_{n}]]></fr:tex> and <fr:tex display="inline"><![CDATA[A]]></fr:tex> lie in <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> and <fr:tex display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex>, then <fr:tex display="inline"><![CDATA[P(A_{n})\downarrow  P(A)]]></fr:tex>.</html:li>
<html:li><html:em>Countable subadditivity</html:em>: If <fr:tex display="inline"><![CDATA[A_{1},A_{2},\ldots ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\bigcup _{k=1}^{\infty }A_{k}]]></fr:tex> lie in <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> (the <fr:tex display="inline"><![CDATA[A_{k}]]></fr:tex> need not be disjoint), then

<fr:tex display="block"><![CDATA[P\left (\bigcup _{k=1}^{\infty }A_{k}\right )\leq \sum _{k=1}^{\infty }P(A_{k})]]></fr:tex></html:li></html:ol></html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Existence and Extension">Existence and Extension</fr:title></fr:frontmatter><fr:mainmatter>
    <html:p>Here we will see how we can define a probability measure on an algebra <fr:tex display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex> and get a unique extension to the <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex display="inline"><![CDATA[\mathscr {F} = \sigma (\mathscr {F}_0)]]></fr:tex>. I guess the key here is uniqueness?</html:p>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000T/</fr:uri><fr:display-uri>000T</fr:display-uri><fr:route>/000T/</fr:route><fr:title text="Outer Measure">Outer Measure</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>For each subset <fr:tex display="inline"><![CDATA[A]]></fr:tex> of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex display="block"><![CDATA[P^{*}(A)=\mathrm {inf}\,\sum _{n}P(A_{n}),]]></fr:tex> where <fr:tex display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n.]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Taking <fr:tex display="inline"><![CDATA[P_*(A) = 1 - P^*(A^c)]]></fr:tex> gives the inner measure. This is just analogously approximating from the inside.</fr:mainmatter></fr:tree>

    Intuition is that the sets that are "measurable" should be sets that can be arbitrarily approximated from the inside and outside, or equivalently
<fr:tex display="block"><![CDATA[P^*(A) + P^*(A^c) = 1]]></fr:tex>
    <html:ol><html:li>My intution for this is that if a set is not arbitrarily well approximated by countable other sets from our algebra then we cannot hope to get an accurate measure from our measure defined on only the algebra.</html:li>
      <html:li>The countableness is just from the definition of the <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</html:li></html:ol>
    <html:p>
    Then we can use <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> as our measure. To do this, we will need to show that <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> is countable additive as one might expect. The rest of the properties of a <fr:link href="/000P/" title="Probability Measure" uri="https://kellenkanarios.com/000P/" display-uri="000P" type="local">Probability Measure</fr:link> are trivial.
    </html:p>

    
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
      <html:p>Suppose that <fr:tex display="inline"><![CDATA[A \subset  \bigcup _{n = 1}^{\infty } A_n]]></fr:tex>. By the definition of <fr:link href="/000T/" title="Outer Measure" uri="https://kellenkanarios.com/000T/" display-uri="000T" type="local">Outer Measure</fr:link>, we can find some <fr:tex display="inline"><![CDATA[B_{nk}]]></fr:tex>, such that <fr:tex display="inline"><![CDATA[A_n \subset  \bigcup _{k = 1}^{\infty } B_{nk}]]></fr:tex> where 
<fr:tex display="block"><![CDATA[\sum _{k} P(B_{nk}) < P^*(A_n) + \epsilon  2^{-k}]]></fr:tex>
Now take <fr:tex display="inline"><![CDATA[C_n = \bigcup _{k} B_{nk}]]></fr:tex>, so that <fr:tex display="inline"><![CDATA[\bigcup _{n} A_n \subset  \bigcup _{n} C_n]]></fr:tex> and
<fr:tex display="block"><![CDATA[P^*\left (\bigcup _n A_n\right ) < \sum _{n} P(C_n) = \sum _{n} \sum _{k} P(B_{nk}) < \sum _{n} P^*(A_n) + \epsilon ]]></fr:tex></html:p>
      Since <fr:tex display="inline"><![CDATA[\bigcup _{n} A_n = A]]></fr:tex>, we have achieved the desired result.
    </fr:mainmatter></fr:tree>
 



    <html:p>
      It turns out that for some reason only enforcing <fr:tex display="inline"><![CDATA[A]]></fr:tex> and its complement to sum to <fr:tex display="inline"><![CDATA[1]]></fr:tex> is not restrictive enough? From this, we end up with the final condition
    </html:p>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>21</fr:day></fr:date><fr:uri>https://kellenkanarios.com/000U/</fr:uri><fr:display-uri>000U</fr:display-uri><fr:route>/000U/</fr:route><fr:title text="P^*-measurable"><fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable if for every <fr:tex display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>, we have that 
<fr:tex display="block"><![CDATA[P^*(A \cap  E) + P^*(A^c \cap  E) = P^*(E)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <html:p>
        You then only need to show two things:
        <html:ol><html:li>The class of <fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets contains <fr:tex display="inline"><![CDATA[\mathscr {F_0}]]></fr:tex>,</html:li>
            <html:li>The class of <fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable sets is a <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.</html:li></html:ol>
        From these, we can conclude that <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> is at least defined on a <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> containing <fr:tex display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>. Restricting <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> to <fr:tex display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex>, then yields the desired extension.
    </html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Uniqueness">Uniqueness</fr:title></fr:frontmatter><fr:mainmatter>
    <html:p>We now want to show that the extension we developed in the previous section is actually unique. The first question we have is what do we mean by unique? To answer this, we need to remember what we have done so far.
    <html:ol><html:li>We have a <fr:link href="/000P/" title="Probability Measure" uri="https://kellenkanarios.com/000P/" display-uri="000P" type="local">Probability Measure</fr:link> <fr:tex display="inline"><![CDATA[P]]></fr:tex>, defined on an algebra <fr:tex display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>.</html:li>
        <html:li>We then extended <fr:tex display="inline"><![CDATA[P]]></fr:tex> to <fr:tex display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex> via <fr:tex display="inline"><![CDATA[P^*]]></fr:tex>, so that for every <fr:tex display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex> we have <fr:tex display="inline"><![CDATA[P(A) = P^*(A)]]></fr:tex> and <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> is defined on all of <fr:tex display="inline"><![CDATA[\sigma (\mathscr {F}_0)]]></fr:tex></html:li></html:ol>
      From this, our only restriction is that <fr:tex display="inline"><![CDATA[P^*(A) = P(A)]]></fr:tex> for <fr:tex display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Therefore, uniqueness here means that if <fr:tex display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for some <fr:tex display="inline"><![CDATA[Q]]></fr:tex> and every <fr:tex display="inline"><![CDATA[A \in  \mathscr {F}_0]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[P^*(A) = Q(A)]]></fr:tex> for every <fr:tex display="inline"><![CDATA[A \in  \sigma (\mathscr {F}_0)]]></fr:tex>.
    </html:p>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0018/</fr:uri><fr:display-uri>0018</fr:display-uri><fr:route>/0018/</fr:route><fr:title text="\pi -system"><fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A class <fr:tex display="inline"><![CDATA[\mathcal {P}]]></fr:tex> of subsets of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system if it is closed under the formation of finite intersections:
<fr:tex display="block"><![CDATA[A,B\in \mathcal {P} \implies  A\cap  B\in \mathcal {P}.]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0019/</fr:uri><fr:display-uri>0019</fr:display-uri><fr:route>/0019/</fr:route><fr:title text="\lambda -system"><fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A class <fr:tex display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system if it contains <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> and is closed under the formation of complements and of finite and countable disjoint unions:

<html:ol><html:li><fr:tex display="inline"><![CDATA[\Omega \in \mathscr {L}]]></fr:tex>;</html:li>

<html:li><fr:tex display="inline"><![CDATA[A\in \mathscr {L}]]></fr:tex> implies <fr:tex display="inline"><![CDATA[A^{c}\in \mathscr {L}]]></fr:tex>;</html:li>

<html:li><fr:tex display="inline"><![CDATA[A_{1},A_{2},\ldots ,\in \mathscr {L}]]></fr:tex> and <fr:tex display="inline"><![CDATA[A_{n}\cap  A_{m}=\varnothing ]]></fr:tex> for <fr:tex display="inline"><![CDATA[m\neq  n]]></fr:tex> imply <fr:tex display="inline"><![CDATA[\bigcup _{n}A_{n}\in \mathscr {L}]]></fr:tex>.</html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<html:p>I was a bit unsure that a <fr:link href="/0019/" title="\lambda -system" uri="https://kellenkanarios.com/0019/" display-uri="0019" type="local"><fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> is not a <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, but the author provided an example that I will walk through to understand the distinction </html:p>


   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
Consider a four point space <fr:tex display="inline"><![CDATA[\Omega  = \{x_1, x_2, x_3, x_4\}]]></fr:tex>. We can define a <fr:link href="/0019/" title="\lambda -system" uri="https://kellenkanarios.com/0019/" display-uri="0019" type="local"><fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> by taking <fr:tex display="inline"><![CDATA[\mathscr {L} = \emptyset , \Omega ,]]></fr:tex> and the six two point sets. The union of any two disjoint two point sets will be <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>. However, a non-disjoint union of two disjoint sets can result in a three point set, which is not in <fr:tex display="inline"><![CDATA[\mathscr {L}]]></fr:tex>. These non-disjoint unions would be covered in a <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>.
  </fr:mainmatter></fr:tree>
 


<html:p>To remedy this disconnect, we have the following lemma:</html:p>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001A/</fr:uri><fr:display-uri>001A</fr:display-uri><fr:route>/001A/</fr:route><fr:taxon>Lemma</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A class that is both a <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system and a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system is a <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field.</html:p></fr:mainmatter></fr:tree>

<html:p>In our example, we could take the intersection of say <fr:tex display="inline"><![CDATA[\{x_1, x_2\}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\{x_2, x_3\}]]></fr:tex> to get <fr:tex display="inline"><![CDATA[\{x_2\}]]></fr:tex>. We could then take a disjoint union of <fr:tex display="inline"><![CDATA[\{x_1, x_3\}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\{x_2\}]]></fr:tex> to get <fr:tex display="inline"><![CDATA[\{x_1, x_2, x_3\}]]></fr:tex>.</html:p> 

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001B/</fr:uri><fr:display-uri>001B</fr:display-uri><fr:route>/001B/</fr:route><fr:title text="Dynkin's \pi \text {-}\lambda ">Dynkin's <fr:tex display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
f <fr:tex display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system and <fr:tex display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system, then <fr:tex display="inline"><![CDATA[\mathscr {P}\subset \mathscr {L}]]></fr:tex> implies <fr:tex display="inline"><![CDATA[\sigma (\mathscr {P})\subset \mathscr {L}]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>

<html:p>Now we will see how this allows us to prove our desired result i.e. the uniqueness of our extension of a probability on an algebra via the outer measure.</html:p>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001C/</fr:uri><fr:display-uri>001C</fr:display-uri><fr:route>/001C/</fr:route><fr:title text="Uniqueness of Extension">Uniqueness of Extension</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  Suppose that <fr:tex display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex display="inline"><![CDATA[P_{2}]]></fr:tex> are probability measures on <fr:tex display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>, where <fr:tex display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system. If <fr:tex display="inline"><![CDATA[P_{1}]]></fr:tex> and <fr:tex display="inline"><![CDATA[P_{2}]]></fr:tex> agree on <fr:tex display="inline"><![CDATA[\mathscr {P}]]></fr:tex>, then they agree on <fr:tex display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.
</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
Take <fr:tex display="inline"><![CDATA[\mathscr {L}]]></fr:tex> to be the class of sets such that <fr:tex display="inline"><![CDATA[A \in  \mathscr {L} \implies  P_1(A) = P_2(A)]]></fr:tex>. Since <fr:tex display="inline"><![CDATA[\mathscr {P}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system, from <fr:link href="/001C/" title="Uniqueness of Extension" uri="https://kellenkanarios.com/001C/" display-uri="001C" type="local">Theorem 9</fr:link>, it is sufficient to show that <fr:tex display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system. Since <fr:tex display="inline"><![CDATA[\Omega  \in  \mathscr {P}]]></fr:tex>, <fr:tex display="inline"><![CDATA[\Omega  \in  \mathscr {L}]]></fr:tex>. If <fr:tex display="inline"><![CDATA[A \in  \mathscr {L}]]></fr:tex>, then
<fr:tex display="block"><![CDATA[P_1(A^c) = 1 - P_1(A) = 1 - P_2(A) = P_2(A^c).]]></fr:tex>
Therefore, <fr:tex display="inline"><![CDATA[A^c \in  \mathscr {L}]]></fr:tex>. Finally, if <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> disjoint then
<fr:tex display="block"><![CDATA[
  P_1\left (\bigcup _{n = 1} A_n\right ) = \sum _{n = 1} P_1(A_n) = \sum _{n = 1}P_2 (A_n) = P_2\left (\bigcup _{n = 1}A_n\right )
]]></fr:tex>
Thus, <fr:tex display="inline"><![CDATA[\mathscr {L}]]></fr:tex> is a <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system. From <fr:link href="/001C/" title="Uniqueness of Extension" uri="https://kellenkanarios.com/001C/" display-uri="001C" type="local">Theorem 9</fr:link>, <fr:tex display="inline"><![CDATA[\sigma (\mathscr {P}) \subset  \mathscr {L}]]></fr:tex> and <fr:tex display="inline"><![CDATA[P_1]]></fr:tex> and <fr:tex display="inline"><![CDATA[P_2]]></fr:tex> agree on all of <fr:tex display="inline"><![CDATA[\sigma (\mathscr {P})]]></fr:tex>.
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>

<html:p>An (important?) note is that this works due to our definition of a <fr:link href="/000P/" title="Probability Measure" uri="https://kellenkanarios.com/000P/" display-uri="000P" type="local">Probability Measure</fr:link>. Namely, countable additivity is really a condition on countable disjoint unions, meaning that the <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> induced by a <fr:link href="/000P/" title="Probability Measure" uri="https://kellenkanarios.com/000P/" display-uri="000P" type="local">Probability Measure</fr:link> does not make full use of the generality allowed under arbitrary countable unions because it must satisfy countable additivity.</html:p>

<html:p>For completeness and future use, we introduce here the notion of monotone classes and Halmo's useful <fr:link href="/001E/" title="Halmo's Monotone Class Theorem" uri="https://kellenkanarios.com/001E/" display-uri="001E" type="local">theorem</fr:link>.</html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001D/</fr:uri><fr:display-uri>001D</fr:display-uri><fr:route>/001D/</fr:route><fr:title text="Monotone Class">Monotone Class</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A class <fr:tex display="inline"><![CDATA[\mathscr {M}]]></fr:tex> of subsets of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> is monotone if it is closed under the formation of monotone unions and intersections:

<html:ol><html:li><fr:tex display="inline"><![CDATA[A_{1},A_{2},\ldots \in \mathscr {M}]]></fr:tex> and <fr:tex display="inline"><![CDATA[A_{n}\uparrow  A]]></fr:tex> imply <fr:tex display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>;</html:li>
<html:li><fr:tex display="inline"><![CDATA[A_{1},A_{2},\ \ldots \in \mathscr {M}]]></fr:tex> and <fr:tex display="inline"><![CDATA[A_{n}\downarrow  A]]></fr:tex> imply <fr:tex display="inline"><![CDATA[A\in \mathscr {M}]]></fr:tex>.</html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001E/</fr:uri><fr:display-uri>001E</fr:display-uri><fr:route>/001E/</fr:route><fr:title text="Halmo's Monotone Class Theorem">Halmo's Monotone Class Theorem</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
If <fr:tex display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> is a field and <fr:tex display="inline"><![CDATA[\mathscr {A}]]></fr:tex> is a monotone class, then <fr:tex display="inline"><![CDATA[\mathscr {F}_{0}\subset \mathscr {A}]]></fr:tex> implies <fr:tex display="inline"><![CDATA[\sigma (\mathscr {F}_{0})\subset \mathscr {A}]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>

<html:p>Also for completeness, we introduce completeness lol.</html:p>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001F/</fr:uri><fr:display-uri>001F</fr:display-uri><fr:route>/001F/</fr:route><fr:title text="Completeness of a measure">Completeness of a measure</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
A probability measure <fr:tex display="inline"><![CDATA[(\Omega , \mathcal {F}, P)]]></fr:tex> is <html:em>complete</html:em> if for <fr:tex display="inline"><![CDATA[A \subset  B]]></fr:tex> if <fr:tex display="inline"><![CDATA[P(B) = 0]]></fr:tex> then <fr:tex display="inline"><![CDATA[P(A) = 0]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>

<html:p>You might be wondering when this is not the case because we have subadditivity. However, it is not the case that <fr:tex display="inline"><![CDATA[P(A) > 0]]></fr:tex> but instead that <fr:tex display="inline"><![CDATA[A]]></fr:tex> is not measurable. As an example,</html:p>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>11</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001G/</fr:uri><fr:display-uri>001G</fr:display-uri><fr:route>/001G/</fr:route><fr:title text="Vitali Sets">Vitali Sets</fr:title><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If we consider <fr:tex display="inline"><![CDATA[[0,1]]]></fr:tex>, then we can partition <fr:tex display="inline"><![CDATA[[0, 1]]]></fr:tex> into equivalent classes as <fr:tex display="inline"><![CDATA[x \sim  y]]></fr:tex> if <fr:tex display="inline"><![CDATA[x - y = r]]></fr:tex> for some <fr:tex display="inline"><![CDATA[r \in  \mathbb {Q} \cap  [0, 1]]]></fr:tex>. Denote each of these as <fr:tex display="inline"><![CDATA[V_{r}]]></fr:tex>. By the <fr:link href="/001H/" title="Axiom of Choice" uri="https://kellenkanarios.com/001H/" display-uri="001H" type="local">Axiom of Choice</fr:link>, we can choose one representative from each <fr:tex display="inline"><![CDATA[V_r]]></fr:tex>. We call the set of these representatives <fr:tex display="inline"><![CDATA[V]]></fr:tex>. Therefore, we can write <fr:tex display="inline"><![CDATA[[0, 1]]]></fr:tex> as a countable union via <fr:tex display="inline"><![CDATA[[0,1] = \bigcup _{r \in  \mathbb {Q}} V + r]]></fr:tex>. For the Lebesgue measure <fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>, each <fr:tex display="inline"><![CDATA[\lambda (V + r) = \lambda (V)]]></fr:tex>. Since each <fr:tex display="inline"><![CDATA[V + r]]></fr:tex> is disjoint, we have 
<fr:tex display="block"><![CDATA[\lambda \left (\bigcup _{r \in  \mathbb {Q}} V + r\right ) = \sum _{r \in  \mathbb {Q}} \lambda (V)]]></fr:tex>
If <fr:tex display="inline"><![CDATA[\lambda (V) = 0]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\lambda ([0,1]) \leq  \lambda (V) = 0]]></fr:tex> which is a contradiction. Otherwise <fr:tex display="inline"><![CDATA[\lambda  ([0,1]) = \sum _{r \in  \mathbb {Q}} k = \infty ]]></fr:tex> for some <fr:tex display="inline"><![CDATA[k \in  \mathbb {R}]]></fr:tex>. Thus, <fr:tex display="inline"><![CDATA[V]]></fr:tex> is not Lebesgue measurable.
</html:p></fr:mainmatter></fr:tree>


  
    
    
    <fr:tree show-metadata="false" toc="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure ›  [billingsleyProbabilityMeasure1995, 3.2]"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> ›  <html:span class="link-reference" tid="3.2" refid="billingsleyProbabilityMeasure1995"><fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">[billingsleyProbabilityMeasure1995, 3.2]</fr:link></html:span></fr:title><fr:taxon>Exercise</fr:taxon></fr:frontmatter><fr:mainmatter>
  
  Let <fr:tex display="inline"><![CDATA[P]]></fr:tex> be a probability measure on a field <fr:tex display="inline"><![CDATA[\mathscr {F}_{0}]]></fr:tex> and for every subset <fr:tex display="inline"><![CDATA[A]]></fr:tex> of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> define <fr:tex display="inline"><![CDATA[P^{\star }(A)]]></fr:tex> by <fr:link href="/000T/" title="Outer Measure" uri="https://kellenkanarios.com/000T/" display-uri="000T" type="local">(3.1)</fr:link>. Denote also by <fr:tex display="inline"><![CDATA[P]]></fr:tex> the extension of <fr:tex display="inline"><![CDATA[P]]></fr:tex> to <fr:tex display="inline"><![CDATA[\mathscr {F}=\sigma (\mathscr {F}_{0})]]></fr:tex>.
  <html:ol><html:li>Show that <fr:tex display="inline"><![CDATA[A]]></fr:tex> is <fr:link href="/000U/" title="P^*-measurable" uri="https://kellenkanarios.com/000U/" display-uri="000U" type="local"><fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> if and only if <fr:tex display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>.</html:li></html:ol>

</fr:mainmatter></fr:tree>
  


 
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Solution</fr:taxon></fr:frontmatter><fr:mainmatter>
  <html:p>First suppose that <fr:tex display="inline"><![CDATA[P^*(A) = P_*(A)]]></fr:tex>. Let <fr:tex display="inline"><![CDATA[E \subset  \Omega ]]></fr:tex>. We must show that 
<fr:tex display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) = P^*(E)]]></fr:tex>
  From part (1) and our hypothesis, <fr:tex display="inline"><![CDATA[\exists  \overline {A}, \underline {A} \in  \mathscr {F}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[\underline {A} \subset  A \subset  \overline {A}]]></fr:tex> and <fr:tex display="block"><![CDATA[P(\overline {A}) = P^*(A) = P_*(A) = P(\underline {A})]]></fr:tex>. Additionally, <fr:tex display="inline"><![CDATA[\exists  B \in  \mathscr {F}]]></fr:tex> such that <fr:tex display="inline"><![CDATA[E \subset  B]]></fr:tex> and <fr:tex display="inline"><![CDATA[P^*(E) = P(B)]]></fr:tex>. Then we have that
<fr:tex display="block"><![CDATA[P^*(E \cap  A) \leq  P^*(B \cap  \overline {A}) = P(B \cap  \overline {A})]]></fr:tex>
  and
<fr:tex display="block"><![CDATA[P^*(B \cap  A) \leq  P^*(B \cap  \underline {A}^c) = P(B \cap  \underline {A}^c)]]></fr:tex>
  Thus,
<fr:tex display="block"><![CDATA[P^*(E \cap  A) + P^*(E \cap  A^c) \leq  P(B \cap  \underline {A}^c) + P(B \cap  \overline {A}) = P^*(E)]]></fr:tex>
  as desired.
  </html:p>
</fr:mainmatter></fr:tree>
 



    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>I really struggled for a minute on even understanding this problem. The import thing to understand for this problem is what space everything is defined on.
<html:ol><html:li><fr:tex display="inline"><![CDATA[P]]></fr:tex> is defined on the initial field <fr:tex display="inline"><![CDATA[\mathscr {F}_0]]></fr:tex>, which is the closure over finite unions and complements of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>.</html:li>
    <html:li><fr:tex display="inline"><![CDATA[P^*]]></fr:tex> is defined on the powerset <fr:tex display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex>. <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> is <html:strong>NOT</html:strong> necessarily a measure on all of these subsets though.
    <html:ul><html:li><fr:tex display="inline"><![CDATA[E]]></fr:tex> is <html:strong>NOT</html:strong> necessarily in <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> hence the need for <fr:tex display="inline"><![CDATA[B]]></fr:tex>.</html:li></html:ul></html:li>
    <html:li><fr:tex display="inline"><![CDATA[P]]></fr:tex> (abuse of notation) is <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> restricted to the <fr:link href="/000U/" title="P^*-measurable" uri="https://kellenkanarios.com/000U/" display-uri="000U" type="local"><fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> subsets of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>.</html:li></html:ol>
  Common question is why we cannot just apply finite additivity and have everything <fr:link href="/000U/" title="P^*-measurable" uri="https://kellenkanarios.com/000U/" display-uri="000U" type="local"><fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link>? The answer is that <fr:tex display="inline"><![CDATA[P^*]]></fr:tex> is not countably subadditive on <fr:tex display="inline"><![CDATA[\mathcal {P}(\Omega )]]></fr:tex> but only the <fr:link href="/000U/" title="P^*-measurable" uri="https://kellenkanarios.com/000U/" display-uri="000U" type="local"><fr:tex display="inline"><![CDATA[P^*]]></fr:tex>-measurable</fr:link> sets.
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Denumerable Probabilities">Denumerable Probabilities</fr:title></fr:frontmatter><fr:mainmatter>
The results of this section concern infinite sequences of events in a probability space. They will be illustrated by examples in the unit interval. By this will always be meant the triple (<fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>, <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex>, <fr:tex display="inline"><![CDATA[P]]></fr:tex>) for which <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> is (0,1), <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> is the <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field <fr:tex display="inline"><![CDATA[\mathscr {B}]]></fr:tex> of Borel sets there, and <fr:tex display="inline"><![CDATA[P(A)]]></fr:tex> is for <fr:tex display="inline"><![CDATA[A]]></fr:tex> in <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex> the Lebesgue measure <fr:tex display="inline"><![CDATA[\lambda (A)]]></fr:tex> of <fr:tex display="inline"><![CDATA[A]]></fr:tex>. 
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001J/</fr:uri><fr:display-uri>001J</fr:display-uri><fr:route>/001J/</fr:route><fr:title text="Conditional Probability">Conditional Probability</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[P(A | B) = \frac {P(A \cap  B)}{P(B)}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001I/</fr:uri><fr:display-uri>001I</fr:display-uri><fr:route>/001I/</fr:route><fr:title text="Chain Rule of Probability">Chain Rule of Probability</fr:title><fr:taxon>Proposition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[P(A \cap  B \cap  C) = P(A)P(B | A)P(C | B \cap  A)]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001M/</fr:uri><fr:display-uri>001M</fr:display-uri><fr:route>/001M/</fr:route><fr:title text="limsup of sets">limsup of sets</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For a sequence <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex display="block"><![CDATA[\lim \sup _{n} A_n = \bigcap _{n = 1}^{\infty } \bigcup _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex display="inline"><![CDATA[\lim \sup _{n} A_{n}]]></fr:tex> if <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex display="inline"><![CDATA[A_{n}]]></fr:tex> infinitely often.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001N/</fr:uri><fr:display-uri>001N</fr:display-uri><fr:route>/001N/</fr:route><fr:title text="liminf of sets">liminf of sets</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For a sequence <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of sets, we define 
<fr:tex display="block"><![CDATA[\lim \inf _{n} A_n = \bigcup _{n = 1}^{\infty } \bigcap _{k = n}^{\infty } A_k]]></fr:tex>
In english, an element <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> is in <fr:tex display="inline"><![CDATA[\lim \inf _{n} A_{n}]]></fr:tex> if <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> is in all but finitely many <fr:tex display="inline"><![CDATA[A_{n}]]></fr:tex>.
  </html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001K/</fr:uri><fr:display-uri>001K</fr:display-uri><fr:route>/001K/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
For each sequence <fr:tex display="inline"><![CDATA[\{A_{n}\}]]></fr:tex>,

<fr:tex display="block"><![CDATA[P\left (\lim \inf _{n}A_{n}\right )\leq \lim _{n}\inf _{n}P\left (\,A_{n}\right ) \leq \lim _{n}\sup _{n}P\left (\,A_{n}\right )\leq  P\left (\lim _{n}\sup _{n}A_{n}\right ).]]></fr:tex></html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>2</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    We define <fr:tex display="inline"><![CDATA[B_n \coloneqq  \bigcup _{k = n}^{\infty } A_k]]></fr:tex> and <fr:tex display="inline"><![CDATA[B_n]]></fr:tex> as <fr:tex display="inline"><![CDATA[C_n = \bigcap _{k = n}^{\infty } A_k]]></fr:tex>. Note that <fr:tex display="inline"><![CDATA[\{B_n\}]]></fr:tex> is a monotonically decreasing sequence to <fr:tex display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex>, and <fr:tex display="inline"><![CDATA[C_n]]></fr:tex> monotonically increases to <fr:tex display="inline"><![CDATA[\lim \inf _{n} A_n]]></fr:tex>. Therefore, we can apply continuity from below / above such that
<fr:tex display="block"><![CDATA[
    \begin {align*}
    \inf _n P(A_n) \geq  P(C_n) \iff  \lim _n \inf _n P(A_n) &\geq  \lim _n P(C_n) \\ 
    &= P(\lim _n C_n) \\ 
    &= P(\lim \inf _n A_n)
    \end {align*}
]]></fr:tex>
      Similarly,
<fr:tex display="block"><![CDATA[
      \begin {align*}
      \sup _n P(A_n) \leq  P(B_n) \iff  \lim _n \sup _n P(A_n) &\leq  \lim _n P(B_n) \\ 
      &= P(\lim _n B_n) \\ 
      &= P(\lim \sup _n A_n)
      \end {align*}
  ]]></fr:tex>
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>26</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001O/</fr:uri><fr:display-uri>001O</fr:display-uri><fr:route>/001O/</fr:route><fr:title text="Independence">Independence</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>
  Independence evolves in the following manner:
  <html:ol><html:li>Events <fr:tex display="inline"><![CDATA[A]]></fr:tex> and <fr:tex display="inline"><![CDATA[B]]></fr:tex> are independent if <fr:tex display="inline"><![CDATA[P(A \cap  B) = P(A)P(B)]]></fr:tex>. </html:li>
    <html:li>A finite collection of events are independent if
    <fr:tex display="block"><![CDATA[P(A_{k_1} \cap  \cdots  \cap  A_{k_j}) = P(A_{k_1}) \cdots  P(A_{k_j})]]></fr:tex></html:li>
    <html:li>A infinite collection of sets is defined to be independent if every finite subcollection is independent.</html:li>
    <html:li>Classes <fr:tex display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent if for any events <fr:tex display="inline"><![CDATA[A_1 \in  \mathscr {A}_1, \ldots , A_n \in  \mathscr {A}_n]]></fr:tex>, <fr:tex display="inline"><![CDATA[A_1, \ldots , A_n]]></fr:tex> are independent.</html:li></html:ol></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001P/</fr:uri><fr:display-uri>001P</fr:display-uri><fr:route>/001P/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\mathscr {A}_1, \ldots , \mathscr {A}_n]]></fr:tex> are independent and each <fr:tex display="inline"><![CDATA[\mathscr {A}_i]]></fr:tex> is a <fr:link href="/0018/" title="\pi -system" uri="https://kellenkanarios.com/0018/" display-uri="0018" type="local"><fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> then <fr:tex display="inline"><![CDATA[\sigma (\mathscr {A}_1), \ldots , \sigma (\mathscr {A}_n)]]></fr:tex> are independent.</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
We have sequence of independent classes and want to show that their respective <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-algebras are also independent. The idea is to take the class of events <fr:tex display="inline"><![CDATA[B_1]]></fr:tex> that are independent with <fr:tex display="inline"><![CDATA[\mathscr {A}_2, \ldots , \mathscr {A}_n]]></fr:tex>, and show that <fr:tex display="inline"><![CDATA[\sigma (\mathscr {A}_1)]]></fr:tex> is a subset of this class. To do this, we use <fr:link href="/001B/" title="Dynkin's \pi \text {-}\lambda " uri="https://kellenkanarios.com/001B/" display-uri="001B" type="local">Dynkin's <fr:tex display="inline"><![CDATA[\pi \text {-}\lambda ]]></fr:tex></fr:link> by noticing that this class is a <fr:link href="/0019/" title="\lambda -system" uri="https://kellenkanarios.com/0019/" display-uri="0019" type="local"><fr:tex display="inline"><![CDATA[\lambda ]]></fr:tex>-system</fr:link> that contains the <fr:link href="/0018/" title="\pi -system" uri="https://kellenkanarios.com/0018/" display-uri="0018" type="local"><fr:tex display="inline"><![CDATA[\pi ]]></fr:tex>-system</fr:link> <fr:tex display="inline"><![CDATA[\mathscr {A}_1]]></fr:tex>.
</fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
<html:p><html:strong>Meaning in english:</html:strong> In the book, they give the example of even and odd numbered coin tosses. We want to know when a new event only depends on even or odd coin tosses. Concretely, we know that even and odd coin tosses are independent, and we want to know if, for example, the outcome of every fourth coin toss is independent of odd tosses. We can do this rigorously by showing that this event is in the <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra of even coin tosses. Then by <fr:link href="/001P/" title="https://kellenkanarios.com/001P/" uri="https://kellenkanarios.com/001P/" display-uri="001P" type="local">Theorem 5.7</fr:link>, we know that this event is also independent of odd coin tosses.</html:p>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001R/</fr:uri><fr:display-uri>001R</fr:display-uri><fr:route>/001R/</fr:route><fr:title text="Array Method">Array Method</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Suppose that the array
<fr:tex display="block"><![CDATA[
\begin {array}{ccc}
A_{11} & A_{12} & \cdots  \\
A_{21} & A_{22} & \cdots  \\
\vdots  & \vdots  & 
\end {array}
]]></fr:tex>
of events is independent. If <fr:tex display="inline"><![CDATA[\mathscr {F}_1]]></fr:tex> is the <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-algebra generated
by the first row then <fr:tex display="inline"><![CDATA[\mathscr {F}_1, \mathscr {F}_2, \ldots ]]></fr:tex> are
independent.
</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>Can write events of flip <fr:tex display="inline"><![CDATA[i]]></fr:tex> as <fr:tex display="inline"><![CDATA[H_i]]></fr:tex> such that the following array
satisfies the above
<fr:tex display="block"><![CDATA[
\begin {array}{ccc}
H_{2} & H_{4} & \cdots  \\
H_{1} & H_3 & \cdots  \\
\end {array}
]]></fr:tex>
Then row 1 and row 2 are independent from above. Therefore, we have shown that
even and odd numbered flips' <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>'s are independent.
</fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Subfields"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Subfields</fr:title></fr:frontmatter><fr:mainmatter>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>Intuition of subfields are spaces with partial information. My best
memory of this coming up in probability was conditional expectation.
Esssentially, we need to consider the subfield of events conditioned on some
event that already occured.</fr:mainmatter></fr:tree>

<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001S/</fr:uri><fr:display-uri>001S</fr:display-uri><fr:route>/001S/</fr:route><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We say that points <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex display="inline"><![CDATA[\omega ']]></fr:tex> are <fr:tex display="inline"><![CDATA[\mathscr {A}]]></fr:tex> equivalent if for
every <fr:tex display="inline"><![CDATA[A \in  \mathscr {A}]]></fr:tex>,
<fr:tex display="block"><![CDATA[I_A(\omega ) = I_A(\omega ')]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<html:p>From this definition, we can conclude an observer with the information of
<fr:tex display="inline"><![CDATA[\sigma (\mathscr {A})]]></fr:tex> has only the information of the equivalence class but
cannot identify a specific point from this class.</html:p>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › The Borel-Cantelli Lemmas"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › The Borel-Cantelli Lemmas</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001Q/</fr:uri><fr:display-uri>001Q</fr:display-uri><fr:route>/001Q/</fr:route><fr:title text="Borel-Cantelli One">Borel-Cantelli One</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> converges, then <fr:tex display="inline"><![CDATA[P(\lim \sup _n A_n) = 0]]></fr:tex>.</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    Recall that <fr:tex display="inline"><![CDATA[\lim \sup _n A_n \subset  \bigcup _{k = n}^{\infty } A_k]]></fr:tex>.
    Therefore,
      <fr:tex display="block"><![CDATA[P(\lim \sup _n A_n) \leq  P\left (\bigcup _{k = n}^{\infty } A_k\right ) \leq 
      \sum _{k = n}^{\infty } P(A_k)]]></fr:tex>
      Taking <fr:tex display="inline"><![CDATA[n \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001T/</fr:uri><fr:display-uri>001T</fr:display-uri><fr:route>/001T/</fr:route><fr:title text="Borel-Cantelli Two">Borel-Cantelli Two</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\{A_n\}]]></fr:tex> is an independent sequence of events and <fr:tex display="inline"><![CDATA[\sum _{n}P(A_n)]]></fr:tex> diverges, then <fr:tex display="inline"><![CDATA[P(\lim \sup _n A_n) = 1]]></fr:tex>.</html:p>
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
    Consider the complement. By independence, we have
<fr:tex display="block"><![CDATA[P(\bigcap _{k = n}^{n + m} A_k^c) = \prod _{k = n}^{n + m}(1 - P(A_k)) \leq 
    \exp (-\sum _{k = n}^{n + m} P(A_k)),]]></fr:tex>
    where the last inequality comes from <fr:tex display="inline"><![CDATA[1 - x \leq  e^{-x}]]></fr:tex>. Since the series diverges, taking <fr:tex display="inline"><![CDATA[m \to  \infty ]]></fr:tex> yields the desired result.
  </fr:mainmatter></fr:tree>
 

</fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>


  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Zero-one Law"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Zero-one Law</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001U/</fr:uri><fr:display-uri>001U</fr:display-uri><fr:route>/001U/</fr:route><fr:title text="Tail \sigma -field">Tail <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>For a sequence <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> of events in a probability space <fr:tex display="inline"><![CDATA[(\Omega ,
\mathscr {F}, P)]]></fr:tex> consider the <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-fields <fr:tex display="inline"><![CDATA[\sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
then their intersection
<fr:tex display="block"><![CDATA[\mathscr {T} = \bigcap _{n = 1}^{\infty } \sigma (A_n, A_{n+1}, \ldots )]]></fr:tex>
is the <html:em>tail <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</html:em> associated with the sequence <fr:tex display="inline"><![CDATA[\{A_n\}]]></fr:tex>.
</html:p></fr:mainmatter></fr:tree>

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>The <fr:tex display="inline"><![CDATA[\lim \sup _n A_n]]></fr:tex> and <fr:tex display="inline"><![CDATA[\lim \inf _n A_n]]></fr:tex> are both tail events.</fr:mainmatter></fr:tree>
 

  </fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>27</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001V/</fr:uri><fr:display-uri>001V</fr:display-uri><fr:route>/001V/</fr:route><fr:title text="Kolmogorov's Zero-one Law">Kolmogorov's Zero-one Law</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[A_1, A_2, \ldots ]]></fr:tex> is an independent sequence of events, then for each
event <fr:tex display="inline"><![CDATA[A]]></fr:tex> in the <fr:link href="/001U/" title="Tail \sigma -field" uri="https://kellenkanarios.com/001U/" display-uri="001U" type="local">Tail <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, <fr:tex display="inline"><![CDATA[P(A)]]></fr:tex> is either <fr:tex display="inline"><![CDATA[0]]></fr:tex> or <fr:tex display="inline"><![CDATA[1]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Random Variables">Random Variables</fr:title></fr:frontmatter><fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001W/</fr:uri><fr:display-uri>001W</fr:display-uri><fr:route>/001W/</fr:route><fr:title text="Simple Random Variable">Simple Random Variable</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> be an arbitrary probability space, and let <fr:tex display="inline"><![CDATA[X]]></fr:tex> be a real-valued function on <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex>. <fr:tex display="inline"><![CDATA[X]]></fr:tex> is a simple random variable if it has finite range and if 
<fr:tex display="block"><![CDATA[\left [\omega  \mid  X(\omega ) = x \right ] \in  \mathscr {F}]]></fr:tex>
for each <fr:tex display="inline"><![CDATA[x]]></fr:tex> in its finite range.
</html:p></fr:mainmatter></fr:tree>
  
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>
    Consider the function 
    <fr:tex display="block"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex>
    If <fr:tex display="inline"><![CDATA[A_i]]></fr:tex> are finite partition of <fr:tex display="inline"><![CDATA[\Omega ]]></fr:tex> into <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-sets, then inverse image is at most countable union of the A_i's, which is an <fr:tex display="inline"><![CDATA[\mathscr {F}]]></fr:tex>-set. Therefore, this function is measurable.
  </fr:mainmatter></fr:tree>
 

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0022/</fr:uri><fr:display-uri>0022</fr:display-uri><fr:route>/0022/</fr:route><fr:title text="Finite Sequence Measurability">Finite Sequence Measurability</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[X_1, \ldots , X_n]]></fr:tex> be <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link>'s
<html:ol><html:li>The <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> <fr:tex display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> consists of the sets
<fr:tex display="block"><![CDATA[\left [(X_1, \ldots , X_n) \in  H\right ] = \left [\omega  \mid  (X_1(\omega ), \ldots , X_n(\omega )) \in  H\right ]]]></fr:tex>
    for <fr:tex display="inline"><![CDATA[H \subset  \mathbb {R}^n]]></fr:tex>.
    </html:li>
    <html:li>A simple random variable <fr:tex display="inline"><![CDATA[Y]]></fr:tex> is measurable <fr:tex display="inline"><![CDATA[\sigma (X_1, \ldots , X_n)]]></fr:tex> if and only if 
<fr:tex display="block"><![CDATA[Y = f(X_1, \ldots , X_n)]]></fr:tex>
    for some <fr:tex display="inline"><![CDATA[f: \mathbb {R}^n \to  \mathbb {R}]]></fr:tex>.
    </html:li></html:ol></html:p></fr:mainmatter></fr:tree>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001X/</fr:uri><fr:display-uri>001X</fr:display-uri><fr:route>/001X/</fr:route><fr:title text="\sigma -field of RV"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field of RV</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field generated by a <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link> is the smallest <fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field such that the <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link> is <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">measurable</fr:link>. For a sequence of <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link>'s, the <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link> generated by them is the smallest <fr:link href="/000O/" title="\sigma -field" uri="https://kellenkanarios.com/000O/" display-uri="000O" type="local"><fr:tex display="inline"><![CDATA[\sigma ]]></fr:tex>-field</fr:link>, such that each of the <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link>'s is measurable.
</html:p></fr:mainmatter></fr:tree>
  
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Convergence of Random Variables"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Convergence of Random Variables</fr:title></fr:frontmatter><fr:mainmatter>
In probability, rather than standard convergence, we actually can consider convergence with high probability or almost surely (should come up later). Formally, we care about measuring the probability of the event <fr:tex display="inline"><![CDATA[\{\omega  \mid  \lim _n X_n(\omega ) \to  X(\omega )\}]]></fr:tex>. The first question we must ask is whether this set is measurable. They do not really cover this in the textbook, but it is an important trick that comes up a lot.

   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Proof</fr:taxon></fr:frontmatter><fr:mainmatter>
We consider the complement. Note that the sequence of random variables not converging can be written as <fr:tex display="inline"><![CDATA[\forall  \epsilon , \exists  n]]></fr:tex> such that <fr:tex display="inline"><![CDATA[|X_n(\omega ) - X(\omega )| \geq  \epsilon ]]></fr:tex>. For a fixed <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>, this is the <fr:tex display="inline"><![CDATA[\lim \sup ]]></fr:tex> of the sequence <fr:tex display="inline"><![CDATA[A_n \coloneqq  [|X_n - X| \geq  \epsilon ]]]></fr:tex>. We know that <fr:tex display="inline"><![CDATA[\lim \sup ]]></fr:tex> of measurable sequence is measurable because it is a countable intersection of countable unions. Therefore, the last thing we need is to show for all <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>. This can be done just using rationals because <fr:tex display="inline"><![CDATA[\mathbb {Q}]]></fr:tex> is <fr:link href="/001Y/" title="Dense Subset" uri="https://kellenkanarios.com/001Y/" display-uri="001Y" type="local">dense</fr:link> in <fr:tex display="inline"><![CDATA[\mathbb {R}]]></fr:tex>. Then we have a countable union of countable sets as desired.
  </fr:mainmatter></fr:tree>
 


    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/001Z/</fr:uri><fr:display-uri>001Z</fr:display-uri><fr:route>/001Z/</fr:route><fr:title text="Almost Sure Convergence">Almost Sure Convergence</fr:title></fr:frontmatter><fr:mainmatter><html:p>A <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link> converges <html:em>almost surely</html:em> if 
<fr:tex display="block"><![CDATA[P(X_n \to  X) = 1]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0020/</fr:uri><fr:display-uri>0020</fr:display-uri><fr:route>/0020/</fr:route><fr:title text="Convergence in Probability">Convergence in Probability</fr:title></fr:frontmatter><fr:mainmatter><html:p>A <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link> converges <html:em>in probability</html:em> if for every <fr:tex display="inline"><![CDATA[\epsilon ]]></fr:tex>
<fr:tex display="block"><![CDATA[\lim _{n \to  \infty } P(|X_n - X| > \epsilon ) = 0]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
        By <fr:link href="/001K/" title="https://kellenkanarios.com/001K/" uri="https://kellenkanarios.com/001K/" display-uri="001K" type="local">Theorem 5.5</fr:link>, almost sure convergence <fr:tex display="inline"><![CDATA[\implies ]]></fr:tex> convergence in probability. Converse is NOT true.
      </fr:mainmatter></fr:tree>

      
   
   <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Example</fr:taxon></fr:frontmatter><fr:mainmatter>Can make array of rows, where the <fr:tex display="inline"><![CDATA[n]]></fr:tex>th row consists of <fr:tex display="inline"><![CDATA[n]]></fr:tex> intervals that evenly divide <fr:tex display="inline"><![CDATA[[0,1]]]></fr:tex>. Then <fr:tex display="inline"><![CDATA[P(A_n) \to  0]]></fr:tex> but <fr:tex display="inline"><![CDATA[[A_n \text { i.o}] = [0,1]]]></fr:tex> </fr:mainmatter></fr:tree>
 

    </fr:mainmatter></fr:tree>

    
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Independence"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Independence</fr:title></fr:frontmatter><fr:mainmatter>
        <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0021/</fr:uri><fr:display-uri>0021</fr:display-uri><fr:route>/0021/</fr:route><fr:title text="Independence of Random Variable">Independence of Random Variable</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A sequence of random variables <fr:tex display="inline"><![CDATA[X_1, X_2, \ldots ]]></fr:tex> is <html:em>independent</html:em> if the classes <fr:tex display="inline"><![CDATA[\sigma (X_1), \sigma (X_2), \ldots ]]></fr:tex> are <fr:link href="/001O/" title="Independence" uri="https://kellenkanarios.com/001O/" display-uri="001O" type="local">independent</fr:link>.</html:p></fr:mainmatter></fr:tree>
      </fr:mainmatter></fr:tree>

    
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Existence of Independent Sequences"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Existence of Independent Sequences</fr:title></fr:frontmatter><fr:mainmatter>
        <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0023/</fr:uri><fr:display-uri>0023</fr:display-uri><fr:route>/0023/</fr:route><fr:title text="Distribution">Distribution</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>The <html:em>distribution</html:em> of a simple random variable <fr:tex display="inline"><![CDATA[X]]></fr:tex> is the probability measure <fr:tex display="inline"><![CDATA[\mu ]]></fr:tex> defined for all subsets <fr:tex display="inline"><![CDATA[A]]></fr:tex> of the line by 
<fr:tex display="block"><![CDATA[\mu (A) = P[X \in  A]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
        <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0024/</fr:uri><fr:display-uri>0024</fr:display-uri><fr:route>/0024/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Let <fr:tex display="inline"><![CDATA[\{\mu _n\}]]></fr:tex> be a sequence of probability measures on the class of all subsets of the line, each having finite support. There exists some probability space <fr:tex display="inline"><![CDATA[(\Omega , \mathscr {F}, P)]]></fr:tex> an independent sequence <fr:tex display="inline"><![CDATA[\{X_n\}]]></fr:tex> of <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link>'s such that <fr:tex display="inline"><![CDATA[X_n]]></fr:tex> has distribution <fr:tex display="inline"><![CDATA[\mu _n]]></fr:tex>.</html:p></fr:mainmatter></fr:tree>
<html:p><html:strong>Guess for english translation</html:strong>: I think what this is saying is that rather than try to define a probability space for a random variable, we can instead just pick probability measures and know that the <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link> come for free? i.e. (from the book) we can just define a trivial space <fr:tex display="inline"><![CDATA[\Omega  = \{1, 0\}]]></fr:tex> and probability measure <fr:tex display="inline"><![CDATA[P(1) = p]]></fr:tex>, <fr:tex display="inline"><![CDATA[P(0) = 1 - p]]></fr:tex> and know that we can get a Bernoulli random variable? In this case <fr:tex display="inline"><![CDATA[X(1) = 1]]></fr:tex>, <fr:tex display="inline"><![CDATA[X(0) = 0]]></fr:tex> such that <fr:tex display="inline"><![CDATA[P(X = 1) = p]]></fr:tex> and <fr:tex display="inline"><![CDATA[P(X = 0) = 1 - p]]></fr:tex>?</html:p>

  
    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>In the text, they say that the underlying probability space does not really matter. Basically, all calculations are determined by the distribution in range space. So I guess that is also what this theorem is getting at? </fr:mainmatter></fr:tree>

  </fr:mainmatter></fr:tree>


  
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Expected Value"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Expected Value</fr:title></fr:frontmatter><fr:mainmatter>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/0029/</fr:uri><fr:display-uri>0029</fr:display-uri><fr:route>/0029/</fr:route><fr:title text="Expected Value">Expected Value</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>A <fr:link href="/001W/" title="Simple Random Variable" uri="https://kellenkanarios.com/001W/" display-uri="001W" type="local">Simple Random Variable</fr:link> of the form <fr:tex display="inline"><![CDATA[X = \sum _{i} x_i I_{A_i}]]></fr:tex> is assigned expected value as 
<fr:tex display="block"><![CDATA[\mathbb {E}[X] = \mathbb {E}\left [\sum _i x_i I_{A_i} \right ] = \sum _i x_i P(A_i)]]></fr:tex>
More generally, if <fr:tex display="inline"><![CDATA[f(X) = \sum _i f(x_i) I_{A_i}]]></fr:tex> then
<fr:tex display="block"><![CDATA[\mathbb {E}\left [f(X)\right ] = \sum _i f(x_i) P(A_i) = \sum _x f(x) P[X = x]]]></fr:tex>
A useful identity is as follows:
<fr:tex display="block"><![CDATA[\mathbb {E}[X] = \int _0^{\infty } P[X \geq  x] \mathrm {d}x]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002A/</fr:uri><fr:display-uri>002A</fr:display-uri><fr:route>/002A/</fr:route><fr:title text="kth Moment"><fr:tex display="inline"><![CDATA[k]]></fr:tex>th Moment</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>We define the <fr:tex display="inline"><![CDATA[k]]></fr:tex>th moment of <fr:tex display="inline"><![CDATA[X]]></fr:tex> as 
<fr:tex display="block"><![CDATA[\mathbb {E}[X^k] = \sum _y y P[X^k = y]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002B/</fr:uri><fr:display-uri>002B</fr:display-uri><fr:route>/002B/</fr:route><fr:title text="Uniformly Bounded">Uniformly Bounded</fr:title><fr:taxon>Definition</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\exists  K]]></fr:tex> such that <fr:tex display="inline"><![CDATA[X_n(\omega ) \leq  K]]></fr:tex> for every <fr:tex display="inline"><![CDATA[\omega ]]></fr:tex> and <fr:tex display="inline"><![CDATA[n]]></fr:tex> then the <fr:tex display="inline"><![CDATA[X_n]]></fr:tex> are <html:em>uniformly bounded</html:em>.</html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>28</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002C/</fr:uri><fr:display-uri>002C</fr:display-uri><fr:route>/002C/</fr:route><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\{X_n\}]]></fr:tex> is uniformly bounded, and if <fr:tex display="inline"><![CDATA[X = \lim _n X_n]]></fr:tex> with probability <fr:tex display="inline"><![CDATA[1]]></fr:tex>, then <fr:tex display="inline"><![CDATA[\mathbb {E}[X] = \lim _n \mathbb {E}[X]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    </fr:mainmatter></fr:tree>

  
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="Notebook: Probability and measure › Inequalities"><fr:link href="/0007/" title="Notebook: Probability and measure" uri="https://kellenkanarios.com/0007/" display-uri="0007" type="local">Notebook: <fr:link href="/billingsleyProbabilityMeasure1995/" title="Probability and measure" uri="https://kellenkanarios.com/billingsleyProbabilityMeasure1995/" display-uri="billingsleyProbabilityMeasure1995" type="local">Probability and measure</fr:link></fr:link> › Inequalities</fr:title></fr:frontmatter><fr:mainmatter>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002E/</fr:uri><fr:display-uri>002E</fr:display-uri><fr:route>/002E/</fr:route><fr:title text="Markov's Inequality">Markov's Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[P[X \geq  \alpha ] \leq  \frac {1}{\alpha } \mathbb {E}[X]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002F/</fr:uri><fr:display-uri>002F</fr:display-uri><fr:route>/002F/</fr:route><fr:title text="Chebyshev's Inequality">Chebyshev's Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p><fr:tex display="block"><![CDATA[P[|X - m| \geq  \alpha ] \leq  \frac {1}{\alpha ^2} \mathrm {Var}[X]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002G/</fr:uri><fr:display-uri>002G</fr:display-uri><fr:route>/002G/</fr:route><fr:title text="Jensen's Inequality">Jensen's Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>If <fr:tex display="inline"><![CDATA[\phi ]]></fr:tex> is a convex function on the range of <fr:tex display="inline"><![CDATA[X]]></fr:tex> then <fr:tex display="block"><![CDATA[\phi (\mathbb {E}[X]) \leq  \mathbb {E}[\phi (X)]]]></fr:tex></html:p></fr:mainmatter></fr:tree>
<fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2024</fr:year><fr:month>12</fr:month><fr:day>29</fr:day></fr:date><fr:uri>https://kellenkanarios.com/002H/</fr:uri><fr:display-uri>002H</fr:display-uri><fr:route>/002H/</fr:route><fr:title text="Holder's Inequality">Holder's Inequality</fr:title><fr:taxon>Theorem</fr:taxon></fr:frontmatter><fr:mainmatter><html:p>Suppose that 
<fr:tex display="block"><![CDATA[\frac {1}{p} + \frac {1}{q} = 1, \quad  p > 1,\ q > 1]]></fr:tex>
Then <html:em>Holder's inequality</html:em> is
<fr:tex display="block"><![CDATA[\mathbb {E}[XY] \leq  \left (\mathbb {E}[|X|^p]\right )^{1/p} \cdot  \left (\mathbb {E}[|Y|^q]\right )^{1/q}]]></fr:tex></html:p></fr:mainmatter></fr:tree>
    </fr:mainmatter></fr:tree>
 
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2024</fr:year><fr:month>10</fr:month><fr:day>30</fr:day></fr:date><fr:title text="The Law of Large Numbers">The Law of Large Numbers</fr:title></fr:frontmatter><fr:mainmatter>

  </fr:mainmatter></fr:tree>
</fr:mainmatter>
    </fr:tree>
  </fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:uri>https://kellenkanarios.com/about/</fr:uri>
            <fr:display-uri>about</fr:display-uri>
            <fr:route>/about/</fr:route>
            <fr:title text="Kellen Kanarios › About this website"><fr:link href="/index/" title="Kellen Kanarios" uri="https://kellenkanarios.com/index/" display-uri="index" type="local">Kellen Kanarios</fr:link> › About this website</fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>
    This is my <fr:link href="https://www.forester-notes.org/index/index.xml" type="external">forest</fr:link> (shoutout to <fr:link href="/jonmsterling/" title="Jon Sterling" uri="https://kellenkanarios.com/jonmsterling/" display-uri="jonmsterling" type="local">Jon Sterling</fr:link> who is remarkably helpful). This website functions both as a <fr:link href="https://en.wikipedia.org/wiki/Personal_knowledge_management" type="external">personal knowledge management system</fr:link>, where I store my notes in <fr:link href="/0015/" title="Notebooks" uri="https://kellenkanarios.com/0015/" display-uri="0015" type="local">notebooks</fr:link> and also have some additional external resources in <fr:link href="/0004/" title="/dev/null" uri="https://kellenkanarios.com/0004/" display-uri="0004" type="local">/dev/null</fr:link>. Additionally, I store my thoughts in a variety of consumption mediums. Namely, short-form notes / blog posts can be found in the "<fr:link href="/007L/" title="Marginalia" uri="https://kellenkanarios.com/007L/" display-uri="007L" type="local">marginalia</fr:link>". I also maintain two weekly posting obligations: a <fr:link href="/007S/" title="Weeknotes" uri="https://kellenkanarios.com/007S/" display-uri="007S" type="local">weeknotes / lifelog</fr:link> and a <fr:link href="/005G/" title="Research Bible" uri="https://kellenkanarios.com/005G/" display-uri="005G" type="local">paper of the week</fr:link>. 
      </html:p>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
