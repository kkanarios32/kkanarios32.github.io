<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/default.xsl"?>
<fr:tree xmlns:fr="http://www.forester-notes.org" xmlns:html="http://www.w3.org/1999/xhtml" xmlns:xml="http://www.w3.org/XML/1998/namespace" root="false" base-url="/">
  <fr:frontmatter>
    <fr:authors>
      <fr:author>
        <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
      </fr:author>
    </fr:authors>
    <fr:date>
      <fr:year>2025</fr:year>
      <fr:month>7</fr:month>
      <fr:day>1</fr:day>
    </fr:date>
    <fr:uri>https://kellenkanarios.com/003W/</fr:uri>
    <fr:display-uri>003W</fr:display-uri>
    <fr:route>/003W/</fr:route>
    <fr:title text="LLMs">LLMs</fr:title>
  </fr:frontmatter>
  <fr:mainmatter><html:p>This will be my backlog accumulator / dump of related resources for my journey through the dubious waters of <fr:link href="/stanford/" title="Stanford University" uri="https://kellenkanarios.com/stanford/" display-uri="stanford" type="local">Stanford's</fr:link> <fr:link href="https://stanford-cs336.github.io/spring2025/index.htmlschedule" type="external">CS336</fr:link> and the broader journey toward understanding industry-level LLMs.</html:p>


  <fr:tree show-metadata="false" numbered="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Reading List / Useful Resources">Reading List / Useful Resources</fr:title></fr:frontmatter><fr:mainmatter>
    <html:ul><html:li><fr:link href="https://hijkzzz.notion.site/rlhf-implementation-tricks?v=158d9a33ecc98132bf9e000c39227361" type="external">PPO + LLM Tricks</fr:link></html:li></html:ul>
</fr:mainmatter></fr:tree>

</fr:mainmatter>
  <fr:backmatter>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="References">References</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Context">Context</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Backlinks">Backlinks</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors>
              <fr:author>
                <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
              </fr:author>
            </fr:authors>
            <fr:date>
              <fr:year>2025</fr:year>
              <fr:month>7</fr:month>
              <fr:day>1</fr:day>
            </fr:date>
            <fr:uri>https://kellenkanarios.com/0085/</fr:uri>
            <fr:display-uri>0085</fr:display-uri>
            <fr:route>/0085/</fr:route>
            <fr:title text="Notebook: Stanford CS336">Notebook: <fr:link href="/stanford/" title="Stanford University" uri="https://kellenkanarios.com/stanford/" display-uri="stanford" type="local">Stanford</fr:link> <fr:link href="https://stanford-cs336.github.io/spring2025/index.htmlschedule" type="external">CS336</fr:link></fr:title>
          </fr:frontmatter>
          <fr:mainmatter>
            <html:p>Formal notebook for my journey in <fr:link href="/stanford/" title="Stanford University" uri="https://kellenkanarios.com/stanford/" display-uri="stanford" type="local">Stanford's</fr:link> <fr:link href="https://stanford-cs336.github.io/spring2025/index.htmlschedule" type="external">CS336</fr:link> as part of my <fr:link href="/003W/" title="LLMs" uri="https://kellenkanarios.com/003W/" display-uri="003W" type="local">LLM</fr:link> self-study endeavors.</html:p>
            <fr:tree show-metadata="false" expanded="false">
              <fr:frontmatter>
                <fr:authors>
                  <fr:author>
                    <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                  </fr:author>
                </fr:authors>
                <fr:date>
                  <fr:year>2025</fr:year>
                  <fr:month>7</fr:month>
                  <fr:day>1</fr:day>
                </fr:date>
                <fr:uri>https://kellenkanarios.com/0086/</fr:uri>
                <fr:display-uri>0086</fr:display-uri>
                <fr:route>/0086/</fr:route>
                <fr:title text="#Deliberate-Practice (2/66): CS336 Lecture 1"><fr:link href="/007U/" title="#Deliberate-Practice" uri="https://kellenkanarios.com/007U/" display-uri="007U" type="local"><![CDATA[#Deliberate-Practice]]></fr:link> (2/66): <fr:link href="/0085/" title="Notebook: Stanford CS336" uri="https://kellenkanarios.com/0085/" display-uri="0085" type="local">CS336</fr:link> Lecture 1</fr:title>
              </fr:frontmatter>
              <fr:mainmatter>
                <html:p>First they give a brief outline of the course (provided below) along with some of the challenges and problem definitions for each of the sections</html:p>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors />
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>7</fr:month>
                      <fr:day>3</fr:day>
                    </fr:date>
                    <fr:uri>https://kellenkanarios.com/DEQT/</fr:uri>
                    <fr:display-uri>DEQT</fr:display-uri>
                    <fr:route>/DEQT/</fr:route>
                    <fr:title text="Course outline">Course outline</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:title text="Basics">Basics</fr:title></fr:frontmatter><fr:mainmatter>
<html:ol><html:li>Tokenization</html:li>
  <html:li>Architecture</html:li>
  <html:li>Loss function</html:li>
  <html:li>Optimizer</html:li>
  <html:li>Learning rate</html:li></html:ol>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:title text="Systems">Systems</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p><html:strong>Goal:</html:strong> Squeeze the most out of the hardware. </html:p>
<html:ol><html:li><html:strong>Kernels</html:strong></html:li>
  <html:p>Basic idea is that the GPU needs to perform computation, but the data cannot fit on the GPU. GPU is the <html:em>factory</html:em> memory is the <html:em>warehouse</html:em></html:p>
  
 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
    <html:em>How do we best organize computation to maximize utilization of GPUs by minimizing data movement?</html:em>
  </html:div>

  <html:li><html:strong>Parallelism</html:strong></html:li>
  <html:p>Beyond one GPU, we must then learn how to scale these ideas to multiple GPUs.</html:p>
  <html:ul><html:li>Sharding</html:li>
    <html:li>{data,tensor,piple,sequence} parallelism</html:li>
    <html:li>Quantization</html:li>
    <html:li>Activation checkpointing</html:li>
    <html:li>CPU offloading</html:li></html:ul>
  <html:li><html:strong>Inference</html:strong></html:li>
  <html:p>Two phases: prefill and decode</html:p>
  <html:ul><html:li>In prefill all tokens are given and you just want to output the next coding (compute bound).</html:li>
    <html:li>In decoding, we need to output one token at a time (memory-bound). </html:li></html:ul></html:ol>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:title text="Scaling Laws">Scaling Laws</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p><html:strong>Goal:</html:strong> do experiments at small scale in order to pick hyperparameters for much more expensive runs at large scale.</html:p>
<html:ol><html:li>Scaling sequence</html:li>
  <html:li>Model complexity</html:li>
  <html:li>Loss metric</html:li>
  <html:li>Parametric form</html:li></html:ol>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:title text="Data">Data</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p><html:strong>Goal:</html:strong> what we want the model to actually do i.e. pick your data for your task.</html:p>
<html:ol><html:li>Evaluation</html:li>
  <html:li>Curation</html:li>
  <html:li>Transformation</html:li>
  <html:li>Filtering</html:li>
  <html:li>Deduplication</html:li>
  <html:li>Mixing</html:li></html:ol>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors /><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>3</fr:day></fr:date><fr:title text="Alignment">Alignment</fr:title></fr:frontmatter><fr:mainmatter>
<html:ol><html:li>Supervised fine-tuning</html:li>
  <html:li>Reinforcement learning</html:li>
  <html:li>Preference data</html:li>
  <html:li>Synthetic data</html:li>
  <html:li>Verifiers</html:li></html:ol>
</fr:mainmatter></fr:tree>
</fr:mainmatter>
                </fr:tree>
                <fr:tree show-metadata="false">
                  <fr:frontmatter>
                    <fr:authors>
                      <fr:author>
                        <fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link>
                      </fr:author>
                    </fr:authors>
                    <fr:date>
                      <fr:year>2025</fr:year>
                      <fr:month>7</fr:month>
                      <fr:day>1</fr:day>
                    </fr:date>
                    <fr:uri>https://kellenkanarios.com/0087/</fr:uri>
                    <fr:display-uri>0087</fr:display-uri>
                    <fr:route>/0087/</fr:route>
                    <fr:title text="Tokenization">Tokenization</fr:title>
                  </fr:frontmatter>
                  <fr:mainmatter>
  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Introduction">Introduction</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
A <html:em>tokenizer</html:em> is responsible for taking text and turning it into a numerical representation we can pass to a neural network i.e.
<fr:tex display="block"><![CDATA[\mathsf {encode}(\text {hello world}) \mapsto  \begin {bmatrix} 24912, & 2375 \end {bmatrix} ]]></fr:tex>
    However, we also need 
    <fr:tex display="block"><![CDATA[\mathsf {decode}(\begin {bmatrix} 24912, & 2375 \end {bmatrix}) \mapsto  \text {hello world} 
    ]]></fr:tex>
 When defining a "good" tokenizer, we are concerned with the <html:em>compression ratio</html:em> i.e. the # of bytes per token.
    </html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Character-based tokenization">Character-based tokenization</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>Trivially, we can do <html:em>character-based tokenization</html:em> i.e. mapping each character to a unique number. For example, <fr:tex display="inline"><![CDATA[\mathsf {chr}(97) = \text {``a''}]]></fr:tex> and <fr:tex display="inline"><![CDATA[\mathsf {ord}(\text {``a''}) = 97]]></fr:tex>. The compression ratio will be <fr:tex display="inline"><![CDATA[> 1]]></fr:tex> because each token corresponds to a character potentially consisting of more than one byte.</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:strong>Problems:</html:strong>
  <html:ol><html:li>Very large vocabulary</html:li>
    <html:li>Many characters are quite rare.</html:li></html:ol>
</html:div>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
There is a fundamental <html:strong>tradeoff</html:strong> between compression ratio and vocabulary size. As an example, suppose we map every sequence of <fr:tex display="inline"><![CDATA[n]]></fr:tex> bytes to a token. This would achieve a compression ratio of <fr:tex display="inline"><![CDATA[n]]></fr:tex>. However, this would require <fr:tex display="inline"><![CDATA[256^n]]></fr:tex> tokens in our vocabulary.
</fr:mainmatter></fr:tree>

<html:p>
  Problem 2 was not entirely straight-forward to me. This actually reminds me of an idea from my <fr:link href="/004B/" title="Notebook: Information Theory" uri="https://kellenkanarios.com/004B/" display-uri="004B" type="local">information theory</fr:link> course, where we can assume we are given a "prior" over human language then we want to map low-probability characters to large strings in order to minimize the expected length (see <fr:link href="/005Z/" title="Huffman Code" uri="https://kellenkanarios.com/005Z/" display-uri="005Z" type="local">huffman coding</fr:link>).
</html:p>
</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Byte-based tokenization">Byte-based tokenization</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>In byte-based tokenization, each byte is a token achieving a compression ratio of exactly <fr:tex display="inline"><![CDATA[1]]></fr:tex>, where a byte <fr:tex display="inline"><![CDATA[\mapsto  [0, 256]]]></fr:tex>
. This is very elegant in the sense that our vocabulary size is fixed at <fr:tex display="inline"><![CDATA[256]]></fr:tex>.
</html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:strong>Problem:</html:strong>
However, with this, the length of our encoding is # of bytes in the string, which will become too long.
</html:div>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Word-based tokenization">Word-based tokenization</fr:title></fr:frontmatter><fr:mainmatter>
  <html:p>
In <html:em>word-based tokenization</html:em>, we simply split the string into the corresponding words then map each of these to a unique integer.
    </html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
  <html:strong>Problem:</html:strong> The vocabulary size is "unbounded" i.e. if we see a word we have not seen before then we need to extend the vocabulary size.
</html:div>

</fr:mainmatter></fr:tree>

  <fr:tree show-metadata="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:title text="Byte Pair Encoding">Byte Pair Encoding</fr:title></fr:frontmatter><fr:mainmatter>
<html:p>For the <html:em>byte pair encoding</html:em> (BPE), we instead <html:em>train</html:em> the tokenizer on raw text to automatically determine the vocabulary.</html:p>

    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
In GPT2, they first split the raw text into words and then do this byte pair encoding.
</fr:mainmatter></fr:tree>

<html:p><html:strong>Algorithm:</html:strong></html:p>

 <html:div class="jms-indent-block" style="
  margin-left: 1em;
  margin-bottom: 1em;
  border-left: 4px solid black;
  padding-left: 12px;
  background-color: whitesmoke;
  ">
<html:em>while</html:em> <html:strong>true</html:strong>:
<html:ol><html:li>Count occurences of byte pairs. Store in dict <fr:tex display="inline"><![CDATA[D]]></fr:tex> with <fr:tex display="inline"><![CDATA[\{(b_1, b_2): \text {count}\}]]></fr:tex></html:li>
  <html:li>Find <fr:tex display="inline"><![CDATA[(b_1, b_2)]]></fr:tex> with highest count.</html:li>
  <html:li>Merge <fr:tex display="inline"><![CDATA[(b_1, b_2)]]></fr:tex> by <fr:tex display="inline"><![CDATA[(b_{1}, b_{2}) \mapsto  b']]></fr:tex></html:li>
  <html:li>Replace all instances of <fr:tex display="inline"><![CDATA[(b_{1}, b_{2})]]></fr:tex> in string with <fr:tex display="inline"><![CDATA[b']]></fr:tex> i.e. 
  <fr:tex display="block"><![CDATA[b_{1} b_{2} b_{3} b_{4} \mapsto  b'b_{3} b_{4}]]></fr:tex></html:li></html:ol>
</html:div>


    <fr:tree show-metadata="false" toc="false"><fr:frontmatter><fr:authors><fr:author><fr:link href="/kellenkanarios/" title="Kellen Kanarios" uri="https://kellenkanarios.com/kellenkanarios/" display-uri="kellenkanarios" type="local">Kellen Kanarios</fr:link></fr:author></fr:authors><fr:date><fr:year>2025</fr:year><fr:month>7</fr:month><fr:day>1</fr:day></fr:date><fr:taxon>Remark</fr:taxon></fr:frontmatter><fr:mainmatter>
  There are a few additional implementation details to consider for project 1.
<html:ol><html:li><fr:tex display="inline"><![CDATA[\mathsf {encode}]]></fr:tex> loops over all merges. Only loop over merges that matter.</html:li>
  <html:li>Detect and preserve special tokens (e.g. &lt;|endoftext|&gt;)</html:li>
  <html:li>Use pre-tokenization (GPT2 regex)</html:li></html:ol>
</fr:mainmatter></fr:tree>

</fr:mainmatter></fr:tree>
</fr:mainmatter>
                </fr:tree>
              </fr:mainmatter>
            </fr:tree>
          </fr:mainmatter>
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Related">Related</fr:title>
      </fr:frontmatter>
      <fr:mainmatter>
        <fr:tree show-metadata="true" expanded="false" toc="false" numbered="false">
          <fr:frontmatter>
            <fr:authors />
            <fr:uri>https://kellenkanarios.com/stanford/</fr:uri>
            <fr:display-uri>stanford</fr:display-uri>
            <fr:route>/stanford/</fr:route>
            <fr:title text="Stanford University">Stanford University</fr:title>
            <fr:taxon>Institute</fr:taxon>
            <fr:meta name="external">https://www.stanford.edu/</fr:meta>
          </fr:frontmatter>
          <fr:mainmatter />
        </fr:tree>
      </fr:mainmatter>
    </fr:tree>
    <fr:tree show-metadata="false" hidden-when-empty="true">
      <fr:frontmatter>
        <fr:authors />
        <fr:title text="Contributions">Contributions</fr:title>
      </fr:frontmatter>
      <fr:mainmatter />
    </fr:tree>
  </fr:backmatter>
</fr:tree>
